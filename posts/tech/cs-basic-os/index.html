<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>计算机基础知识总结（系统篇） | 向着悠远的苍穹</title>
<meta name="keywords" content="C&#43;&#43;, 基础知识, 操作系统">
<meta name="description" content="内存模型, Linux用户空间内存分布, 程序内存空间, 虚拟内存, new, delete, malloc, free, brk, mmap, ptmalloc, tcmalloc, 内存对敌, 用户态, 内核态, 中断, 系统调用, 缺页中断, 虚表, 虚表指针">
<meta name="author" content="
作者:&nbsp;kdjlyy">
<link rel="canonical" href="https://kdjlyy.github.io/posts/tech/cs-basic-os/">

<link crossorigin="anonymous" href="/assets/css/stylesheet.4a1e83b1dc991b987e09d59a3232bf231a50d897a91cd64f5577a412f11bd136.css" integrity="sha256-Sh6DsdyZG5h&#43;CdWaMjK/IxpQ2JepHNZPVXekEvEb0TY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kdjlyy.github.io/img/logo.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://kdjlyy.github.io/img/logo.ico">
<link rel="icon" type="image/png" sizes="32x32" href="https://kdjlyy.github.io/img/logo.ico">
<link rel="apple-touch-icon" href="https://kdjlyy.github.io/logo.ico">
<link rel="mask-icon" href="https://kdjlyy.github.io/logo.ico">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            },
            "HTML-CSS": {
                availableFonts: ["Arial", "TeX"],
                preferredFont: "TeX",
                webFont: "TeX"
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>


<html>

<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css" />
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
    
    
    <style>
        body {
             
            font-family: "LXGW WenKai Lite", sans-serif;
             
            font-family: "LXGW WenKai Screen", sans-serif;
        }
    </style>
</head>

</html>



<script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.1.6/mermaid.min.js"></script>
<script>
    mermaid.initialize({
        startOnLoad: true,
        theme: localStorage.getItem("pref-theme") === "dark" ? "dark" : "forest" 
    });
</script>
<meta property="og:title" content="计算机基础知识总结（系统篇）" />
<meta property="og:description" content="内存模型, Linux用户空间内存分布, 程序内存空间, 虚拟内存, new, delete, malloc, free, brk, mmap, ptmalloc, tcmalloc, 内存对敌, 用户态, 内核态, 中断, 系统调用, 缺页中断, 虚表, 虚表指针" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kdjlyy.github.io/posts/tech/cs-basic-os/" />
<meta property="og:image" content="https://s1.ax1x.com/2023/07/02/pCDNi8O.jpg" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-16T15:31:26+08:00" />
<meta property="article:modified_time" content="2023-05-18T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://s1.ax1x.com/2023/07/02/pCDNi8O.jpg" />
<meta name="twitter:title" content="计算机基础知识总结（系统篇）"/>
<meta name="twitter:description" content="内存模型, Linux用户空间内存分布, 程序内存空间, 虚拟内存, new, delete, malloc, free, brk, mmap, ptmalloc, tcmalloc, 内存对敌, 用户态, 内核态, 中断, 系统调用, 缺页中断, 虚表, 虚表指针"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "文章",
      "item": "https://kdjlyy.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "👨🏻‍💻 技术",
      "item": "https://kdjlyy.github.io/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "计算机基础知识总结（系统篇）",
      "item": "https://kdjlyy.github.io/posts/tech/cs-basic-os/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机基础知识总结（系统篇）",
  "name": "计算机基础知识总结（系统篇）",
  "description": "内存模型, Linux用户空间内存分布, 程序内存空间, 虚拟内存, new, delete, malloc, free, brk, mmap, ptmalloc, tcmalloc, 内存对敌, 用户态, 内核态, 中断, 系统调用, 缺页中断, 虚表, 虚表指针",
  "keywords": [
    "C++", "基础知识", "操作系统"
  ],
  "articleBody": "Linux用户空间内存分布 程序内存在地址空间中的分布情况称为内存模型。\n对于32位环境，理论上程序可以拥有4GB的虚拟地址空间，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间。\nLinux默认将高地址的1GB空间分配给内核。也就是说，应用程序只能使用剩下3GB的地址空间，称为用户空间。\nLinux用户空间内存分布 内存分区 说明 text段（程序代码 区） 存放已编译程序的机器代码，只读。 rodata段（常量区） 存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。 data段（全局数据区的已初始化部分） 存放已经初始化的全局变量和静态变量等，这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。 bss段（全局数据区的未初始化部分） 存放未初始化的全局变量和静态变量等。 heap（堆区） 一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。 文件/内存映射区（动态链接库） 用于在程序运行期间加载和卸载动态链接库。例如使用 mmap() 创建内存映射区时，就是在这里申请的内存空间。 stack（栈区） 存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。 Linux程序内存空间 Linux 下内存资源是通过虚拟内存管理的，在分配内存时并不是在物理内存开辟了一段空间，而是在使用时才分配的，并且是通过段页式管理。linux 下内存分配是以页为单位的，而页是通过段管理。各个段之间是独立的，方便管理。\nLinux 程序执行时能够分为下面几个内存段：text、rodata、data、bss、stack、heap。\ntext 段（代码段）：text 段存放程序代码，运行前就已经确定（编译时确定），通常为只读； rodata 段（常量区）：rodata 段存储常量数据，比如程序中定义为 const 的全局变量，“#define”定义的常量，以及诸如“Hello World”的字符串常量。const 修饰的全局变量在常量区，const 修饰的局部变量只是为了防止修改，没有放入常量区（存在栈区）； data 段：data 存储已经初始化的全局变量（静态变量），属于静态内存分配，需要占用可执行文件空间（注意：初始化为0的全局变量和静态变量还是被保存在 bss 段）； bss 段：bss 段存储没有初始化或初始化为0的全局变量（静态变量），属于静态内存分配。bss 不占用可执行文件空间，其内容由操作系统初始化（清零），但占据程序运行时的内存空间； stack 段：stack 段存储参数变量和局部变量，由系统进行申请和释放，属于静态内存分配； heap 段：heap 段是程序运行过程中动态分配的内存段，由用户申请和释放，程序中不释放，则程序结束时，由 OS 回收。 执行文件中包含了 text、rodata、data 段的内容，不包含 bss 段内容（一堆0放入执行文件没有意义）。 堆和栈的内存增长方向是相反的：栈是从高地址向低地址生长，堆是从低地址向高地址生长。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const int NUM = 10086; // 常量区(rodata段) int a = 10; // 全局初始化区（data） char *p1; // 全局未初始化区（bss） int main() { int b; // 栈区 char s[] = \"abc\"; // 栈区 char *p; // 栈区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); // 分配得来的10和20字节的区域就在堆区 static int c =0; // bss段 const int d = 5; // stack段 char *p3 = \"123456\"; // p3在栈区，\"123456\\0\" 在rodata段 strcpy(p1, \"123456\"); // \"123456\\0\" 放在rodata段，编译器可能会将它与p3所指向的\"123456\"优化成一个地方。 } 虚拟内存 物理内存是实际的物理空间，即直接映射到硬件 RAM 的物理内存资源。\n虚拟内存是逻辑上的地址空间，它通过将物理内存和硬盘空间组合使用，从逻辑上扩展了物理内存的大小，从而让程序获得更多的可用内存。\n为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个页（Linux下页大小为4KB，即4096字节）。而物理内存则被分成相同大小的页面帧，程序的页被映射到物理内存对应的帧（但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中）。当程序访问到不在物理内存中的页时，发生缺页中断，将缺失的页装入物理内存并重新执行失败的指令。\n从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生16位地址，那么一个程序的地址空间范围是0~64K。该计算机只有32KB的物理内存，虚拟内存技术允许该计算机运行一个64K大小的程序。\n虚拟内存 new/delete 和 malloc/free new 和 delete 是用户进行动态内存申请和释放的操作符，operator new 和 operator delete 是系统提供的全局函数，new 在底层调用 operator new 全局函数来申请空间，delete 在底层通过 operator delete 全局函数来释放空间。\nnew的过程\n调用 operator new 函数申请空间； 在申请的空间上执行构造函数，完成对象的构造。 delete的过程\n在申请的空间上执行析构函数，完成对象中资源的清理工作； 调用 operator delete 函数释放对象的空间。 new T[N]的过程\n调用 operator new[] 函数，在 operator new[] 中实际调用 operator new 函数完成N个对象空间的申请； 在申请的空间上执行N次构造函数。 delete[]的过程\n在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理； 调用 operator delete[] 释放空间，实际在 operator delete[] 中调用 operator delete 来释放空间。 new/delete 和 malloc/free的异同 相同点是: 都是从堆上申请空间，并且需要用户手动释放。\n不同点是:\nmalloc 和 free 是函数，new 和 delete 是操作符； malloc 申请的空间不会初始化，new 可以初始化； malloc 申请空间时，需要手动计算空间大小并传递，new 只需在其后跟上空间的类型即可； malloc 的返回值为 void*, 在使用时必须强转；new 不需要，因为 new 后跟的是空间的类型； malloc 申请空间失败时，返回的是 NULL，因此使用时必须判空；new 不需要，但是 new 需要捕获异常； 申请自定义类型对象时，malloc/free 只会开辟与销毁空间，不会调用构造函数与析构函数；而 new 在申请空间后会调用构造函数完成对象的初始化，delete 在释放空间前会调用析构函数完成空间中资源的清理； new/delete 比 malloc/free 的效率稍微低点，因为 new/delete 的底层封装了 malloc/free。 free 如何知道要 free 多大的空间 malloc 函数的实现是以块分配内存，在被分配的块中包括两部分：\n第一部分中存储含有报头的元数据，它其中包含有分配块的大小信息，是一个常量； 第二部分中存储实际用户数据。而使用 malloc 分配内存返回的是第二部分用户数据的地址。 所以内存释放时不再需要再指定释放多大的内存空间，只需要指定该块内存空间的首地址即可。\nnew 一个对象时加括号和不加括号的区别 对于内置类型：\nint *a = new int; 不会将申请到的 int 空间初始化，而 int *a = new int(); 则会将申请到的 int 空间初始化为0。\n1 2 int *a1 = new int[10]; // 10个未初始化int int *a2 = new int[10](); // 10个值初始化为0的int 对于自定义类类型：\n如果该类显式定义了默认构造函数，那么 class c = new class; 和 class c = new class(); 一样，都会调用默认构造函数。\n如果该类没有显式定义构造函数（由编译器生成默认构造函数）但有虚函数，那么 class c = new class; 和 class c = new class(); 一样，都会调用默认构造函数；\n如果该类没有显式定义构造函数（由编译器生成默认构造函数）也没有虚函数，那么 class c = new class 将不调用合成的默认构造函数，而 class c = new class() 则会调用默认构造函数。\nmalloc/free 实现原理 brk 和 mmap 函数 brk() 和 sbrk() 函数：作用是扩展 heap 的上界 brk\n1 2 3 4 5 // addr为新的brk地址，成功返回0，失败返回-1 int brk(const void *addr); // incr为需要申请的内存大小，返回heap新的上界brk地址。若sbrk的参数为0，则返回原来的brk地址 void* sbrk (intptr_t incr); mmap() 和 munmap() 函数：映射磁盘文件到内存中或匿名映射（向映射区申请一块内存）\n1 2 3 4 5 6 7 // addr为映射区的开始地址，length为映射区的长度，prot为期望的内存保护标志， // flags指定映射对象的类型，fd为文件描述符，offset为文件映射的偏移量，通常设置为0， // 代表从文件最前方开始对应，offset必须是分页大小的整数倍 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); // munmap执行与mmap相反的操作，删除特定地址区域的对象映射 int munmap(void *addr, size_t length); 实现原理 malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。\n方式一：如果用户分配的内存 $\u003c128 KB$，则通过 brk() 系统调用从堆分配内存；\n方式二：如果用户分配的内存 $\\geq128 KB$，则通过 mmap() 系统调用在文件/内存映射区域分配内存。\nbrk 是将 heap 的上界指针 brk 往高地址推，mmap 是在进程的虚拟地址空间中（堆和栈中间，称为内存/文件映射区域的地方）找一块空闲的虚拟内存。 这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。\nbrk 分配的内存需要等到高地址内存释放以后才能释放（这就是内存碎片产生的原因），当最高地址空间的空闲内存超过128K（可由 M_TRIM_THRESHOLD 选项调节）时，执行内存紧缩操作（trim）。 mmap 分配的内存可以单独释放。\nbrk和mmap 调用 free(A) 后 A 对应的虚拟内存和物理内存都没有释放，因为只有一个 brk 指针，如果往回推，那么 B 这块内存怎么办呢？\n当然 A 这块内存是可以重用的，如果这个时候再来一个 40KB 的请求，那么 malloc 很可能就使用 A 这块内存。\n进程调用 free(B) 以后，A 和 B 连接起来，变成一块 150KB 的空闲内存，于是内存紧缩。\nmalloc 采用了内存池的实现方式：先申请一大块内存，然后将内存分成不同大小的内存块，用户申请内存时，直接从内存池中选择一块相近的内存块即可。brk 分配内存时优先从内存池获取，失败的话走 brk 系统调用。细节参考：简书：glibc内存管理那些事儿\n既然堆内内存 brk 和 sbrk 不能直接释放，导致疑似“内存泄露”问题，为什么不全部使用 mmap 来分配，munmap 直接释放，而是仅仅对于大于 128K 的大块内存才使用 mmap？\n因为 brk 和 mmap 都是系统调用，频繁调用系统调用都比较消耗系统资源。使用 mmap 申请的空间，直接调用 munmap 是将空间真正释放了，而 brk 释放的空间，并不一定真正释放了，那些没有被真正释放的内存碎片可以被重复利用，再次访问该内存可能不需产生任何系统调用和缺页中断，这将大大降低 CPU 的消耗。\nmalloc 和 tcmalloc malloc 和 tcmalloc 都是内存分配库，主要的不同在于实现方式和效率。\nmalloc 是C标准库中的一部分，是系统提供的内存分配器。它的主要作用是管理进程虚拟内存空间，负责分配和释放内存资源。但是，由于多线程并发执行时需要加锁，所以它的性能并不是最优的。 tcmalloc 是 Google 开发的一个高性能、多线程的内存管理库，是 malloc 的替代品之一。tcmalloc 采用线程本地缓存技术（Thread-Caching Malloc，TCMalloc），避免了锁的竞争，从而在多线程环境下具有更好的性能表现。此外，tcmalloc 还会将未使用的页面设置为“dirty”状态，提高缓存命中率，进一步提升了其效率。 总的来说，tcmalloc 比 malloc 具有更高的性能和更好的可扩展性，在大型高并发的应用场景中使用更为适合。但是，tcmalloc 也相对较复杂，需要结合实际情况进行使用和优化。\n参考：内存优化总结:ptmalloc、tcmalloc和jemalloc、ptmalloc、tcmalloc与jemalloc对比分析\n内存管理可以分为三个层次，自底向上分别是：\n内核层 C运行时库层（glibc 层使用系统调用维护的内存管理算法） 应用程序层（应用程序从 glibc 动态分配内存后，根据应用程序本身的程序特性进行优化，比如使用引用计数 std::shared_ptr，内存池方式等） 现状 目前大部分服务端程序使用 glibc 提供的 malloc/free 系列函数，而 glibc 使用的 ptmalloc2 在性能上远远弱后于 google 的 tcmalloc 和 facebook 的 jemalloc。而且后两者只需要使用 LD_PRELOAD 环境变量启动程序即可，甚至并不需要重新编译。\nptmalloc2 ptmalloc2 即是我们当前使用的 glibc malloc 版本。\nptmalloc2 操作 heap 时，一般大内存采用 mmap，小内存使用 brk。\n🔰 主分配区和非主分配区\nptmalloc 的内存分配器中，为了解决多线程锁争夺问题，分为主分配区（main_area）和非主分配区（no_main_area）。\n每个进程有一个主分配区，也可以允许有多个非主分配区。 主分配区可以使用 brk 和 mmap 来分配内存，而非主分配区只能使用 mmap 来映射内存块（批发申请 HEAP_MAX_SIZE 大小的虚拟内存）。当用户向非主分配区请求分配内存时再切割成小块“零售” 出去，毕竟系统调用是相对低效的，直接从用户空间分配内存快多了。所以 ptmalloc 在必要的情况下才会调用 mmap 函数向操作系统申请虚拟内存。 非主分配区的数量一旦增加，则不会减少。 主分配区和非主分配区形成一个环形链表进行管理。 当某一线程需要调用 malloc 分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么 malloc 会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。\n在释放操作中，线程同样试图获得待释放内存块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行释放操作。\n🔰 chunk 内存块的基本组织单元\nptmalloc 通过 chunk 的数据结构来组织每个内存单元。当我们使用 malloc 分配得到一块内存的时候，这块内存就会通过 chunk 的形式被 glibc 管理起来。你可以把它想象成自己写内存池的时候的一个内存数据结构。chunk 的结构可以分为使用中的 chunk 和空闲的 chunk。\n空闲的 chunk 会被放置到空闲的链表 bins 上。当用户 malloc 申请内存的时候，会先去查找空闲链表 bins上是否有合适的内存。\n🔰 空闲链表 bins\n当用户使用 free 函数释放掉的内存，ptmalloc 并不会马上交还给操作系统，而是被 ptmalloc 本身的空闲链表 bins 管理起来了，这样当下次进程需要 malloc 一块内存的时候，ptmalloc 就会从空闲的 bins 上寻找一块合适大小的内存块分配给用户使用。这样的好处可以避免频繁的系统调用，降低内存分配的开销。\nptmalloc ptmalloc 一共维护了128个 bin。每个 bin 都维护了大小相近的双向链表的 chunk。通过上图这个 bins 的列表就能看出，当用户调用 malloc 的时候，能很快找到用户需要分配的内存大小是否在维护的 bin 上，如果在某一个 bin 上，就可以通过双向链表去查找合适的 chunk 内存块给用户使用。\nfast bins：fast bins 是 bins 的高速缓冲区，大约有10个定长队列。当用户释放一块不大于 max_fast（默认值64B）的 chunk 的时候，会默认会被放到 fast bins 上。当用户下次需要申请内存的时候首先会到 fast bins 上寻找是否有合适的 chunk。ptmalloc 会遍历 fast bin，看是否有合适的 chunk 需要合并到 bins 上。 unsorted bin：是 bins 的一个缓冲区。当用户释放的内存大于 max_fast 或者 fast bins 合并后的 chunk 都会进入 unsorted bin 上。当用户 malloc 的时候，先会到 unsorted bin 上查找是否有合适的 bin，如果没有合适的 bin，ptmalloc 会将 unsorted bin 上的 chunk 放入 bins 上，然后到 bins 上查找合适的空闲 chunk。 small bins 和 large bins：small bins 和 large bins 是真正用来放置 chunk 双向链表的。每个 bin 之间相差8个字节，并且通过上面的这个列表，可以快速定位到合适大小的空闲 chunk。前64个为 small bins 定长；后64个为 large bins，非定长。 Top chunk：并不是所有的 chunk 都会被放到 bins 上。top chunk 相当于分配区的顶部空闲内存，当 bins 上都不能满足内存分配要求的时候，就会来 top chunk 上分配。 mmaped chunk：当分配的内存非常大（大于分配阀值，默认128K）的时候，需要被 mmap 映射，则会放到 mmaped chunk 上，当释放 mmaped chunk 上的内存的时候会直接交还给操作系统。 ✏️ 内存分配 malloc() 的流程\nmalloc()的流程 获取分配区的锁，防止多线程冲突；\n计算出需要分配的内存的 chunk 实际大小；\n判断chunk的大小，如果小于 max_fast（64B），则取 fast bins 上去查询是否有适合的 chunk，如果有则分配结束；\nchunk 大小是否小于512B，如果是，则从 small bins 上去查找 chunk，如果有合适的，则分配结束；\n继续从 unsorted bins 上查找：\n如果 unsorted bins 上只有一个 chunk 并且大于待分配的 chunk，则进行切割，并且剩余的 chunk 继续扔回 unsorted bins；\n如果 unsorted bins 上有大小和待分配 chunk 相等的，则返回，并从 unsorted bins 删除；\n如果 unsorted bins 中的某一 chunk 大小属于 small bins 的范围，则放入 small bins 的头部；\n如果 unsorted bins 中的某一 chunk 大小属于 large bins 的范围，则找到合适的位置放入；\n从 large bins 中查找，找到链表头后，反向遍历此链表，直到找到第一个大小大于待分配的 chunk，然后进行切割，如果有余下的，则放入 unsorted bin 中去，分配则结束；\n如果搜索 fast bins 和其他 bins 都没有找到合适的 chunk，那么就需要操作 top chunk 来进行分配了（top chunk 相当于分配区的剩余内存空间）。判断 top chunk 大小是否满足所需 chunk 的大小，如果是，则从 top chunk 中分出一块来；\n如果 top chunk 也不能满足需求，则需要扩大 top chunk。主分区上，如果分配的内存小于分配阀值（默认128K），则直接使用 brk 分配一块内存；如果分配的内存大于分配阀值，则需要 mmap 来分配。\n非主分区上，则直接使用 mmap 来分配一块内存。通过 mmap 分配的内存，就会放入 mmaped chunk 上，mmaped chunk 上的内存会直接回收给操作系统。\n✏️ 内存释放 free() 的流程\n获取分配区的锁，保证线程安全；\n如果 free 的是空指针，则返回，什么都不做；\n判断当前 chunk 是否是 mmap 映射区域映射的内存，如果是，则直接 munmap 释放这块内存。已使用 chunk 的数据结构中，有对应的标识判断是否是 mmap 映射的内存；\n判断 chunk 是否与 top chunk 相邻，如果相邻，则直接和 top chunk 合并（和 top chunk 相邻相当于和分配区中的空闲内存块相邻），转到步骤8；\n如果 chunk 的大小大于 max_fast（64B），则放入 unsorted bin，并且检查是否有合并，有合并情况并且和 top chunk 相邻，则转到步骤8；没有合并情况则 free；\n如果 chunk 的大小小于 max_fast（64B），则直接放入 fast bin，fast bin 并没有改变 chunk 的状态。没有合并情况，则 free；有合并情况，转到步骤7；\n在 fast bin，如果当前 chunk 的下一个 chunk 也是空闲的，则将这两个 chunk 合并，放入 unsorted bin 上面。合并后的大小如果大于64KB，会触发进行 fast bins 的合并操作，fast bins 中的 chunk 将被遍历，并与相邻的空闲 chunk 进行合并，合并后的 chunk 会被放到 unsorted bin 中，fast bin 会变为空。合并后的 chunk 和 top chunk 相邻，则会合并到 top chunk 中。转到步骤8；\n判断 top chunk 的大小是否大于 mmap 收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还 top chunk 中的一部分给操作系统。free 结束。\n✏️ ptmalloc 的问题\nptmalloc 的主要问题其实是内存浪费、内存碎片、以及加锁导致的性能问题。\n内存浪费：\n每个 chunk 本身至少8字节的开销很大；\n后分配的内存先释放，可能无法及时归还系统。因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放，top chunk 以下的 chunk 都无法释放；\n内存不能在线程间移动，多线程使用内存不均衡将导致内存浪费。\n内存碎片：不定期分配长生命周期的内存容易造成内存碎片，不利于回收。\n加锁导致的性能问题：加锁耗时，无论当前分区有无耗时，在内存分配和释放时，会首先加锁。\ntcmalloc tcmalloc 是 Google 开源的一个内存管理库， 作为 glibc malloc 的替代品。目前已经在 chrome、safari 等知名软件中运用。\n🔰 对象分配\ntcmalloc 为每个线程分配了一个线程本地 ThreadCache，小内存从 ThreadCache 分配，此外还有个中央堆（CentralCache），ThreadCache 不够用的时候，会从 CentralCache中 获取空间放到 ThreadCache 中。 小对象（$\\leq32KB$）从 ThreadCache 分配，大对象从 CentralCache 分配。大对象分配的空间都是4K页面对齐的，多个 pages 也能切割成多个小对象划分到 ThreadCache 中。 ✏️ tcmalloc的优势\n小内存可以在 ThreadCache 中不加锁分配（加锁的代价大约100ns） 大内存可以直接按照大小分配不需要再像 ptmalloc 一样进行查找 大内存加锁使用更高效的自旋锁 减少了内存碎片 内存对齐 什么是内存对齐 现代计算机中内存空间都是按照字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。\n为什么要内存对齐 主要是由于 CPU 的访问内存的特性决定，CPU 访问内存时并不是以字节为单位来读取内存，而是以机器字长为单位，实际机器字长由 CPU 数据总线宽度决定的。实际 CPU 运行时，每一次控制内存读写信号发生时，CPU 可以从内存中读取数据总线宽度的数据，并将其写入到 CPU 的通用寄存器中。内存对齐的主要目的是为了减少 CPU 访问内存的次数。假设读取8个字节的数据，按照每次读取4个字节的速度，则8个字节需要 CPU 耗费2次读取操作。CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数。\n怎么使用内存对齐 我们可以用#progma pack(x)指定结构体以x为单位进行对齐。一般情况下使用方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #pragma pack(push) /* push current alignment to stack */ #pragma pack(1) /* set alignment to 1 byte boundary */ struct MyPackedData { char Data1; // 1 byte long Data2; // 8 byte(64位环境) char Data3; // 1 byte }; #pragma pack(pop) /* restore original alignment from stack */ int main() { cout \u003c\u003c alignof(MyPackedData) \u003c\u003c endl; // 1 cout \u003c\u003c sizeof(MyPackedData) \u003c\u003c endl; // 10 return 0; } C++11之后提供了alignas关键字，允许往更大的字节数去对齐（有的平台不支持未对齐内存访问，alignas 的目的是允许你往更大的字节数去对齐，比如 char 对齐到32位供 SIMD load）。\n即 pack 是变小，alignas 是变大，用法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct alignas(1) Point // 使用g++能正常运行，但是在CLion中会报错，因为这样做是不合规范（ill-formed）的 { int a; char b; }p; cout \u003c\u003c alignof(p) \u003c\u003c endl; // 4 cout \u003c\u003c sizeof(p) \u003c\u003c endl; // 8 #pragma pack(push) #pragma pack(1) struct Point2 { int a; char b; }p2; #pragma pop(pop) cout \u003c\u003c alignof(p2) \u003c\u003c endl; // 1 cout \u003c\u003c sizeof(p2) \u003c\u003c endl; // 4 用户态与内核态 用户态/内核态的概念 CPU 指令可以直接操作硬件，而对于硬件的操作是非常复杂的，出问题的几率相当大，所以操作系统内核直接屏蔽了个人开发者对于硬件操作的可能。因为这个需求，硬件设备商直接提供了硬件级别的支持，做法就是对 CPU 指令设置了权限，不同级别的权限可以使用的 CPU 指令是有限制的。\n以 Intel CPU 为例，CPU 指令操作的权限划为4级：ring 0、ring 1、ring 2、ring 3。其中ring 0权限最高，可以使用所有 CPU 指令，ring 3 权限最低，仅能使用常规 CPU 指令，不能使用访问硬件资源的指令，比如 I/O读写、网卡访问、申请内存等。\nLinux 系统内核采用了：ring 0 和 ring 3 这2个权限\nring 0 被叫做 内核态，完全在操作系统内核中运行，由专门的内核线程执行其任务； ring 3 被叫做 用户态，在应用程序中运行，由用户线程执行其任务。 切换方式 从用户态到内核态切换可以通过三种方式，或者说会导致从用户态切换到内核态的操作：\n系统调用：系统调用本身就是中断，属于软件中断，跟硬件中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。比如我们使用库函数 fopen 打开文件，就会触发 open 系统调用。 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中。 外围设备中断：硬件中断，外围设备完成用户请求的操作之后，会向 CPU 发出中断信号，这时 CPU 会转去处理对应的中断处理程序。 切换过程 当发生用户态到内核态的切换时，会发生如下过程（本质上是从“用户程序”切换到“内核程序”）\n设置处理器至内核态；\n保存当前程序的寄存器（栈指针、程序计数器、通用寄存器）；\n将栈指针设置指向内核栈地址；\n执行中断处理程序；\n恢复之前保存的寄存器，从中断处理程序返回。\n具体流程参考：中断（系统调用）的具体过程\n中断（系统调用）的具体过程 总结： 用户运行库函数（系统调用的封装），函数里面其实是执行的 int 0x80 指令。系统调用先把系统调用号保存在 eax 寄存器中，然后执行 int 0x80 指令。int 0x80 指令先进行切换堆栈（找到进程的堆栈，将寄存器值压入到内核栈中，将 esp，ss 设置成对应内核栈的值），查找相应中断向量的中断处理程序(system_call)并调用，随后 system_call 从系统调用表中找到相应的系统调用进行调用，调用结束后从 system_call 中返回。\n中断一般有两个属性，中断号和中断处理程序（ISR，Interrupt Service Routine）。在内核中，有一个数组称为中断向量表，包含了中断号及其对应中断处理程序的指针。中断到来时，CPU 暂停当前执行的代码，根据中断的中断号，在中断向量表中找到对应的中断处理程序，并调用它。中断处理程序执行完成之后，CPU 会继续执行之前的代码。\n由于中断号是有限的，操作系统不舍得每一个系统调用对应一个中断号，而更倾向于用一个或少数几个中断号来对应所有的系统调用。Linux 则使用 int 0x80 来触发所有系统调用。每个系统调用对应一份系统调用号，这个系统调用号在执行 int 0x80 指令前会放置在某个固定的寄存器里（eax)，对应的中断代码会取得这个系统调用号，并且调用正确的函数。\n系统调用的详细过程 触发中断 用户程序在代码中调用系统调用，执行 int 指令前将系统调用号放入 eax 寄存器中，执行 int 0x80 指令（int 指令最终执行的函数是 system_call，该函数验证系统调用号的有效性，查找系统调用函数并执行，最后通过 itret 指令从中断处理程序返回）。\n切换堆栈（此步在 int 指令中完成） 在实际执行 0x80 号中断向量所对应的中断处理程序（system_call）之前，CPU 首先要进行堆栈切换，即从用户态切换到内核态。所谓的当前栈，指得是 esp（栈指针）的值所在的栈空间。如果 esp 的值位于用户栈的范围内，那么程序的当前栈就是用户栈，反之亦然。此外，寄存器 ss 的值还应该指向当前栈所在的页。\n所以，将当前栈由用户栈切换为内核栈（用户态切换到内核态）的实际行为就是：保存当前的 esp，ss 的值（保证存在内核栈上，int 指令发送后自动地由硬件完成），并将 esp，ss 的值设置为内核栈的相应值\n当 0x80 号中断发生的时候，cpu 除了切入内核态之外，还会自动完成下列几件事：\n（1）找到当前进程的内核栈（每一个进程都有自己的内核栈）\n（2）在内核栈中一次压入用户态的寄存器 ss、esp、eflags、cs、eip\n而当内核从系统调用返回的时候，须要调用 iret 指令来回到用户态，iret 指令则会从内核栈里弹出寄存器 ss、esp、eflags、cs、eip 的值，使得栈恢复到用户态的状态。\n中断时内核栈和用户栈的切换 中断处理程序 在 int 指令切换内核栈之后，程序就切换到了中断向量表中的 0x80 号中断处理程序。Linux 中 0x80 向量对应的中断处理程序是 system_call。\nsystem_call 中断服务程序首先检查系统调用号的有效性，再根据 eax 寄存器存储的系统调用号从系统调用表上找到相应的系统调用并调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // system_call的开头部分 ...... SAVE_ALL // 保存寄存器的值到栈中，以免被覆盖 ...... cmpl $(nr_syscalls), %eax // 比较eax寄存器中的值和系统调用号大1的值（验证系统调用号的有效性） jae syscall_badsys\t// 如果系统调用无效，指向syscall_badsys // 如果系统调用号有效，则会执行以下代码 syscall_call: call *sys_call_table(0, %eax, 4) // 查找中断服务程序并执行， sys_call_table其实就是系统调用表 ..... RESTORE_REGS // 恢复之前保存的寄存器 ...... iret // 从中断程序返回 恢复之前保存的寄存器，从中断处理程序返回，从内核态切换回用户态 缺页中断 在操作系统中，程序执行时需要访问的内存在虚拟内存中，不在物理内存中，此时就会发生缺页中断（该情况为硬件页缺失）。\n缺页中断的分类 软性页缺失：指页缺失发生时，相关的页已经被加载进内存，但是没有向 MMU（内存管理单元）注册的情况。操作系统只需要在 MMU 中注册相关页对应的物理地址即可。 硬性页缺失：硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。 无效页缺失：当程序访问的虚拟地址是不存在于虚拟地址空间内的时候，则发生无效页缺失。\n查看进程发生缺页中断的次数 ps -o majflt,minflt -C ps -o majflt,minflt -p majflt 代表 major fault，中文名叫大错误，minflt 代表 minor fault，中文名叫小错误。 majflt 表示需要读写磁盘，可能是内存对应页面在磁盘中需要load到物理内存中，也可能是此时物理内存不足，需要淘汰部分物理页面至磁盘中。 这两个数值表示一个进程自启动以来所发生的缺页中断的次数。\n缺页中断过程 当程序访问一个虚拟地址时，操作系统会检查该地址是否被映射到物理内存中，如果没有，则触发缺页中断：\n缺页中断会暂停程序执行，将控制权交给操作系统内核（进程会陷入内核态），保护程序现场，以免被操作系统破坏。\n内核会检查发生缺页中断的虚拟地址是否有效：\n如果虚拟地址有效，操作系统将会分配一个空闲物理页面，并把未被读取的数据从磁盘拷贝到物理内存所分配的页面中（没有空闲物理页面会触发页面置换算法），并更新页表信息。 如果虚拟地址无效，则操作系统会向进程发出一个信号或杀掉该进程。 当操作系统处理完缺页中断后，程序会恢复至发生缺页中断指令以前的状态，程序计数器重新指向这条指令。 缺页中断和缺页异常 缺页中断是指当程序访问一个虚拟内存地址时，对应的物理内存页不在主存中，需要从磁盘中加载到主存中，此时 CPU 就会发出一个中断请求，操作系统会响应中断请求，将对应的物理页加载到主存中，并重新执行产生缺页中断的指令。缺页中断是一种同步事件，也就是说，程序需要等待操作系统完成页的加载操作后才能继续执行。\n缺页异常是指当程序访问一个虚拟内存地址时，对应的物理内存页不在主存中，需要从磁盘中加载到主存中，但是此时 CPU 不会发出中断请求，而是将控制权交给操作系统，让操作系统处理缺页异常。缺页异常是一种异步事件，也就是说，程序不需要等待操作系统完成页的加载操作就可以继续执行。\n因此，缺页中断和缺页异常的主要区别在于它们是同步事件还是异步事件。缺页中断是同步事件，程序需要等待操作系统完成页的加载操作后才能继续执行；而缺页异常是异步事件，程序不需要等待操作系统完成页的加载操作就可以继续执行。\n虚表/虚表指针 为了实现 C++ 的多态，C++ 使用了一种动态绑定的技术，这个技术的核心是虚函数表。\n虚表 每个包含了虚函数的类都包含一个虚表； 一个类继承了包含虚函数的基类，那么这个类也会拥有自己的虚表； 虚表是一个指针数组，其元素是虚函数的指针，即虚表中每个元素对应一个虚函数的函数指针； 虚函数的的调用都需要经过虚表，普通函数即非虚函数，其调用并不需要经过虚表； 虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段； 虚表是属于类的，而不属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。 虚表指针 如有类中包含虚函数，编译器会自动在类中添加一个指针：*__vptr，用来指向该类的虚表； 类的对象在创建时便拥有虚表指针，且这个指针的值会自动被设置为指向类的唯一虚表。 类A的定义如下：\n1 2 3 4 5 6 7 8 9 class A { public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int m_data1, m_data2; }; 因为类A中存在（一个或多个）虚函数，编译器会自动给类A加上一个虚表指针（占8字节空间），所以sizeof(A)=16。 类A的虚表和虚表指针（__vptr）关系如下：\n虚表和虚表指针 多态相关 一个类的基类如果包含虚函数，那个这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表； 一旦继承类重写了基类的某个虚函数，那么它的虚表项也会同步更新，指向继承类重写的函数，否则指向它基类的同名函数。 通过基类的指针调用派生类中的函数称为（运行时）多态，经过虚表调用虚函数的过程称为动态绑定； 虚表和虚表指针的创建时机： 在编译的过程中编译器就为含有虚函数的类创建了虚表，并且编译器会在构造函数中插入一段代码，这段代码用来给虚指针赋值。因此虚表是在编译的过程中创建。 由于虚指针是基于对象的，所以对象在实例化的时候，虚指针就会创建，所以虚指针是在运行时创建。 此外，编译器规定一个模版函数不能为虚函数。因为模版机制需要在编译期间识别模版支持类型，对于每一种类型我们都要生成对应类型的函数体。如果这个模版函数为虚函数，我们不知道这个模版函数被生成了多少份对应类型的虚函数，也就不好确定虚表的大小，所以编译器禁止这一行为。\n更详细的内容参考：知乎：C++中虚函数、虚继承内存模型\n",
  "wordCount" : "12848",
  "inLanguage": "zh",
  "image":"https://s1.ax1x.com/2023/07/02/pCDNi8O.jpg","datePublished": "2023-05-16T15:31:26+08:00",
  "dateModified": "2023-05-18T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "kdjlyy"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kdjlyy.github.io/posts/tech/cs-basic-os/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "向着悠远的苍穹",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kdjlyy.github.io/img/logo.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kdjlyy.github.io" accesskey="h" title="向着悠远的苍穹 (Alt + H)">向着悠远的苍穹</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kdjlyy.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://kdjlyy.github.io/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://kdjlyy.github.io/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://kdjlyy.github.io/archives" title="⏱️时间轴">
                    <span>⏱️时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://kdjlyy.github.io/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://kdjlyy.github.io/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post" autonumbering>
  
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://kdjlyy.github.io">主页</a>&nbsp;»&nbsp;<a href="https://kdjlyy.github.io/posts/">文章</a>&nbsp;»&nbsp;<a href="https://kdjlyy.github.io/posts/tech/">👨🏻‍💻 技术</a></div>
    <h1 class="post-title">
      计算机基础知识总结（系统篇）
    </h1>
    <div class="post-meta">










创建:&nbsp;<span title='2023-05-16 15:31:26 +0800 CST'>2023-05-16</span>&nbsp;|&nbsp;更新:&nbsp;2023-05-18&nbsp;|&nbsp;字数:&nbsp;12848字&nbsp;|&nbsp;
作者:&nbsp;kdjlyy


      
    </div>
  </header> <aside id="toc-container" class="toc-container wide">
        <div class="toc">
            <details  open>
                <summary accesskey="c" title="(Alt + C)">
                    <span class="details">目录</span>
                </summary>

                <div class="inner"><ul>
                        <li>
                            <a href="#linux%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e5%86%85%e5%ad%98%e5%88%86%e5%b8%83" aria-label="Linux用户空间内存分布">Linux用户空间内存分布</a></li>
                        <li>
                            <a href="#linux%e7%a8%8b%e5%ba%8f%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4" aria-label="Linux程序内存空间">Linux程序内存空间</a></li>
                        <li>
                            <a href="#%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98" aria-label="虚拟内存">虚拟内存</a></li>
                        <li>
                            <a href="#newdelete-%e5%92%8c-mallocfree" aria-label="new/delete 和 malloc/free">new/delete 和 malloc/free</a><ul>
                                    
                        <li>
                            <a href="#newdelete-%e5%92%8c-mallocfree%e7%9a%84%e5%bc%82%e5%90%8c" aria-label="new/delete 和 malloc/free的异同">new/delete 和 malloc/free的异同</a></li>
                        <li>
                            <a href="#free-%e5%a6%82%e4%bd%95%e7%9f%a5%e9%81%93%e8%a6%81-free-%e5%a4%9a%e5%a4%a7%e7%9a%84%e7%a9%ba%e9%97%b4" aria-label="free 如何知道要 free 多大的空间">free 如何知道要 free 多大的空间</a></li>
                        <li>
                            <a href="#new-%e4%b8%80%e4%b8%aa%e5%af%b9%e8%b1%a1%e6%97%b6%e5%8a%a0%e6%8b%ac%e5%8f%b7%e5%92%8c%e4%b8%8d%e5%8a%a0%e6%8b%ac%e5%8f%b7%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="new 一个对象时加括号和不加括号的区别">new 一个对象时加括号和不加括号的区别</a></li></ul>
                        </li>
                        <li>
                            <a href="#mallocfree-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86" aria-label="malloc/free 实现原理">malloc/free 实现原理</a><ul>
                                    
                        <li>
                            <a href="#brk-%e5%92%8c-mmap-%e5%87%bd%e6%95%b0" aria-label="brk 和 mmap 函数">brk 和 mmap 函数</a></li>
                        <li>
                            <a href="#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86" aria-label="实现原理">实现原理</a></li></ul>
                        </li>
                        <li>
                            <a href="#malloc-%e5%92%8c-tcmalloc" aria-label="malloc 和 tcmalloc">malloc 和 tcmalloc</a><ul>
                                    
                        <li>
                            <a href="#%e7%8e%b0%e7%8a%b6" aria-label="现状">现状</a></li>
                        <li>
                            <a href="#ptmalloc2" aria-label="ptmalloc2">ptmalloc2</a></li>
                        <li>
                            <a href="#tcmalloc" aria-label="tcmalloc">tcmalloc</a></li></ul>
                        </li>
                        <li>
                            <a href="#%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90" aria-label="内存对齐">内存对齐</a><ul>
                                    
                        <li>
                            <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90" aria-label="什么是内存对齐">什么是内存对齐</a></li>
                        <li>
                            <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90" aria-label="为什么要内存对齐">为什么要内存对齐</a></li>
                        <li>
                            <a href="#%e6%80%8e%e4%b9%88%e4%bd%bf%e7%94%a8%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90" aria-label="怎么使用内存对齐">怎么使用内存对齐</a></li></ul>
                        </li>
                        <li>
                            <a href="#%e7%94%a8%e6%88%b7%e6%80%81%e4%b8%8e%e5%86%85%e6%a0%b8%e6%80%81" aria-label="用户态与内核态">用户态与内核态</a><ul>
                                    
                        <li>
                            <a href="#%e7%94%a8%e6%88%b7%e6%80%81%e5%86%85%e6%a0%b8%e6%80%81%e7%9a%84%e6%a6%82%e5%bf%b5" aria-label="用户态/内核态的概念">用户态/内核态的概念</a></li>
                        <li>
                            <a href="#%e5%88%87%e6%8d%a2%e6%96%b9%e5%bc%8f" aria-label="切换方式">切换方式</a></li>
                        <li>
                            <a href="#%e5%88%87%e6%8d%a2%e8%bf%87%e7%a8%8b" aria-label="切换过程">切换过程</a></li></ul>
                        </li>
                        <li>
                            <a href="#span-idsystem_call%e4%b8%ad%e6%96%ad%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e7%9a%84%e5%85%b7%e4%bd%93%e8%bf%87%e7%a8%8bspan" aria-label="中断（系统调用）的具体过程"><span id="system_call">中断（系统调用）的具体过程</span></a></li>
                        <li>
                            <a href="#%e7%bc%ba%e9%a1%b5%e4%b8%ad%e6%96%ad" aria-label="缺页中断">缺页中断</a><ul>
                                    
                        <li>
                            <a href="#%e7%bc%ba%e9%a1%b5%e4%b8%ad%e6%96%ad%e7%9a%84%e5%88%86%e7%b1%bb" aria-label="缺页中断的分类">缺页中断的分类</a></li>
                        <li>
                            <a href="#%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e5%8f%91%e7%94%9f%e7%bc%ba%e9%a1%b5%e4%b8%ad%e6%96%ad%e7%9a%84%e6%ac%a1%e6%95%b0" aria-label="查看进程发生缺页中断的次数">查看进程发生缺页中断的次数</a></li>
                        <li>
                            <a href="#%e7%bc%ba%e9%a1%b5%e4%b8%ad%e6%96%ad%e8%bf%87%e7%a8%8b" aria-label="缺页中断过程">缺页中断过程</a></li>
                        <li>
                            <a href="#%e7%bc%ba%e9%a1%b5%e4%b8%ad%e6%96%ad%e5%92%8c%e7%bc%ba%e9%a1%b5%e5%bc%82%e5%b8%b8" aria-label="缺页中断和缺页异常">缺页中断和缺页异常</a></li></ul>
                        </li>
                        <li>
                            <a href="#%e8%99%9a%e8%a1%a8%e8%99%9a%e8%a1%a8%e6%8c%87%e9%92%88" aria-label="虚表/虚表指针">虚表/虚表指针</a><ul>
                                    
                        <li>
                            <a href="#%e8%99%9a%e8%a1%a8" aria-label="虚表">虚表</a></li>
                        <li>
                            <a href="#%e8%99%9a%e8%a1%a8%e6%8c%87%e9%92%88" aria-label="虚表指针">虚表指针</a></li>
                        <li>
                            <a href="#%e5%a4%9a%e6%80%81%e7%9b%b8%e5%85%b3" aria-label="多态相关">多态相关</a></li>
                        <li>
                            <a href="#%e8%99%9a%e8%a1%a8%e5%92%8c%e8%99%9a%e8%a1%a8%e6%8c%87%e9%92%88%e7%9a%84%e5%88%9b%e5%bb%ba%e6%97%b6%e6%9c%ba" aria-label="虚表和虚表指针的创建时机：">虚表和虚表指针的创建时机：</a>
                        </li>
                    </ul>
                    </li>
                    </ul>
                </div>
            </details>
        </div>
    </aside>
    <script>
        let activeElement;
        let elements;
        window.addEventListener('DOMContentLoaded', function (event) {
            checkTocPosition();

            elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
            
            activeElement = elements[0];
            const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
            document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
        }, false);

        window.addEventListener('resize', function (event) {
            checkTocPosition();
        }, false);

        window.addEventListener('scroll', () => {
            
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight / 2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement) {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }, false);

        const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
        const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
        const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

        function checkTocPosition() {
            const width = document.body.scrollWidth;

            if (width - main - (toc * 2) - (gap * 4) > 0) {
                document.getElementById("toc-container").classList.add("wide");
            } else {
                document.getElementById("toc-container").classList.remove("wide");
            }
        }

        function getOffsetTop(element) {
            if (!element.getClientRects().length) {
                return 0;
            }
            let rect = element.getBoundingClientRect();
            let win = element.ownerDocument.defaultView;
            return rect.top + win.pageYOffset;
        }
    </script>
  <div class="post-content"><h2 id="linux用户空间内存分布">Linux用户空间内存分布<a hidden class="anchor" aria-hidden="true" href="#linux用户空间内存分布">#</a></h2>
<blockquote>
<p>程序内存在地址空间中的分布情况称为内存模型。<br>
对于32位环境，理论上程序可以拥有4GB的虚拟地址空间，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为<strong>内核空间</strong>。<br>
Linux默认将高地址的1GB空间分配给内核。也就是说，应用程序只能使用剩下3GB的地址空间，称为<strong>用户空间</strong>。</p>
</blockquote>
<div style="text-align:center;">
  <img style="display: block; margin: 0 auto;" src="https://s1.ax1x.com/2023/07/02/pCDNi8O.jpg" width="100%" height="100%" >
  <span style="font-size: 14px; color: grey;">Linux用户空间内存分布</span>
</div>
<table>
<thead>
<tr>
<th style="text-align:left">内存分区</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">text段（程序代码  区）</td>
<td style="text-align:left">存放已编译程序的机器代码，只读。</td>
</tr>
<tr>
<td style="text-align:left">rodata段（常量区）</td>
<td style="text-align:left">存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。</td>
</tr>
<tr>
<td style="text-align:left">data段（全局数据区的已初始化部分）</td>
<td style="text-align:left">存放已经初始化的全局变量和静态变量等，这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。</td>
</tr>
<tr>
<td style="text-align:left">bss段（全局数据区的未初始化部分）</td>
<td style="text-align:left">存放未初始化的全局变量和静态变量等。</td>
</tr>
<tr>
<td style="text-align:left">heap（堆区）</td>
<td style="text-align:left">一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。</td>
</tr>
<tr>
<td style="text-align:left">文件/内存映射区（动态链接库）</td>
<td style="text-align:left">用于在程序运行期间加载和卸载动态链接库。例如使用 <em>mmap()</em> 创建内存映射区时，就是在这里申请的内存空间。</td>
</tr>
<tr>
<td style="text-align:left">stack（栈区）</td>
<td style="text-align:left">存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="linux程序内存空间">Linux程序内存空间<a hidden class="anchor" aria-hidden="true" href="#linux程序内存空间">#</a></h2>
<blockquote>
<p>Linux 下内存资源是通过虚拟内存管理的，在分配内存时并不是在物理内存开辟了一段空间，而是在使用时才分配的，并且是通过段页式管理。linux 下内存分配是以页为单位的，而页是通过段管理。各个段之间是独立的，方便管理。</p>
</blockquote>
<p>Linux 程序执行时能够分为下面几个内存段：<strong>text、rodata、data、bss、stack、heap</strong>。</p>
<ol>
<li>text 段（代码段）：text 段存放程序代码，运行前就已经确定（编译时确定），通常为只读；</li>
<li>rodata 段（常量区）：rodata 段存储常量数据，比如程序中定义为 const 的全局变量，“#define”定义的常量，以及诸如“Hello World”的字符串常量。const 修饰的全局变量在常量区，const 修饰的局部变量只是为了防止修改，没有放入常量区（存在栈区）；</li>
<li>data 段：data 存储已经初始化的全局变量（静态变量），属于静态内存分配，需要占用可执行文件空间（注意：初始化为0的全局变量和静态变量还是被保存在 bss 段）；</li>
<li>bss 段：bss 段存储没有初始化或初始化为0的全局变量（静态变量），属于静态内存分配。bss 不占用可执行文件空间，其内容由操作系统初始化（清零），但占据程序运行时的内存空间；</li>
<li>stack 段：stack 段存储参数变量和局部变量，由系统进行申请和释放，属于静态内存分配；</li>
<li>heap 段：heap 段是程序运行过程中动态分配的内存段，由用户申请和释放，程序中不释放，则程序结束时，由 OS 回收。</li>
</ol>
<blockquote>
<p>执行文件中包含了 text、rodata、data 段的内容，不包含 bss 段内容（一堆0放入执行文件没有意义）。
堆和栈的内存增长方向是相反的：栈是从高地址向低地址生长，堆是从低地址向高地址生长。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">NUM</span> <span class="o">=</span> <span class="mi">10086</span><span class="p">;</span> <span class="c1">// 常量区(rodata段)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>    <span class="c1">// 全局初始化区（data）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">char</span> <span class="o">*</span><span class="n">p1</span><span class="p">;</span>      <span class="c1">// 全局未初始化区（bss）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>            <span class="c1">// 栈区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;abc&#34;</span><span class="p">;</span> <span class="c1">// 栈区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> 		  <span class="c1">// 栈区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// 分配得来的10和20字节的区域就在堆区 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>         <span class="c1">// bss段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>         <span class="c1">// stack段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="s">&#34;123456&#34;</span><span class="p">;</span>     <span class="c1">// p3在栈区，&#34;123456\0&#34; 在rodata段    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">strcpy</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="s">&#34;123456&#34;</span><span class="p">);</span>    <span class="c1">// &#34;123456\0&#34; 放在rodata段，编译器可能会将它与p3所指向的&#34;123456&#34;优化成一个地方。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="虚拟内存">虚拟内存<a hidden class="anchor" aria-hidden="true" href="#虚拟内存">#</a></h2>
<p>物理内存是实际的物理空间，即直接映射到硬件 RAM 的物理内存资源。<br>
虚拟内存是逻辑上的地址空间，它通过将物理内存和硬盘空间组合使用，从逻辑上扩展了物理内存的大小，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个页（Linux下页大小为4KB，即4096字节）。而物理内存则被分成相同大小的页面帧，程序的页被映射到物理内存对应的帧（但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中）。当程序访问到不在物理内存中的页时，发生缺页中断，将缺失的页装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生16位地址，那么一个程序的地址空间范围是0~64K。该计算机只有32KB的物理内存，虚拟内存技术允许该计算机运行一个64K大小的程序。</p>
<div style="text-align:center;">
  <img style="display: block; margin: 0 auto;" src="https://s1.ax1x.com/2023/07/02/pCDBssO.jpg" width="50%" height="50%" >
  <span style="font-size: 14px; color: grey;">虚拟内存</span>
</div>
<hr>
<h2 id="newdelete-和-mallocfree">new/delete 和 malloc/free<a hidden class="anchor" aria-hidden="true" href="#newdelete-和-mallocfree">#</a></h2>
<blockquote>
<p>new 和 delete 是用户进行动态内存申请和释放的操作符，<em>operator new</em> 和 <em>operator delete</em> 是系统提供的全局函数，new 在底层调用 <em>operator new</em> 全局函数来申请空间，delete 在底层通过 <em>operator delete</em> 全局函数来释放空间。</p>
</blockquote>
<p><strong>new的过程</strong></p>
<ol>
<li>调用 <em>operator new</em> 函数申请空间；</li>
<li>在申请的空间上执行构造函数，完成对象的构造。</li>
</ol>
<p><strong>delete的过程</strong></p>
<ol>
<li>在申请的空间上执行析构函数，完成对象中资源的清理工作；</li>
<li>调用 <em>operator delete</em> 函数释放对象的空间。</li>
</ol>
<p><strong>new T[N]的过程</strong></p>
<ol>
<li>调用 <em>operator new[]</em> 函数，在 <em>operator new[]</em> 中实际调用 <em>operator new</em> 函数完成N个对象空间的申请；</li>
<li>在申请的空间上执行N次构造函数。</li>
</ol>
<p><strong>delete[]的过程</strong></p>
<ol>
<li>在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理；</li>
<li>调用 <em>operator delete[]</em> 释放空间，实际在 <em>operator delete[]</em> 中调用 <em>operator delete</em> 来释放空间。</li>
</ol>
<h3 id="newdelete-和-mallocfree的异同">new/delete 和 malloc/free的异同<a hidden class="anchor" aria-hidden="true" href="#newdelete-和-mallocfree的异同">#</a></h3>
<p><strong>相同点是:</strong>
都是从堆上申请空间，并且需要用户手动释放。</p>
<p><strong>不同点是:</strong></p>
<ol>
<li><strong>malloc 和 free 是函数，new 和 delete 是操作符</strong>；</li>
<li>malloc 申请的空间不会初始化，new 可以初始化；</li>
<li>malloc 申请空间时，需要手动计算空间大小并传递，new 只需在其后跟上空间的类型即可；</li>
<li>malloc 的返回值为 void*, 在使用时必须强转；new 不需要，因为 new 后跟的是空间的类型；</li>
<li>malloc 申请空间失败时，返回的是 NULL，因此使用时必须判空；new 不需要，但是 new 需要捕获异常；</li>
<li><strong>申请自定义类型对象时，malloc/free 只会开辟与销毁空间，不会调用构造函数与析构函数；而 new 在申请空间后会调用构造函数完成对象的初始化，delete 在释放空间前会调用析构函数完成空间中资源的清理</strong>；</li>
<li>new/delete 比 malloc/free 的效率稍微低点，因为 new/delete 的底层封装了 malloc/free。</li>
</ol>
<h3 id="free-如何知道要-free-多大的空间">free 如何知道要 free 多大的空间<a hidden class="anchor" aria-hidden="true" href="#free-如何知道要-free-多大的空间">#</a></h3>
<p>malloc 函数的实现是以块分配内存，在被分配的块中包括两部分：</p>
<ol>
<li>第一部分中存储含有报头的元数据，它其中包含有分配块的大小信息，是一个常量；</li>
<li>第二部分中存储实际用户数据。而使用 malloc 分配内存返回的是第二部分用户数据的地址。</li>
</ol>
<p>所以内存释放时不再需要再指定释放多大的内存空间，只需要指定该块内存空间的首地址即可。</p>
<h3 id="new-一个对象时加括号和不加括号的区别">new 一个对象时加括号和不加括号的区别<a hidden class="anchor" aria-hidden="true" href="#new-一个对象时加括号和不加括号的区别">#</a></h3>
<ul>
<li>
<p>对于内置类型：<br>
<em>int *a = new int;</em> 不会将申请到的 int 空间初始化，而 <em>int *a = new int();</em> 则会将申请到的 int 空间初始化为0。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>   <span class="c1">// 10个未初始化int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]();</span> <span class="c1">// 10个值初始化为0的int
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>对于自定义类类型：</p>
<ul>
<li>
<p>如果该类显式定义了默认构造函数，那么 <em>class c = new class;</em> 和 <em>class c = new class();</em> 一样，都会调用默认构造函数。</p>
</li>
<li>
<p>如果该类没有显式定义构造函数（由编译器生成默认构造函数）但有虚函数，那么 <em>class c = new class;</em> 和 <em>class c = new class();</em> 一样，都会调用默认构造函数；</p>
<p>如果该类没有显式定义构造函数（由编译器生成默认构造函数）也没有虚函数，那么 <em>class c = new class</em> 将不调用合成的默认构造函数，而 <em>class c = new class()</em> 则会调用默认构造函数。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="mallocfree-实现原理">malloc/free 实现原理<a hidden class="anchor" aria-hidden="true" href="#mallocfree-实现原理">#</a></h2>
<h3 id="brk-和-mmap-函数">brk 和 mmap 函数<a hidden class="anchor" aria-hidden="true" href="#brk-和-mmap-函数">#</a></h3>
<p>brk() 和 sbrk() 函数：作用是扩展 heap 的上界 brk</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// addr为新的brk地址，成功返回0，失败返回-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">brk</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// incr为需要申请的内存大小，返回heap新的上界brk地址。若sbrk的参数为0，则返回原来的brk地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">sbrk</span> <span class="p">(</span><span class="n">intptr_t</span> <span class="n">incr</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>mmap() 和 munmap() 函数：映射磁盘文件到内存中或<strong>匿名映射（向映射区申请一块内存）</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// addr为映射区的开始地址，length为映射区的长度，prot为期望的内存保护标志，
</span></span></span><span class="line"><span class="cl"><span class="c1">// flags指定映射对象的类型，fd为文件描述符，offset为文件映射的偏移量，通常设置为0，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 代表从文件最前方开始对应，offset必须是分页大小的整数倍
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="nf">mmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// munmap执行与mmap相反的操作，删除特定地址区域的对象映射
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">munmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">length</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="实现原理">实现原理<a hidden class="anchor" aria-hidden="true" href="#实现原理">#</a></h3>
<p>malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。<br>
方式一：如果用户分配的内存 $&lt;128 KB$，则通过 brk() 系统调用从堆分配内存；<br>
方式二：如果用户分配的内存 $\geq128 KB$，则通过 mmap() 系统调用在文件/内存映射区域分配内存。</p>
<p>brk 是将 heap 的上界指针 brk 往高地址推，mmap 是在进程的虚拟地址空间中（堆和栈中间，称为内存/文件映射区域的地方）找一块空闲的虚拟内存。
这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p>
<p>brk 分配的内存需要等到高地址内存释放以后才能释放（这就是内存碎片产生的原因），当最高地址空间的空闲内存超过128K（可由 M_TRIM_THRESHOLD 选项调节）时，执行内存紧缩操作（trim）。
mmap 分配的内存可以单独释放。</p>
<div style="text-align:center;">
  <img style="display: block; margin: 0 auto;" src="https://s1.ax1x.com/2023/07/02/pCDB2od.jpg" width="100%" height="100%" >
  <span style="font-size: 14px; color: grey;">brk和mmap</span>
</div><br>
<p>调用 free(A) 后 A 对应的虚拟内存和物理内存都没有释放，因为只有一个 brk 指针，如果往回推，那么 B 这块内存怎么办呢？<br>
当然 A 这块内存是可以重用的，如果这个时候再来一个 40KB 的请求，那么 malloc 很可能就使用 A 这块内存。</p>
<p>进程调用 free(B) 以后，A 和 B 连接起来，变成一块 150KB 的空闲内存，于是内存紧缩。</p>
<p>malloc 采用了<strong>内存池</strong>的实现方式：先申请一大块内存，然后将内存分成不同大小的内存块，用户申请内存时，直接从内存池中选择一块相近的内存块即可。brk 分配内存时优先从内存池获取，失败的话走 brk 系统调用。细节参考：<a href="https://www.jianshu.com/p/2fedeacfa797">简书：glibc内存管理那些事儿</a></p>
<blockquote>
<p><strong>既然堆内内存 brk 和 sbrk 不能直接释放，导致疑似“内存泄露”问题，为什么不全部使用 mmap 来分配，munmap 直接释放，而是仅仅对于大于 128K 的大块内存才使用 mmap？</strong></p>
<p>因为 brk 和 mmap 都是系统调用，频繁调用系统调用都比较消耗系统资源。使用 mmap 申请的空间，直接调用 munmap 是将空间真正释放了，而 brk 释放的空间，并不一定真正释放了，那些没有被真正释放的内存碎片可以被重复利用，再次访问该内存可能不需产生任何系统调用和缺页中断，这将大大降低 CPU 的消耗。</p>
</blockquote>
<hr>
<h2 id="malloc-和-tcmalloc">malloc 和 tcmalloc<a hidden class="anchor" aria-hidden="true" href="#malloc-和-tcmalloc">#</a></h2>
<blockquote>
<p>malloc 和 tcmalloc 都是内存分配库，主要的不同在于实现方式和效率。</p>
<ul>
<li>malloc 是C标准库中的一部分，是系统提供的内存分配器。它的主要作用是管理进程虚拟内存空间，负责分配和释放内存资源。但是，由于多线程并发执行时需要加锁，所以它的性能并不是最优的。</li>
<li>tcmalloc 是 Google 开发的一个高性能、多线程的内存管理库，是 malloc 的替代品之一。tcmalloc 采用线程本地缓存技术（Thread-Caching Malloc，TCMalloc），避免了锁的竞争，从而在多线程环境下具有更好的性能表现。此外，tcmalloc 还会将未使用的页面设置为“dirty”状态，提高缓存命中率，进一步提升了其效率。</li>
</ul>
<p>总的来说，tcmalloc 比 malloc 具有更高的性能和更好的可扩展性，在大型高并发的应用场景中使用更为适合。但是，tcmalloc 也相对较复杂，需要结合实际情况进行使用和优化。</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/497509956">内存优化总结:ptmalloc、tcmalloc和jemalloc</a>、<a href="https://www.cyningsun.com/07-07-2018/memory-allocator-contrasts.html">ptmalloc、tcmalloc与jemalloc对比分析</a></p>
</blockquote>
<p>内存管理可以分为三个层次，自底向上分别是：</p>
<ul>
<li><strong>内核层</strong></li>
<li><strong>C运行时库层</strong>（glibc 层使用系统调用维护的内存管理算法）</li>
<li><strong>应用程序层</strong>（应用程序从 glibc 动态分配内存后，根据应用程序本身的程序特性进行优化，比如使用引用计数 std::shared_ptr，内存池方式等）</li>
</ul>
<h3 id="现状">现状<a hidden class="anchor" aria-hidden="true" href="#现状">#</a></h3>
<p>目前大部分服务端程序使用 glibc 提供的 malloc/free 系列函数，而 glibc 使用的 ptmalloc2 在性能上远远弱后于 google 的 tcmalloc 和 facebook 的 jemalloc。而且后两者只需要使用 LD_PRELOAD 环境变量启动程序即可，甚至并不需要重新编译。</p>
<h3 id="ptmalloc2">ptmalloc2<a hidden class="anchor" aria-hidden="true" href="#ptmalloc2">#</a></h3>
<p>ptmalloc2 即是我们当前使用的 glibc malloc 版本。</p>
<p>ptmalloc2 操作 heap 时，一般大内存采用 mmap，小内存使用 brk。</p>
<p><span style="font-size:18px;"><b>🔰 主分配区和非主分配区</b></span></p>
<p>ptmalloc 的内存分配器中，为了解决多线程锁争夺问题，分为主分配区（main_area）和非主分配区（no_main_area）。</p>
<ul>
<li>每个进程有一个主分配区，也可以允许有多个非主分配区。</li>
<li>主分配区可以使用 brk 和 mmap 来分配内存，而非主分配区只能使用 mmap 来映射内存块（批发申请 <abbr title="32位系统默认1MB，64位系统默认64MB">HEAP_MAX_SIZE</abbr> 大小的虚拟内存）。当用户向非主分配区请求分配内存时再切割成小块“零售” 出去，毕竟系统调用是相对低效的，直接从用户空间分配内存快多了。所以 ptmalloc 在必要的情况下才会调用 mmap 函数向操作系统申请虚拟内存。</li>
<li>非主分配区的数量一旦增加，则不会减少。</li>
<li>主分配区和非主分配区形成一个环形链表进行管理。</li>
</ul>
<blockquote>
<p>当某一线程需要调用 malloc 分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么 malloc 会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。</p>
<p>在释放操作中，线程同样试图获得待释放内存块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行释放操作。</p>
</blockquote>
<p><span style="font-size:18px;"><b>🔰 chunk 内存块的基本组织单元</b></span></p>
<p>ptmalloc 通过 chunk 的数据结构来组织每个内存单元。当我们使用 malloc 分配得到一块内存的时候，这块内存就会通过 chunk 的形式被 glibc 管理起来。你可以把它想象成自己写内存池的时候的一个内存数据结构。chunk 的结构可以分为使用中的 chunk 和空闲的 chunk。</p>
<p>空闲的 chunk 会被放置到空闲的链表 bins 上。当用户 malloc 申请内存的时候，会先去查找空闲链表 bins上是否有合适的内存。</p>
<p><span style="font-size:18px;"><b>🔰 空闲链表 bins</b></span></p>
<p>当用户使用 free 函数释放掉的内存，ptmalloc 并不会马上交还给操作系统，而是被 ptmalloc 本身的空闲链表 bins 管理起来了，这样当下次进程需要 malloc 一块内存的时候，ptmalloc 就会从空闲的 bins 上寻找一块合适大小的内存块分配给用户使用。这样的好处可以避免频繁的系统调用，降低内存分配的开销。</p>
<div style="text-align:center;">
  <img style="display: block; margin: 0 auto;" src="https://s1.ax1x.com/2023/07/02/pCDBgdH.jpg" width="100%" height="100%" >
  <span style="font-size: 14px; color: grey;">ptmalloc</span>
</div><br>
<p>ptmalloc 一共维护了128个 bin。每个 bin 都维护了大小相近的双向链表的 chunk。通过上图这个 bins 的列表就能看出，当用户调用 malloc 的时候，能很快找到用户需要分配的内存大小是否在维护的 bin 上，如果在某一个 bin 上，就可以通过双向链表去查找合适的 chunk 内存块给用户使用。</p>
<ul>
<li><b>fast bins：</b>fast bins 是 bins 的高速缓冲区，大约有10个定长队列。当用户释放一块不大于 max_fast（默认值64B）的 chunk 的时候，会默认会被放到 fast bins 上。当用户下次需要申请内存的时候首先会到 fast bins 上寻找是否有合适的 chunk。ptmalloc 会遍历 fast bin，看是否有合适的 chunk 需要合并到 bins 上。</li>
<li><b>unsorted bin：</b>是 bins 的一个缓冲区。当用户释放的内存大于 max_fast 或者 fast bins 合并后的 chunk 都会进入 unsorted bin 上。当用户 malloc 的时候，先会到 unsorted bin 上查找是否有合适的 bin，如果没有合适的 bin，ptmalloc 会将 unsorted bin 上的 chunk 放入 bins 上，然后到 bins 上查找合适的空闲 chunk。</li>
<li><b>small bins </b>和 <b>large bins：</b>small bins 和 large bins 是真正用来放置 chunk 双向链表的。每个 bin 之间相差8个字节，并且通过上面的这个列表，可以快速定位到合适大小的空闲 chunk。前64个为 small bins 定长；后64个为 large bins，非定长。</li>
<li><b>Top chunk：</b>并不是所有的 chunk 都会被放到 bins 上。top chunk 相当于分配区的顶部空闲内存，当 bins 上都不能满足内存分配要求的时候，就会来 top chunk 上分配。</li>
<li><b>mmaped chunk：</b>当分配的内存非常大（大于分配阀值，默认128K）的时候，需要被 mmap 映射，则会放到 mmaped chunk 上，当释放 mmaped chunk 上的内存的时候会直接交还给操作系统。</li>
</ul>
<p><span style="font-size:18px;"><b>✏️ 内存分配 malloc() 的流程</b></span></p>
<div style="text-align:center;">
  <img style="display: block; margin: 0 auto;" src="https://s1.ax1x.com/2023/07/02/pCDBHeg.jpg" width="50%" height="50%" >
  <span style="font-size: 14px; color: grey;">malloc()的流程</span>
</div>
<ol>
<li>
<p>获取分配区的锁，防止多线程冲突；</p>
</li>
<li>
<p>计算出需要分配的内存的 chunk 实际大小；</p>
</li>
<li>
<p>判断chunk的大小，如果小于 max_fast（64B），则取 fast bins 上去查询是否有适合的 chunk，如果有则分配结束；</p>
</li>
<li>
<p>chunk 大小是否小于512B，如果是，则从 small bins 上去查找 chunk，如果有合适的，则分配结束；</p>
</li>
<li>
<p>继续从 unsorted bins 上查找：</p>
<ul>
<li>
<p>如果 unsorted bins 上只有一个 chunk 并且大于待分配的 chunk，则进行切割，并且剩余的 chunk 继续扔回 unsorted bins；</p>
</li>
<li>
<p>如果 unsorted bins 上有大小和待分配 chunk 相等的，则返回，并从 unsorted bins 删除；</p>
</li>
<li>
<p>如果 unsorted bins 中的某一 chunk 大小属于 small bins 的范围，则放入 small bins 的头部；</p>
</li>
<li>
<p>如果 unsorted bins 中的某一 chunk 大小属于 large bins 的范围，则找到合适的位置放入；</p>
</li>
</ul>
</li>
<li>
<p>从 large bins 中查找，找到链表头后，反向遍历此链表，直到找到第一个大小大于待分配的 chunk，然后进行切割，如果有余下的，则放入 unsorted bin 中去，分配则结束；</p>
</li>
<li>
<p>如果搜索 fast bins 和其他 bins 都没有找到合适的 chunk，那么就需要操作 top chunk 来进行分配了（top chunk 相当于分配区的剩余内存空间）。判断 top chunk 大小是否满足所需 chunk 的大小，如果是，则从 top chunk 中分出一块来；</p>
</li>
<li>
<p>如果 top chunk 也不能满足需求，则需要扩大 top chunk。主分区上，如果分配的内存小于分配阀值（默认128K），则直接使用 brk 分配一块内存；如果分配的内存大于分配阀值，则需要 mmap 来分配。</p>
<p>非主分区上，则直接使用 mmap 来分配一块内存。<strong>通过 mmap 分配的内存，就会放入 mmaped chunk 上，mmaped chunk 上的内存会直接回收给操作系统。</strong></p>
</li>
</ol>
<p><span style="font-size:18px;"><b>✏️ 内存释放 free() 的流程</b></span></p>
<ol>
<li>
<p>获取分配区的锁，保证线程安全；</p>
</li>
<li>
<p>如果 free 的是空指针，则返回，什么都不做；</p>
</li>
<li>
<p>判断当前 chunk 是否是 mmap 映射区域映射的内存，如果是，则直接 munmap 释放这块内存。已使用 chunk 的数据结构中，有对应的标识判断是否是 mmap 映射的内存；</p>
</li>
<li>
<p>判断 chunk 是否与 top chunk 相邻，如果相邻，则直接和 top chunk 合并（和 top chunk 相邻相当于和分配区中的空闲内存块相邻），转到步骤8；</p>
</li>
<li>
<p>如果 chunk 的大小大于 max_fast（64B），则放入 unsorted bin，并且检查是否有合并，有合并情况并且和 top chunk 相邻，则转到步骤8；没有合并情况则 free；</p>
</li>
<li>
<p>如果 chunk 的大小小于 max_fast（64B），则直接放入 fast bin，fast bin 并没有改变 chunk 的状态。没有合并情况，则 free；有合并情况，转到步骤7；</p>
</li>
<li>
<p>在 fast bin，如果当前 chunk 的下一个 chunk 也是空闲的，则将这两个 chunk 合并，放入 unsorted bin 上面。合并后的大小如果大于64KB，会触发进行 fast bins 的合并操作，fast bins 中的 chunk 将被遍历，并与相邻的空闲 chunk 进行合并，合并后的 chunk 会被放到 unsorted bin 中，fast bin 会变为空。合并后的 chunk 和 top chunk 相邻，则会合并到 top chunk 中。转到步骤8；</p>
</li>
<li>
<p>判断 top chunk 的大小是否大于 mmap 收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还 top chunk 中的一部分给操作系统。free 结束。</p>
</li>
</ol>
<p><span style="font-size:18px;"><b>✏️ ptmalloc 的问题</b></span></p>
<p>ptmalloc 的主要问题其实是<strong>内存浪费、内存碎片、以及加锁导致的性能问题</strong>。</p>
<ol>
<li>
<p>内存浪费：</p>
<p>每个 chunk 本身至少8字节的开销很大；</p>
<p>后分配的内存先释放，可能无法及时归还系统。因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放，top chunk 以下的 chunk 都无法释放；</p>
<p>内存不能在线程间移动，多线程使用内存不均衡将导致内存浪费。</p>
</li>
<li>
<p>内存碎片：不定期分配长生命周期的内存容易造成内存碎片，不利于回收。</p>
</li>
<li>
<p>加锁导致的性能问题：加锁耗时，无论当前分区有无耗时，在内存分配和释放时，会首先加锁。</p>
</li>
</ol>
<h3 id="tcmalloc">tcmalloc<a hidden class="anchor" aria-hidden="true" href="#tcmalloc">#</a></h3>
<blockquote>
<p>tcmalloc 是 Google 开源的一个内存管理库， 作为 glibc malloc 的替代品。目前已经在 chrome、safari 等知名软件中运用。</p>
</blockquote>
<p><span style="font-size:18px;"><b>🔰 对象分配</b></span></p>
<ul>
<li>tcmalloc 为每个线程分配了一个线程本地 ThreadCache，小内存从 ThreadCache 分配，此外还有个中央堆（CentralCache），ThreadCache 不够用的时候，会从 CentralCache中 获取空间放到 ThreadCache 中。</li>
<li>小对象（$\leq32KB$）从 ThreadCache 分配，大对象从 CentralCache 分配。大对象分配的空间都是4K页面对齐的，多个 pages 也能切割成多个小对象划分到 ThreadCache 中。</li>
</ul>
<p><span style="font-size:18px;"><b>✏️ tcmalloc的优势</b></span></p>
<ul>
<li>小内存可以在 ThreadCache 中不加锁分配（加锁的代价大约100ns）</li>
<li>大内存可以直接按照大小分配不需要再像 ptmalloc 一样进行查找</li>
<li>大内存加锁使用更高效的自旋锁</li>
<li>减少了内存碎片</li>
</ul>
<hr>
<h2 id="内存对齐">内存对齐<a hidden class="anchor" aria-hidden="true" href="#内存对齐">#</a></h2>
<h3 id="什么是内存对齐">什么是内存对齐<a hidden class="anchor" aria-hidden="true" href="#什么是内存对齐">#</a></h3>
<p>现代计算机中内存空间都是按照字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。</p>
<h3 id="为什么要内存对齐">为什么要内存对齐<a hidden class="anchor" aria-hidden="true" href="#为什么要内存对齐">#</a></h3>
<p>主要是由于 CPU 的访问内存的特性决定，<b>CPU 访问内存时并不是以字节为单位来读取内存，而是以机器字长为单位，实际机器字长由 CPU 数据总线宽度决定的。</b>实际 CPU 运行时，每一次控制内存读写信号发生时，CPU 可以从内存中读取数据总线宽度的数据，并将其写入到 CPU 的通用寄存器中。内存对齐的主要目的是为了减少 CPU 访问内存的次数。假设读取8个字节的数据，按照每次读取4个字节的速度，则8个字节需要 CPU 耗费2次读取操作。CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数。</p>
<h3 id="怎么使用内存对齐">怎么使用内存对齐<a hidden class="anchor" aria-hidden="true" href="#怎么使用内存对齐">#</a></h3>
<p>我们可以用<code>#progma pack(x)</code>指定结构体以<code>x</code>为单位进行对齐。一般情况下使用方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#pragma pack(push)  </span><span class="cm">/* push current alignment to stack */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#pragma pack(1)     </span><span class="cm">/* set alignment to 1 byte boundary */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">MyPackedData</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">Data1</span><span class="p">;</span>  <span class="c1">// 1 byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="n">Data2</span><span class="p">;</span>  <span class="c1">// 8 byte(64位环境)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">Data3</span><span class="p">;</span>  <span class="c1">// 1 byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#pragma pack(pop)   </span><span class="cm">/* restore original alignment from stack */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">alignof</span><span class="p">(</span><span class="n">MyPackedData</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MyPackedData</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>   <span class="c1">// 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>C++11之后提供了<code>alignas</code>关键字，允许往更大的字节数去对齐（有的平台不支持未对齐内存访问，alignas 的目的是允许你往更大的字节数去对齐，比如 char 对齐到32位供 SIMD load）。</p>
<p>即 pack 是变小，alignas 是变大，用法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nf">alignas</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">Point</span> <span class="c1">// 使用g++能正常运行，但是在CLion中会报错，因为这样做是不合规范（ill-formed）的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">alignof</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>  <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#pragma pack(push)
</span></span></span><span class="line"><span class="cl"><span class="cp">#pragma pack(1)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">struct</span> <span class="nc">Point2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">p2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#pragma pop(pop)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">alignof</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;&lt;</span>  <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 4
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="用户态与内核态">用户态与内核态<a hidden class="anchor" aria-hidden="true" href="#用户态与内核态">#</a></h2>
<h3 id="用户态内核态的概念">用户态/内核态的概念<a hidden class="anchor" aria-hidden="true" href="#用户态内核态的概念">#</a></h3>
<p>CPU 指令可以直接操作硬件，而对于硬件的操作是非常复杂的，出问题的几率相当大，所以操作系统内核直接屏蔽了个人开发者对于硬件操作的可能。因为这个需求，硬件设备商直接提供了硬件级别的支持，做法就是对 CPU 指令设置了权限，不同级别的权限可以使用的 CPU 指令是有限制的。</p>
<p>以 Intel CPU 为例，CPU 指令操作的权限划为4级：<code>ring 0</code>、<code>ring 1</code>、<code>ring 2</code>、<code>ring 3</code>。其中<code>ring 0</code>权限最高，可以使用所有 CPU 指令，<code>ring 3</code> 权限最低，仅能使用常规 CPU 指令，不能使用访问硬件资源的指令，比如 I/O读写、网卡访问、申请内存等。</p>
<p>Linux 系统内核采用了：<code>ring 0</code> 和 <code>ring 3</code> 这2个权限</p>
<ul>
<li><code>ring 0</code> 被叫做 <code>内核态</code>，完全在<strong>操作系统内核</strong>中运行，由专门的<strong>内核线程</strong>执行其任务；</li>
<li><code>ring 3</code> 被叫做 <code>用户态</code>，在<strong>应用程序</strong>中运行，由<strong>用户线程</strong>执行其任务。</li>
</ul>
<h3 id="切换方式">切换方式<a hidden class="anchor" aria-hidden="true" href="#切换方式">#</a></h3>
<p>从用户态到内核态切换可以通过三种方式，或者说会导致从用户态切换到内核态的操作：</p>
<ol>
<li><strong>系统调用</strong>：系统调用本身就是中断，属于软件中断，跟硬件中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。比如我们使用库函数 fopen 打开文件，就会触发 open 系统调用。</li>
<li><strong>异常</strong>：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中。</li>
<li><strong>外围设备中断</strong>：硬件中断，外围设备完成用户请求的操作之后，会向 CPU 发出中断信号，这时 CPU 会转去处理对应的中断处理程序。</li>
</ol>
<h3 id="切换过程">切换过程<a hidden class="anchor" aria-hidden="true" href="#切换过程">#</a></h3>
<p>当发生用户态到内核态的切换时，会发生如下过程（本质上是从“用户程序”切换到“内核程序”）</p>
<ol>
<li>
<p>设置处理器至内核态；</p>
</li>
<li>
<p>保存当前程序的寄存器（栈指针、程序计数器、通用寄存器）；</p>
</li>
<li>
<p>将栈指针设置指向内核栈地址；</p>
</li>
<li>
<p>执行中断处理程序；</p>
</li>
<li>
<p>恢复之前保存的寄存器，从中断处理程序返回。</p>
</li>
</ol>
<p>具体流程参考：<a href="#system_call">中断（系统调用）的具体过程</a></p>
<hr>
<h2 id="span-idsystem_call中断系统调用的具体过程span"><span id="system_call">中断（系统调用）的具体过程</span><a hidden class="anchor" aria-hidden="true" href="#span-idsystem_call中断系统调用的具体过程span">#</a></h2>
<blockquote>
<p><strong>总结：</strong> 用户运行库函数（系统调用的封装），函数里面其实是执行的 int 0x80 指令。系统调用先把系统调用号保存在 eax 寄存器中，然后执行 int 0x80 指令。int 0x80 指令先进行切换堆栈（找到进程的堆栈，将寄存器值压入到内核栈中，将 esp，ss 设置成对应内核栈的值），查找相应中断向量的中断处理程序(system_call)并调用，随后 system_call 从系统调用表中找到相应的系统调用进行调用，调用结束后从 system_call 中返回。</p>
</blockquote>
<p>中断一般有两个属性，<strong>中断号</strong>和<strong>中断处理程序</strong>（ISR，Interrupt Service Routine）。在内核中，有一个数组称为<strong>中断向量表</strong>，包含了中断号及其对应中断处理程序的指针。中断到来时，CPU 暂停当前执行的代码，根据中断的中断号，在中断向量表中找到对应的中断处理程序，并调用它。中断处理程序执行完成之后，CPU 会继续执行之前的代码。</p>
<p>由于中断号是有限的，操作系统不舍得每一个系统调用对应一个中断号，而更倾向于用一个或少数几个中断号来对应所有的系统调用。Linux 则使用 int 0x80 来触发所有系统调用。<strong>每个系统调用对应一份系统调用号</strong>，这个系统调用号在执行 int 0x80 指令前会放置在某个固定的寄存器里（eax)，对应的中断代码会取得这个系统调用号，并且调用正确的函数。</p>
<div style="text-align:center;">
  <img style="display: block; margin: 0 auto;" src="https://s1.ax1x.com/2023/07/02/pCDBXYn.jpg" width="100%" height="100%" >
  <span style="font-size: 14px; color: grey;">系统调用的详细过程</span>
</div>
<ol>
<li><strong>触发中断</strong></li>
</ol>
<p>用户程序在代码中调用系统调用，执行 int 指令前将系统调用号放入 eax 寄存器中，执行 int 0x80 指令（int 指令最终执行的函数是 <em>system_call</em>，该函数验证系统调用号的有效性，查找系统调用函数并执行，最后通过 <em>itret</em> 指令从中断处理程序返回）。</p>
<ol start="2">
<li><strong>切换堆栈</strong>（此步在 int 指令中完成）</li>
</ol>
<p>在实际执行 0x80 号中断向量所对应的中断处理程序（<em>system_call</em>）之前，CPU 首先要进行堆栈切换，即从用户态切换到内核态。所谓的当前栈，指得是 esp（栈指针）的值所在的栈空间。如果 esp 的值位于用户栈的范围内，那么程序的当前栈就是用户栈，反之亦然。此外，寄存器 ss 的值还应该指向当前栈所在的页。</p>
<p>所以，将当前栈由用户栈切换为内核栈（用户态切换到内核态）的实际行为就是：保存当前的 esp，ss 的值（保证存在内核栈上，int 指令发送后自动地由硬件完成），并将 esp，ss 的值设置为内核栈的相应值</p>
<p>当 0x80 号中断发生的时候，cpu 除了切入内核态之外，还会自动完成下列几件事：</p>
<p>（1）找到当前进程的内核栈（每一个进程都有自己的内核栈）</p>
<p>（2）在内核栈中一次压入用户态的寄存器 ss、esp、eflags、cs、eip</p>
<p>而当内核从系统调用返回的时候，须要调用 iret 指令来回到用户态，iret 指令则会从内核栈里弹出寄存器 ss、esp、eflags、cs、eip 的值，使得栈恢复到用户态的状态。</p>
<div style="text-align:center;">
  <img style="display: block; margin: 0 auto;" src="https://s1.ax1x.com/2023/07/02/pCDBxS0.jpg" width="80%" height="80%" >
  <span style="font-size: 14px; color: grey;">中断时内核栈和用户栈的切换</span>
</div>
<ol start="3">
<li><strong>中断处理程序</strong></li>
</ol>
<p>在 int 指令切换内核栈之后，程序就切换到了中断向量表中的 0x80 号中断处理程序。Linux 中 0x80 向量对应的中断处理程序是 system_call。</p>
<p>system_call 中断服务程序首先检查系统调用号的有效性，再根据 eax 寄存器存储的系统调用号从系统调用表上找到相应的系统调用并调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// system_call的开头部分
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">SAVE_ALL // 保存寄存器的值到栈中，以免被覆盖
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">cmpl $(nr_syscalls), %eax // 比较eax寄存器中的值和系统调用号大1的值（验证系统调用号的有效性）
</span></span><span class="line"><span class="cl">jae syscall_badsys	      // 如果系统调用无效，指向syscall_badsys
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 如果系统调用号有效，则会执行以下代码
</span></span><span class="line"><span class="cl">syscall_call:
</span></span><span class="line"><span class="cl">	call *sys_call_table(0, %eax, 4) // 查找中断服务程序并执行， sys_call_table其实就是系统调用表
</span></span><span class="line"><span class="cl">	.....
</span></span><span class="line"><span class="cl">	RESTORE_REGS // 恢复之前保存的寄存器
</span></span><span class="line"><span class="cl">	......
</span></span><span class="line"><span class="cl">	iret 		 // 从中断程序返回
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li><strong>恢复之前保存的寄存器，从中断处理程序返回，从内核态切换回用户态</strong></li>
</ol>
<hr>
<h2 id="缺页中断">缺页中断<a hidden class="anchor" aria-hidden="true" href="#缺页中断">#</a></h2>
<blockquote>
<p>在操作系统中，程序执行时需要访问的内存在虚拟内存中，不在物理内存中，此时就会发生缺页中断（该情况为硬件页缺失）。</p>
</blockquote>
<h3 id="缺页中断的分类">缺页中断的分类<a hidden class="anchor" aria-hidden="true" href="#缺页中断的分类">#</a></h3>
<p><strong>软性页缺失</strong>：指页缺失发生时，相关的页已经被加载进内存，但是没有向 MMU（内存管理单元）注册的情况。操作系统只需要在 MMU 中注册相关页对应的物理地址即可。
<strong>硬性页缺失</strong>：硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。
<strong>无效页缺失</strong>：当程序访问的虚拟地址是不存在于虚拟地址空间内的时候，则发生无效页缺失。</p>
<h3 id="查看进程发生缺页中断的次数">查看进程发生缺页中断的次数<a hidden class="anchor" aria-hidden="true" href="#查看进程发生缺页中断的次数">#</a></h3>
<p><code>ps -o majflt,minflt -C &lt;program_name&gt;</code><br>
<code>ps -o majflt,minflt -p &lt;pid&gt; </code></p>
<p>majflt 代表 major fault，中文名叫大错误，minflt 代表 minor fault，中文名叫小错误。
majflt 表示需要读写磁盘，可能是内存对应页面在磁盘中需要load到物理内存中，也可能是此时物理内存不足，需要淘汰部分物理页面至磁盘中。
这两个数值表示一个进程自启动以来所发生的缺页中断的次数。</p>
<h3 id="缺页中断过程">缺页中断过程<a hidden class="anchor" aria-hidden="true" href="#缺页中断过程">#</a></h3>
<p>当程序访问一个虚拟地址时，操作系统会检查该地址是否被映射到物理内存中，如果没有，则触发缺页中断：</p>
<ol>
<li>
<p><strong>缺页中断会暂停程序执行，将控制权交给操作系统内核（进程会陷入内核态），保护程序现场，以免被操作系统破坏</strong>。</p>
</li>
<li>
<p>内核会检查发生缺页中断的虚拟地址是否有效：</p>
</li>
</ol>
<ul>
<li>如果虚拟地址有效，操作系统将会分配一个空闲物理页面，并把未被读取的数据从磁盘拷贝到物理内存所分配的页面中（没有空闲物理页面会触发页面置换算法），并更新页表信息。</li>
<li>如果虚拟地址无效，则操作系统会向进程发出一个信号或杀掉该进程。</li>
</ul>
<ol start="3">
<li>当操作系统处理完缺页中断后，<strong>程序会恢复至发生缺页中断指令以前的状态，程序计数器重新指向这条指令</strong>。</li>
</ol>
<h3 id="缺页中断和缺页异常">缺页中断和缺页异常<a hidden class="anchor" aria-hidden="true" href="#缺页中断和缺页异常">#</a></h3>
<ul>
<li>
<p>缺页中断是指当程序访问一个虚拟内存地址时，对应的物理内存页不在主存中，需要从磁盘中加载到主存中，此时 CPU 就会发出一个中断请求，操作系统会响应中断请求，将对应的物理页加载到主存中，并重新执行产生缺页中断的指令。缺页中断是一种同步事件，也就是说，程序需要等待操作系统完成页的加载操作后才能继续执行。</p>
</li>
<li>
<p>缺页异常是指当程序访问一个虚拟内存地址时，对应的物理内存页不在主存中，需要从磁盘中加载到主存中，但是此时 CPU <strong>不会发出中断请求</strong>，而是将控制权交给操作系统，让操作系统处理缺页异常。缺页异常是一种异步事件，也就是说，程序不需要等待操作系统完成页的加载操作就可以继续执行。</p>
</li>
</ul>
<p>因此，缺页中断和缺页异常的主要区别在于它们是同步事件还是异步事件。缺页中断是同步事件，程序需要等待操作系统完成页的加载操作后才能继续执行；而缺页异常是异步事件，程序不需要等待操作系统完成页的加载操作就可以继续执行。</p>
<hr>
<h2 id="虚表虚表指针">虚表/虚表指针<a hidden class="anchor" aria-hidden="true" href="#虚表虚表指针">#</a></h2>
<p>为了实现 C++ 的多态，C++ 使用了一种动态绑定的技术，这个技术的核心是虚函数表。</p>
<h3 id="虚表">虚表<a hidden class="anchor" aria-hidden="true" href="#虚表">#</a></h3>
<blockquote>
<ol>
<li>每个包含了虚函数的类都包含一个虚表；</li>
<li>一个类继承了包含虚函数的基类，那么这个类也会拥有自己的虚表；</li>
<li>虚表是一个指针数组，其元素是虚函数的指针，即虚表中每个元素对应一个虚函数的函数指针；</li>
<li>虚函数的的调用都需要经过虚表，普通函数即非虚函数，其调用并不需要经过虚表；</li>
<li>虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段；</li>
<li>虚表是属于类的，而不属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。</li>
</ol>
</blockquote>
<h3 id="虚表指针">虚表指针<a hidden class="anchor" aria-hidden="true" href="#虚表指针">#</a></h3>
<blockquote>
<ol>
<li>如有类中包含虚函数，编译器会自动在类中添加一个指针：*__vptr，用来指向该类的虚表；</li>
<li>类的对象在创建时便拥有虚表指针，且这个指针的值会自动被设置为指向类的唯一虚表。</li>
</ol>
</blockquote>
<p>类A的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">vfunc1</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">vfunc2</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">func1</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">func2</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">m_data1</span><span class="p">,</span> <span class="n">m_data2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为类A中存在（一个或多个）虚函数，编译器会自动给类A加上一个虚表指针（占8字节空间），所以<code>sizeof(A)=16</code>。
类A的虚表和虚表指针（__vptr）关系如下：</p>
<div style="text-align:center;">
  <img style="display: block; margin: 0 auto;" src="https://s1.ax1x.com/2023/07/02/pCDDpOU.jpg" width="80%" height="80%" >
  <span style="font-size: 14px; color: grey;">虚表和虚表指针</span>
</div>
<h3 id="多态相关">多态相关<a hidden class="anchor" aria-hidden="true" href="#多态相关">#</a></h3>
<blockquote>
<ol>
<li>一个类的基类如果包含虚函数，那个这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表；</li>
<li>一旦继承类重写了基类的某个虚函数，那么它的虚表项也会同步更新，指向继承类重写的函数，否则指向它基类的同名函数。</li>
<li>通过基类的指针调用派生类中的函数称为<b>（运行时）多态</b>，经过虚表调用虚函数的过程称为<strong>动态绑定</strong>；</li>
</ol>
</blockquote>
<h3 id="虚表和虚表指针的创建时机">虚表和虚表指针的创建时机：<a hidden class="anchor" aria-hidden="true" href="#虚表和虚表指针的创建时机">#</a></h3>
<ul>
<li>在编译的过程中编译器就为含有虚函数的类创建了虚表，并且编译器会在构造函数中插入一段代码，这段代码用来给虚指针赋值。因此<strong>虚表是在编译的过程中创建</strong>。</li>
<li>由于虚指针是基于对象的，所以对象在实例化的时候，虚指针就会创建，所以<strong>虚指针是在运行时创建</strong>。</li>
</ul>
<p>此外，编译器规定一个模版函数不能为虚函数。因为模版机制需要在编译期间识别模版支持类型，对于每一种类型我们都要生成对应类型的函数体。如果这个模版函数为虚函数，我们不知道这个模版函数被生成了多少份对应类型的虚函数，也就不好确定虚表的大小，所以编译器禁止这一行为。</p>
<p>更详细的内容参考：<a href="https://zhuanlan.zhihu.com/p/41309205">知乎：C++中虚函数、虚继承内存模型</a></p>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://kdjlyy.github.io/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
      <li><a href="https://kdjlyy.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></li>
      <li><a href="https://kdjlyy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://kdjlyy.github.io/posts/site/site-init/">
    <span class="title">« 上一页</span>
    <br>
    <span>基于Hugo搭建静态博客</span>
  </a>
  <a class="next" href="https://kdjlyy.github.io/posts/tech/cs-basic-grammar/">
    <span class="title">下一页 »</span>
    <br>
    <span>计算机基础知识总结（语法篇）</span>
  </a>
</nav>

  </footer>
<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">评论</span>
        <br />
    </div>
    <div id="tcomment"></div>
    <script src="https://utteranc.es/client.js" repo="kdjlyy/blog_comments" issue-term="title" theme="github-light"
        crossorigin="anonymous" async>
        </script>
</div>
</article>
    </main>
    
<footer class="footer">
    <div class="busuanzi-footer">
        <span>&copy; 2025 <a href="https://kdjlyy.github.io">向着悠远的苍穹</a></span>
        <span>
            
            | <a href="https://beian.miit.gov.cn/" rel="noopener noreferrer" target="_blank">皖ICP备2023007581号</a>
            
            </span>
    </div>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Done';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script></body>

</html>
