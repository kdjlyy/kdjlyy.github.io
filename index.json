[{"content":" 常见的Markdown语法，例如引用、标题、段落、无序列表、有序列表等不做讨论。\n参考：Sulv’s Blog、荷戟独彷徨、Memory、3rd\u0026rsquo;s Blog、Doit。\n字体种类 在Markdown中，使用\u0026lt;font\u0026gt;标签的face属性修改文字字体：\n1 2 3 \u0026lt;font face=\u0026#39;SimHei\u0026#39;\u0026gt;这是黑体\u0026lt;/font\u0026gt; \u0026lt;font face=\u0026#39;KaiTi\u0026#39;\u0026gt;这是楷体\u0026lt;/font\u0026gt; \u0026lt;font face=\u0026#39;Fangsong_GB2312\u0026#39;\u0026gt;这是仿宋_GB2312字体\u0026lt;/font\u0026gt; 字体名称 字体写法 黑体 SimHei 宋体 SimSun 新宋体 NSimSun 仿宋 FangSong 楷体 KaiTi 仿宋_GB2312 FangSong_GB2312 楷体_GB2312 KaiTi_GB2312 微软雅黑 Microsoft YaHei 落霞文楷 LXGW WenKai 落霞文楷 Lite LXGW WenKai Lite 落霞文楷 Screen LXGW WenKai Screen 落霞文楷 TC LXGW WenKai TC 字号 1 2 3 4 5 6 7 \u0026lt;font size=\u0026#34;1\u0026#34;\u0026gt;这是1号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;2\u0026#34;\u0026gt;这是2号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;3\u0026#34;\u0026gt;这是3号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;4\u0026#34;\u0026gt;这是4号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;5\u0026#34;\u0026gt;这是5号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;6\u0026#34;\u0026gt;这是6号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;7\u0026#34;\u0026gt;这是7号字体\u0026lt;/font\u0026gt; 这是1号字体\n这是2号字体 这是3号字体 这是4号字体 这是5号字体 这是6号字体 这是7号字体 字体颜色 1 2 3 4 \u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;这是红色字体\u0026lt;/font\u0026gt; \u0026lt;font color=\u0026#39;rgb(200, 100, 100)\u0026#39;\u0026gt;这是rgb(200, 100, 100)颜色字体\u0026lt;/font\u0026gt; \u0026lt;font color=\u0026#39;#FF00BB\u0026#39;\u0026gt;这是#FF00BB颜色字体\u0026lt;/font\u0026gt; \u0026lt;font style=\u0026#34;background: linear-gradient(to right, #ff1616, #36c945, #10a5ce, #0f0096, #a51eff, #ff1616);\u0026#34;\u0026gt;这是7色渐变颜色\u0026lt;/font\u0026gt; 这是红色字体 这是rgb(200, 100, 100)颜色字体 这是#FF00BB颜色字体\n这是7色渐变颜色\n待办列表 使用-[]表示一项待办，当完成待办后给中括号中添加x（不区分大小写，注意空格不可省略）即可，例如：\n1 2 3 - [x] 吃饭 - [x] 睡觉 - [ ] 写作业 吃饭 睡觉 写作业 脚注 1 2 3 这是一个简单的脚注[^1]，这是另一个脚注[^bignote]。 [^1]:这是第一个脚注 [^bignote]:这是第二脚注 这是一个简单的脚注1，这是另一个脚注2。\n鼠标悬浮效果 1 \u0026lt;abbr title=\u0026#34;🙃🙃🙃\u0026#34;\u0026gt;鼠标悬浮这里\u0026lt;/abbr\u0026gt;可以看到详细的解释。 鼠标悬浮这里 可以看到详细的解释。\n自定义shortcodes Hugo博客通过简码方式插入pdf、bilibili以及博客文章内链等功能。\n为了防止被识别生效，调用样式均表示为{.{\u0026lt; xxx \u0026gt;}}，实际使用时去掉大括号中间的.即可。\n插入pdf 1 {.{\u0026lt; ppt src=\u0026#34;https://www.africau.edu/images/default/sample.pdf\u0026#34; \u0026gt;}} 插入bilibili视频 1 2 {.{\u0026lt; bilibili BV1WZ4y1a7MF \u0026gt;}} # 如果有集数（默认第一集），例如要播放第5集，则这样使用：{.{\u0026lt; bilibili BV1WZ4y1a7MF 5 \u0026gt;}} \u003c!DOCTYPE HTML\u003e 插入博客文章内链 1 2 {.{\u0026lt; innerlink src=\u0026#34;posts/tech/cs_basic_grammar.md\u0026#34; \u0026gt;}} # 卡片获取的文章长度默认是70，需要在config.yaml配置文件添加 summaryLength: 140，即设置为140 计算机基础知识总结（语法篇） 日期: 2023-05-09 \u0026nbsp; 标签: #C\u0026#43;\u0026#43;\u0026nbsp; #基础知识\u0026nbsp; 成员变量初始化 构造函数内部初始化和初始化列表 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。 对于内置类型，如int, float等，使用初始化列表和在构造函数体内初始化差别不大； 对于类类型来说，使用初始化列表会减少调用默认构造函数的次数，更加高效。 1 2 ...... 代码折叠 1 2 3 4 5 6 7 8 9 {.{% code %}} ```cpp #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } ``` {.{% /code %}} Codes 1 2 3 4 5 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 文字位置 1 2 3 {.{\u0026lt; align left \u0026#34;文字居左\u0026#34; \u0026gt;}} {.{\u0026lt; align center \u0026#34;文字居中\u0026#34; \u0026gt;}} {.{\u0026lt; align right \u0026#34;文字居中\u0026#34; \u0026gt;}} 文字居左\n文字居中\n文字居中\n图片 figure标签是PaperMod主题自带的\n1 2 {.{\u0026lt; figure src=\u0026#34;https://kdjlyy.github.io/img/logo.ico\u0026#34; caption=\u0026#34;图片描述\u0026#34; width=\u0026#34;50%\u0026#34; height=\u0026#34;50%\u0026#34; align=\u0026#34;center\u0026#34; \u0026gt;}} {.{\u0026lt; figure src=\u0026#34;https://kdjlyy.github.io/img/logo.ico\u0026#34; title=\u0026#34;xxx\u0026#34; caption=\u0026#34;图片描述\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34; \u0026gt;}} 图片描述\nGithub卡片 1 {.{\u0026lt; github title=\u0026#34;kdjlyy/fastRPC\u0026#34; \u0026gt;}} Mermaid作图 1 2 3 4 5 6 7 8 \u0026lt;div align=center\u0026gt; \u0026lt;!-- 可以用html代码包裹该代码实现居中或其他排版 --\u0026gt; {.{\u0026lt;mermaid\u0026gt;}} flowchart LR a --\u0026gt; b \u0026amp; c --\u0026gt; d {.{\u0026lt;/mermaid\u0026gt;}} \u0026lt;/div\u0026gt; flowchart LR a --\u003e b \u0026 c --\u003e d 流程图 Codes 1 2 3 4 5 6 {.{\u0026lt; mermaid \u0026gt;}}graph LR; A[Hard edge] --\u0026gt;|Link text| B(Round edge) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result one] C --\u0026gt;|Two| E[Result two] {.{\u0026lt; /mermaid \u0026gt;}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] 时序图 Codes 1 2 3 4 5 6 7 8 9 10 11 12 {.{\u0026lt; mermaid \u0026gt;}}sequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! {.{\u0026lt; /mermaid \u0026gt;}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! 甘特图 Codes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { {\u0026lt; mermaid \u0026gt;}}gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d { {\u0026lt; /mermaid \u0026gt;}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d 类图 Codes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { {\u0026lt; mermaid \u0026gt;}}classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u0026lt;--\u0026gt; C2: Cool label { {\u0026lt; /mermaid \u0026gt;}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label 状态图 Codes 1 2 3 4 5 6 7 8 {.{\u0026lt; mermaid \u0026gt;}}stateDiagram [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] {.{\u0026lt; /mermaid \u0026gt;}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] Git图 Codes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 { {\u0026lt; mermaid \u0026gt;}} gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\u0026#34;ash\u0026#34; tag:\u0026#34;abc\u0026#34; branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release { {\u0026lt; /mermaid \u0026gt;}} gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\"ash\" tag:\"abc\" branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release 饼图 Codes 1 2 3 4 5 6 7 \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; pie \u0026#34;Dogs\u0026#34; : 386 \u0026#34;Cats\u0026#34; : 85 \u0026#34;Rats\u0026#34; : 15 \u0026lt;/div\u0026gt; pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 Echarts作图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;echarts\u0026#34; style=\u0026#34;width: 600px;height:400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/echarts/5.1.1/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var myChart = echarts.init(document.getElementById(\u0026#39;echarts\u0026#39;)); myChart.setOption({ title: { text: \u0026#39;ECharts 示例\u0026#39; }, tooltip: {}, xAxis: { data: [\u0026#39;周一\u0026#39;, \u0026#39;周二\u0026#39;, \u0026#39;周三\u0026#39;, \u0026#39;周四\u0026#39;, \u0026#39;周五\u0026#39;, \u0026#39;周六\u0026#39;, \u0026#39;周日\u0026#39;] }, yAxis: {}, series: [{ name: \u0026#39;销量\u0026#39;, type: \u0026#39;bar\u0026#39;, data: [5, 20, 36, 10, 10, 20, 5] }] }); \u0026lt;/script\u0026gt; 其他 上标和下标 1 2 3 H\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;O C\u0026lt;sub\u0026gt;6\u0026lt;/sub\u0026gt;H\u0026lt;sub\u0026gt;12\u0026lt;/sub\u0026gt;O\u0026lt;sub\u0026gt;6\u0026lt;/sub\u0026gt; X\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; + Y\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; = Z\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; H2O\nC6H12O6 Xn + Yn = Zn 公式 1 $$0.414213562373095048\\approx6\\*16^{-1}+a\\*16^{-2}+0\\*16^{-3}+\\cdots$$ $$0.414213562373095048\\approx6*16^{-1}+a*16^{-2}+0*16^{-3}+\\cdots$$\n高亮 1 \u0026lt;mark\u0026gt;高亮标记语言\u0026lt;/mark\u0026gt;显示段落中的重要文字部分。 高亮标记语言显示段落中的重要文字部分。\n这是第一个脚注\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n这是第二脚注\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://kdjlyy.github.io/posts/tech/markdown_note/","summary":"主要展示 PaperMod 主题中 Markdown 语法的页面效果","title":"PaperMod主题Markdown示例"},{"content":"成员变量初始化 构造函数内部初始化和初始化列表 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。\n对于内置类型，如int, float等，使用初始化列表和在构造函数体内初始化差别不大； 对于类类型来说，使用初始化列表会减少调用默认构造函数的次数，更加高效。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;A()\u0026#34; \u0026lt;\u0026lt; endl; } A(int _a) { a = _a; cout \u0026lt;\u0026lt; \u0026#34;A(_a)\u0026#34; \u0026lt;\u0026lt; endl; } private: int a; }; class B { public: B() { cout \u0026lt;\u0026lt; \u0026#34;B()\u0026#34; \u0026lt;\u0026lt; endl; } B(int _b) : b(_b), m_a(_b) { // 初始化列表初始化 // b = _b, m_a = A(_b); // 构造函数内部赋值操作 cout \u0026lt;\u0026lt; \u0026#34;B(_b)\u0026#34; \u0026lt;\u0026lt; endl; } private: int b; A m_a; }; int main(int argc, char** argv) { B b(100); } 这段代码输出：\n1 2 A(_a) B(_b) 如果不使用初始化列表，使用17行构造函数内部赋值的方式，会输出：\n1 2 3 A() A(_a) B(_b) 除了性能问题之外，有时候初始化列表是不可或缺的，以下几种情况必须使用初始化列表：\n类的const成员\n引用类型\nconst对象或引用只能初始化但是不能赋值，构造函数的函数体内只能做赋值而不是初始化。因此初始化const对象或引用的唯一机会是构造函数函数体之前的初始化列表中。\n没有默认构造函数的类类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class A { public: A(int a): i(a) {} int i; }; class B { public: A a ; B(const A\u0026amp; a1) { a = a1; // error: 类A不存在默认构造函数 } }; class C: public A { public: C(int _x): x(_x) {} // error: 类A不存在默认构造函数 private: int x; } 以上代码无法通过编译，因为B的构造函数中a=a1这一行会先调用A的默认构造函数来初始化a1，由于A没有默认的构造函数，所以无法执行，故而编译错误。\n如果基类没有默认构造函数，派生类必须在其初始化列表中显示调用基类的构造函数。\n构造函数调用顺序 调用基类构造函数，调用顺序按照他们的继承时声明的顺序。 调用内嵌成员对象的构造函数，调用顺序按照他们在类中声明的顺序。 调用派生类自己的构造函数体中的内容。 析构函数的调用顺序相反。\n更详细的：构造函数的执行可以分成两个阶段，初始化阶段和计算阶段，初始化阶段先于计算阶段。\n初始化阶段：所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。 计算阶段：一般用于执行构造函数体内的赋值操作。 所以，初始化列表总是先于构造函数体执行：基类初始化列表 → 基类的构造函数 → 派生类初始化列表 → 派生类的构造函数。\n成员变量初始化顺序 成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class A { private: int n1; int n2; public: A(): n2(0), n1(n2+1) {} void Print(){ cout \u0026lt;\u0026lt; \u0026#34;n1: \u0026#34; \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#34;, n2: \u0026#34; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt;endl; } }; int main() { A a; a.Print(); // 输出是：`n1: 18749281, n2: 0`，而不是`n1: 1, n2 0` return 0; } const和constexpr constexpr关键字是C++11新增的，其作用包括：\n定义编译期常量[1]； 定义常量表达式函数[2]； 定义编译期常量对象[3]。 [1]常量分为编译期常量、运行期常量。 编译期常量在编译阶段就可以确定其值，并将其结果展开到使用的地方，一般存放在rodata段。 运行期常量本质上是只读的变量（存放在栈区），编译时无法确定其值；运行时，无法修改其值。\nconst 可以定义编译期常量，也可以定义运行期常量； constexpr 只能定义编译期常量。 1 2 3 4 5 6 7 const int a = 10; // 编译期常量，存放在静态存储区的rodata段 int main() { int b = 20; // 栈 const int c = b; // 栈（运行期常量） // constexpr int c = b; Error: 因为b是一个普通变量，必须到运行期才能确定，constexpr无法修饰运行期常量。 } [2]普通函数必须在运行时才能执行，进而计算出结果。而常量表达式函数要求函数在编译期就计算出结果，运行时直接使用结果。也就是说将函数的执行从运行阶段转移到编译阶段，提升程序运行效率。 只需要在函数返回值类型前面加上constexpr关键字即可定义常量表达式函数，我们必须使用constexpr修饰的编译期常量来保存常量表达式函数的结果，否则常量表达式函数仍然会在运行期执行。\n1 2 3 4 5 6 7 8 constexpr int my_sum(int n) { if (n == 1) return 1; return n + my_sum(n - 1); } void test() { constexpr int a = my_sum(3); } [3]编译期常量对象的任何计算都在编译期完成。定义编译期常量对象，有以下几点要求：\n构造函数使用constexpr修饰，必须使用初始化列表对成员进行初始化； 对象调用的成员函数必须使用constexpr修饰。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Box { public: // 构造函数使用constexptr修饰，并且使用初始化列表对成员进行初始化。这就保证了对象成员m_l、m_w、m_h在编译期确定其值。 constexpr Box(int l, int w, int h) : m_l(l), m_w(w), m_h(h) {} // get_volume函数被定义为了常量表达式成员函数，调用该函数则会在编译阶段计算出结果。 constexpr int get_volume() const { return m_l * m_w * m_h; } // get_sum函数则是普通函数，该函数必须声明为const函数，否则无法被常量对象调用 int get_sum() const { return (m_l + m_w + m_h); } public: int m_l, m_w, m_h; }; void test() { constexpr Box box(10, 20, 30); // 程序编译期间调用常量表达式构造函数 constexpr int volume = box.get_volume(); // 在编译期计算出函数的执行结果，并赋值给编译期常量volume int my_sum = box.get_sum(); // 在运行期进行执行 } 单例模式 单例模式是一种设计模式，它确保一个类只有一个实例，并且提供一个全局访问点来访问它。 单例模式的实现一般需要将构造函数、析构函数私有化，禁用拷贝构造函数和赋值运算符，将成员变量和成员函数都设置成静态类型。\n懒汉单例模式实现 最简单的懒汉模式（在全局访问入口中声明静态变量。局部静态变量在C++11后也是线程安全的） 1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton { private: Singleton(); ~Singleton(); Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton* getInstance() { static Singleton instance; return \u0026amp;instance; } }; 加锁版本的懒汉单例模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Singleton { private: Singleton(); ~Singleton(); Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* instance; static pthread_mutex_t mutex; public: static Singleton* getInstance() { if (instance == nullptr) { pthread_mutex_lock(\u0026amp;mutex); instance = new Singleton(); pthread_mutex_unlock(\u0026amp;mutex); } return instance; } }; Singleton* Singleton::instance = nullptr; pthread_mutex_t Singleton::mutex = PTHREAD_MUTEX_INITIALIZER; 饿汉单例模式实现 饿汉单例模式天生线程安全，因为在main函数前已经初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton { private: Singleton(); ~Singleton(); Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* instance; public: static Singleton* getInstance() { return instance; } }; Singleton* Singleton::instance = new Singleton(); ","permalink":"https://kdjlyy.github.io/posts/tech/cs_basic_grammar/","summary":"成员变量初始化 构造函数内部初始化和初始化列表 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。 对于内置类型，如int, float等，使用初始化列表和在构造函数体内初始化差别不大； 对于类类型来说，使用初始化列表会减少调用默认构造函数的次数，更加高效。 1 2","title":"计算机基础知识总结（语法篇）"}]