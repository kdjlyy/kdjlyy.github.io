[{"content":"参考：https://www.cnblogs.com/benjieqiang/p/17501293.html#:~:text=3%E5%88%86%E9%92%9F%E5%AE%8C%E6%88%90Macbook%20m1%E8%8A%AF%E7%89%87%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85Elasticsearch%E5%92%8CKibana%201%201%E3%80%81%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6,2%202%E3%80%81%E5%88%9B%E5%BB%BAes%E5%AE%9E%E4%BE%8B%203%203%E3%80%81%E5%88%9B%E5%BB%BAKibana\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 docker pull elasticsearch:7.16.2 docker pull kibana:7.16.2 ➜ codes mkdir elasticsearch ➜ codes cd elasticsearch ➜ elasticsearch mkdir config ➜ elasticsearch mkdir data ➜ elasticsearch mkdir plugins ➜ codes chmod -R 777 ./elasticsearch ➜ codes echo \u0026#34;http.host: 0.0.0.0\u0026#34; \u0026gt;\u0026gt; elasticsearch/config/elasticsearch.yml ➜ codes # -d : 后台运行 # -p : 指定宿主机与docker启动容器的端口映射 # --name : 为 elasticsearch 容器起个别名 # -e : 指定为单节点集群模式 # -e ES_JAVA_OPTS=\u0026#34;-Xms64m -Xmx512m\u0026#34; \\ 设置ES的初始内存和最大内存，否则导致过大启动不了ES docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \\ -e \u0026#34;discovery.type=single-node\u0026#34; \\ -e ES_JAVA_OPTS=\u0026#34;-Xms64m -Xmx512m\u0026#34; \\ -v /Users/yuki/codes/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\ -v /Users/yuki/codes/elasticsearch/data:/usr/share/elasticsearch/data \\ -v /Users/yuki/codes/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\ -d elasticsearch:7.16.2 ➜ elasticsearch docker inspect -f \u0026#39;{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}\u0026#39; elasticsearch 172.17.0.2 docker run --name kibana -e ELASTICSEARCH_HOSTS=http://172.17.0.2:9200 -e \u0026#34;I18N_LOCALE=zh-CN\u0026#34; -p 5601:5601 -d kibana:7.16.2 docker pull alivv/elasticsearch-head vi config/elasticsearch.yml 添加 http.cors.enabled: true http.cors.allow-origin: \u0026#34;*\u0026#34; docker create --name elasticsearch-head -p 9100:9100 alivv/elasticsearch-head ","permalink":"https://kdjlyy.github.io/posts/tech/elasticsearch-start/","summary":"elasticsearch","title":"Elasticsearch初体验"},{"content":"Floyd算法 Floyd 算法（Floyd-Warshall algorithm）是解决加权图中顶点间的最短路径算法之一，使用范围：无负权回路即可，边权可以为负值，运行一次算法即可求得任意两点间最短路。\n其状态转移方程如下（结点 $i$ 借助 $k$ 更新到 $j$ 的距离）：\n$$G[i][j]=min(G[i][j],\\ G[i][k]+G[k][j]);$$\n$G[i][j]$ 表示顶点 $i$ 到 $j$ 的最短距离，$k$ 是枚举的借助的点，时间复杂度：$O(n^3)$。\n初始状态：\n如果 $i$，$j$ 之间有边，$G[i][j] = len$； 如果 $i == j$，$G[i][j] = 0$； 其余情况，$G[i][j] = ∞$。 注意：\n需要判断 $i → k$ 以及 $k → j$ 是否真的有边，如果没有的话要进行特判（因为如果 $len_{i→k}=∞,\\ len_{k→j}=-1,\\ len_{i→j}=∞$，此时不应该更新 $G[i][j]$）。\n模版：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 结点编号 0 - n-1 // edges[i] = [u, v, w] 表示有一条从 u 到 v 权值为 w 的边 void floyd(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { int G[n][n]; // 初始化 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { G[i][j] = (i==j)? 0: INT_MAX; } } // 建图 for (auto e : edges) { G[e[0]][e[1]] = e[2]; } for (int k = 0; k \u0026lt; n; k++) { // 穷举所以可能被借助的点 for (int i = 0; i \u0026lt; n; i++) { // 穷举所有的起点 for (int j = 0; j \u0026lt; n; j++) { // 穷举所有的终点 if (G[i][k] != INT_MAX \u0026amp;\u0026amp; G[k][j] != INT_MAX) { G[i][j] = min(G[i][j], G[i][k] + G[k][j]); } } } } } 例题：课程表 IV\nsasx\nsaxasca\n例子如下\ncaca\n","permalink":"https://kdjlyy.github.io/posts/algorithm/algorithm-graph/","summary":"图论, Floyd算法, 弗洛伊德算法","title":"图论专题"},{"content":" 本文主要介绍 Vue（2.x 版本）的基础使用方法，结合 ElementUI 和 Axios 可以快速搭建前端页面。\n准备工作 首先需要准备 node.js 环境，安装完成后查看环境是否正常：\n1 2 3 4 ➜ node -v v16.18.1 ➜ npm -v 9.8.1 之后就可以使用 npm 工具安装 Vue、ElementUI 以及 Axios：\n1 2 3 4 5 ➜ npm install vue -g ➜ npm install vue-cli -g // 安装脚手架 ➜ npm install vue-router ➜ npm install axios ➜ npm install element-ui -S 因为安装了脚手架工具，可以使用 vue ui 命令打开 Vue 项目管理器来创建 Vue 项目：\nVue 项目管理器 Vue项目介绍 项目结构 创建 Vue 项目成功后，我们可以看到项目的文件结构如下：\nVue 项目结构 启动项目 在项目根目录下，控制台输入 npm run serve 即可启动项目，同时可以在 package.json 文件指定服务的端口号：\n1 2 3 4 5 \u0026#34;scripts\u0026#34;: { \u0026#34;serve\u0026#34;: \u0026#34;vue-cli-service serve --port 12345 --open\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vue-cli-service build\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;vue-cli-service lint\u0026#34; } 或者在 vue.config.js 文件中添加配置：\n1 2 3 4 5 6 7 const { defineConfig } = require(\u0026#39;@vue/cli-service\u0026#39;) module.exports = defineConfig({ transpileDependencies: true, devServer: { port: 12345 } }) 开发流程 我们访问的首页是 index.html，但是打开 public/index.html 文件后发现代码很简洁，只有一个：\n1 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 而浏览器所呈现的 index.html 内容却很丰富。这是因为 Vue 项目的 index.html 文件默认引入了入口函数 main.js 文件，其代码如下：\n1 2 3 4 5 6 7 8 9 10 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; Vue.config.productionTip = false new Vue({ router, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 其中 $mount('#app') 将 Vue 对象创建的 dom 对象挂在到 id=\u0026quot;app\u0026quot; 的标签区域中。\nrender: h =\u0026gt; h(App) 中 render 是一个渲染函数，用于创建 HTML 模版。打开 App.vue，注意的是 .vue 结尾的都是 Vue 组件，而 Vue 的组件文件包含 3 个部分：\ntemplate: 模板部分，主要是 HTML 代码，用来展示页面主体结构； script: js 代码区域，主要是通过 js 代码来控制模板的数据来源和行为； style: css 样式部分，主要通过 css 样式控制模板的页面效果。 接下来我们可以简化模板部分内容，添加 script 部分的数据模型，删除 css 样式，完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{ message }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { \u0026#34;message\u0026#34;: \u0026#34;hello world!\u0026#34; } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 使用ElementUI和Axios Element 是饿了么公司前端开发团队提供的一套基于 Vue 的网站组件库，用于快速构建网页。\nAxios 是对原生的 AJAX 进行封装，用来发送异步请求。\n前面已经介绍如何安装 ElementUI，然后我们需要在 main.js 这个入口文件中引入 ElementUI 的组件库，其代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.config.productionTip = false Vue.use(ElementUI); new Vue({ router, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 然后在 views 文件夹下创建 StudentView.vue，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!-- 模版 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 脚本 --\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { \u0026#34;message\u0026#34;: \u0026#34;hello world!\u0026#34; }; } } \u0026lt;/script\u0026gt; \u0026lt;!-- 样式 --\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 接下来我们要使用 ElementUI 写一个学生管理系统页面，需要注意的是，我们默认访问的是 App.vue 这个组件，此时我们需要修改成引入 student-view 这个组件，此时 App.vue 整体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;student-view\u0026gt;\u0026lt;/student-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import StudentView from \u0026#39;./views/StudentView.vue\u0026#39;; export default { components: { StudentView }, data() { return { \u0026#34;message\u0026#34;: \u0026#34;hello world\u0026#34; }; }, } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 布局 首先去 ElementUI 的 Container 布局容器找到合适的布局，粘贴到 StudentView.vue 组件的 template 模块中即可： 1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- 模版 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-header\u0026gt;Header\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt;Aside\u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt;Main\u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/template\u0026gt; 同时设置 style：\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!-- 样式 --\u0026gt; \u0026lt;style\u0026gt; .el-container { height: 800px; border: 1px solid #eee } .el-header { background-color: #B3C0D1; color: #333; text-align: center; line-height: 60px; } .el-aside { background-color: #D3DCE6; color: #333; text-align: center; line-height: 200px; } .el-main { background-color: #E9EEF3; color: #333; text-align: center; line-height: 160px; } body\u0026gt;.el-container { margin-bottom: 40px; } .el-container:nth-child(5) .el-aside, .el-container:nth-child(6) .el-aside { line-height: 260px; } .el-container:nth-child(7) .el-aside { line-height: 320px; } \u0026lt;/style\u0026gt; 设置 Header、Aside、Main 的布局，完成后的布局如下： 布局展示-1 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 \u0026lt;!-- 模版 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;!-- 顶栏 --\u0026gt; \u0026lt;el-header style=\u0026#34;font-size:36px;background-color: #eff1f8\u0026#34;\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-col :span=\u0026#34;24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;grid-content bg-purple-dark\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-user-solid\u0026#34; color=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;学生管理系统\u0026lt;/div\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;!-- 导航栏 --\u0026gt; \u0026lt;el-aside width=\u0026#34;250px\u0026#34; style=\u0026#34;background-color: rgb(238, 241, 246)\u0026#34;\u0026gt; \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-menu\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;学生信息管理\u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;!-- 表格 --\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;id\u0026#34; label=\u0026#34;序号\u0026#34; width=\u0026#34;60\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{ (pageNum - 1) * pageSize + scope.$index + 1 }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;no\u0026#34; label=\u0026#34;学号\u0026#34; width=\u0026#34;150\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;120\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;class\u0026#34; label=\u0026#34;班级\u0026#34; width=\u0026#34;150\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;gender\u0026#34; label=\u0026#34;性别\u0026#34; width=\u0026#34;60\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;entryDate\u0026#34; label=\u0026#34;入学日期\u0026#34; width=\u0026#34;150\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;contact\u0026#34; label=\u0026#34;联系方式\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34; width=\u0026#34;300\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 脚本 --\u0026gt; \u0026lt;script\u0026gt; export default { data() { const item = { no: \u0026#39;SA20225525\u0026#39;, name: \u0026#39;王小虎\u0026#39;, class: \u0026#39;大数据3班\u0026#39;, gender: 1, entryDate: \u0026#39;2020-09-01\u0026#39;, contact: \u0026#39;18823456789\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39;, }; return { pageNum: 1, pageSize: 10, tableData: Array(10).fill(item) } } } \u0026lt;/script\u0026gt; \u0026lt;!-- 样式 --\u0026gt; \u0026lt;style\u0026gt; .el-container { height: 800px; border: 1px solid #ffffff; } .el-header { background-color: #B3C0D1; color: #333; text-align: center; line-height: 60px; } .el-aside { background-color: #D3DCE6; color: #333; text-align: center; line-height: 200px; } .el-main { background-color: #E9EEF3; color: #333; text-align: center; padding: 0; } body\u0026gt;.el-container { margin-bottom: 40px; } .el-header { background-color: #B3C0D1; color: #333; line-height: 60px; } .el-aside { color: #333; } \u0026lt;/style\u0026gt; js 脚本中的 data() 函数与模版进行了双向数据绑定，我们可以在 HTML 代码中引用 data() 函数的返回值。\n添加控件 接下来我们为页面添加搜索和分页控件，从 ElementUI 官网找到对应的控件粘贴到模版里，并且在脚本部分建立对应的数据模型，此时页面样式和对应的代码如下：\n布局展示-2 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 \u0026lt;!-- 模版 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;!-- 顶栏 --\u0026gt; \u0026lt;el-header style=\u0026#34;font-size:36px;background-color: #eff1f8\u0026#34;\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-col :span=\u0026#34;24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;grid-content bg-purple-dark\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-user-solid\u0026#34; color=\u0026#34;white\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;学生管理系统\u0026lt;/div\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;!-- 导航栏 --\u0026gt; \u0026lt;el-aside width=\u0026#34;250px\u0026#34; style=\u0026#34;background-color: rgb(238, 241, 246)\u0026#34;\u0026gt; \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-menu\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;学生信息管理\u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;!-- 表格 --\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;!-- 搜索栏 --\u0026gt; \u0026lt;el-form :inline=\u0026#34;true\u0026#34; :model=\u0026#34;searchForm\u0026#34; label=\u0026#34;left\u0026#34; class=\u0026#34;searchForm\u0026#34;\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-input v-model=\u0026#34;searchForm.no\u0026#34; placeholder=\u0026#34;学号\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-input v-model=\u0026#34;searchForm.name\u0026#34; placeholder=\u0026#34;姓名\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-select v-model=\u0026#34;searchForm.gender\u0026#34; placeholder=\u0026#34;性别\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;男\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;女\u0026#34; value=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-date-picker v-model=\u0026#34;searchForm.entryDate\u0026#34; type=\u0026#34;daterange\u0026#34; range-separator=\u0026#34;至\u0026#34; start-placeholder=\u0026#34;开始日期\u0026#34; end-placeholder=\u0026#34;结束日期\u0026#34;\u0026gt; \u0026lt;/el-date-picker\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSearchStudent\u0026#34;\u0026gt;搜索\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;!-- 表格 --\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; style=\u0026#34;width: 100%;\u0026#34;\u0026gt; \u0026lt;el-table-column type=\u0026#34;index\u0026#34; label=\u0026#34;序号\u0026#34; width=\u0026#34;60\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;!-- \u0026lt;el-table-column prop=\u0026#34;id\u0026#34; label=\u0026#34;序号\u0026#34; width=\u0026#34;60\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{ (pageNum - 1) * pageSize + scope.$index + 1 }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; --\u0026gt; \u0026lt;el-table-column prop=\u0026#34;no\u0026#34; label=\u0026#34;学号\u0026#34; width=\u0026#34;120\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;90\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;class\u0026#34; label=\u0026#34;班级\u0026#34; width=\u0026#34;120\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;gender\u0026#34; label=\u0026#34;性别\u0026#34; :formatter=\u0026#34;genderFormate\u0026#34; width=\u0026#34;60\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;entryDate\u0026#34; label=\u0026#34;入学日期\u0026#34; width=\u0026#34;120\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;contact\u0026#34; label=\u0026#34;联系方式\u0026#34; width=\u0026#34;150\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34; width=\u0026#34;300\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34;\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; size=\u0026#34;mini\u0026#34; @click=\u0026#34;onEditStudent\u0026#34;\u0026gt;编辑\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; size=\u0026#34;mini\u0026#34; @click=\u0026#34;onDeleteStudent\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;!-- Pagination分页 --\u0026gt; \u0026lt;el-pagination @size-change=\u0026#34;handleSizeChange\u0026#34; @current-change=\u0026#34;handleCurrentChange\u0026#34; background layout=\u0026#34;sizes, prev, pager, next, jumper, total\u0026#34; :total=\u0026#34;pageForm.total\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 脚本 --\u0026gt; \u0026lt;script\u0026gt; export default { data() { const item = { \u0026#39;no\u0026#39;: \u0026#39;SA20225525\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;王小虎\u0026#39;, \u0026#39;class\u0026#39;: \u0026#39;大数据3班\u0026#39;, \u0026#39;gender\u0026#39;: 1, \u0026#39;entryDate\u0026#39;: \u0026#39;2020-09-01\u0026#39;, \u0026#39;contact\u0026#39;: \u0026#39;18823456789\u0026#39;, \u0026#39;address\u0026#39;: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39;, }; return { pageNum: 1, pageSize: 10, tableData: Array(10).fill(item), genderFormate(row) { if (row.gender == 1) return \u0026#34;男\u0026#34; else if (row.gender == 0) return \u0026#34;女\u0026#34; else return \u0026#34;未知\u0026#34; }, // 搜索栏 searchForm: { \u0026#39;no\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;gender\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;entryDate\u0026#39;: \u0026#39;\u0026#39;, }, // 分页 pageForm: { total: 56, } } }, methods: { // 搜索 onSearchStudent() { console.log(\u0026#34;搜索\u0026#34;); }, // 分页 handleSizeChange(val) { console.log(`每页 ${val} 条`); }, handleCurrentChange(val) { console.log(`当前页: ${val}`); }, // 编辑 onEditStudent() { }, // 删除 onDeleteStudent() { } }, } \u0026lt;/script\u0026gt; \u0026lt;!-- 样式 --\u0026gt; \u0026lt;style\u0026gt; .el-container { height: 800px; border: 1px solid #ffffff; } .el-header { background-color: #B3C0D1; color: #333; text-align: center; line-height: 60px; } .el-aside { background-color: #D3DCE6; color: #333; text-align: center; line-height: 200px; } .el-main { background-color: #E9EEF3; color: #333; text-align: left; padding: 0; } body\u0026gt;.el-container { margin-bottom: 40px; } .el-header { background-color: #B3C0D1; color: #333; line-height: 60px; } .el-aside { color: #333; } .el-pagination { margin-top: 5px; } \u0026lt;/style\u0026gt; 使用Axios TODO:\nVue路由 在 src/router/index.js 文件中定义路由表，根据其提供的模板代码进行修改，最终代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import Vue from \u0026#39;vue\u0026#39; import VueRouter from \u0026#39;vue-router\u0026#39; import StudentView from \u0026#39;../views/StudentView.vue\u0026#39; import AboutView from \u0026#39;../views/AboutView.vue\u0026#39; Vue.use(VueRouter) const routes = [ { path: \u0026#39;/\u0026#39;, redirect: \u0026#39;/student\u0026#39;, // 首页重定向 }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;about\u0026#39;, component: AboutView }, { path: \u0026#39;/student\u0026#39;, name: \u0026#39;student\u0026#39;, component: StudentView } ] const router = new VueRouter({ routes }) export default router 此时，由于使用的是路由的方式控制页面跳转，所以 App.vue 页面更改为：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 使用路由 --\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; StudentView.vue 的导航栏绑定路由：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 导航栏 --\u0026gt; \u0026lt;el-aside width=\u0026#34;250px\u0026#34; style=\u0026#34;background-color: rgb(238, 241, 246)\u0026#34;\u0026gt; \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-menu\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;学生信息管理\u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/student\u0026#34;\u0026gt;学生基本信息\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt;关于\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; 打包部署 前端工程开发后可以通过nginx服务器发布前端工程。\n","permalink":"https://kdjlyy.github.io/posts/tech/vue-start/","summary":"Vue, Vue2, 前端, ElementUI, axios","title":"Vue2开发指南"},{"content":"reveal.js简介 reveal.js 是一个开源的 HTML 展示框架。我们可以使用它做出各种精美的幻灯片，和传统的 PPT 不同，reveal.js 需要在浏览器中运行，并且可以把 Markdown 文件转为类似 PPT 的演示文稿，轻快省力，减少排版上的时间，更专于文字内容，同时也获得 PPT 所不具有的灵活性。\n安装教程 reveal.js 的官网有详细说明，一般的安装/启动步骤如下：\ngit clone https://github.com/hakimel/reveal.js.git\ncd reveal.js \u0026amp;\u0026amp; npm install\nnpm start\n打开 http://localhost:8000/ 即可预览\n自定义端口启动：npm start -- --port=8008\n使用教程 简介 用 vscode 打开/reveal.js/index.html，这是一个简单的样例，只有两页 slides，分别显示“Slide 1”和“Slide 2”：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\u0026#34;\u0026gt; \u0026lt;title\u0026gt;reveal.js\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;dist/reset.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;dist/reveal.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;dist/theme/black.css\u0026#34;\u0026gt; \u0026lt;!-- 主题 --\u0026gt; \u0026lt;!-- Theme used for syntax highlighted code --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;plugin/highlight/monokai.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;reveal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slides\u0026#34;\u0026gt; \u0026lt;section\u0026gt;Slide 1\u0026lt;/section\u0026gt; \u0026lt;section\u0026gt;Slide 2\u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;dist/reveal.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;plugin/notes/notes.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;plugin/markdown/markdown.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;plugin/highlight/highlight.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // More info about initialization \u0026amp; config: // - https://revealjs.com/initialization/ // - https://revealjs.com/config/ Reveal.initialize({ hash: true, // Learn about plugins: https://revealjs.com/plugins/ plugins: [RevealMarkdown, RevealHighlight, RevealNotes] }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在 index.html 里，可以看到一对\u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;之间嵌套了一对\u0026lt;div class=\u0026quot;reveal\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;，而\u0026lt;div class=\u0026quot;slides\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;之间的内容对应页面显示的内容。\n分页 reveal.js 有两种页面类型，横向的一级页面、纵向的子页面。后者务必嵌套在前者里面。键盘上的左右箭头控制一级页面，上下键移动子页面。\nreveal.js 分页演示 对应的代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;div class=\u0026#34;reveal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slides\u0026#34;\u0026gt; \u0026lt;section\u0026gt;Welcome ~\u0026lt;/section\u0026gt; \u0026lt;!-- 一级页面 --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;section\u0026gt;你好！\u0026lt;/section\u0026gt; \u0026lt;!-- 子页面 --\u0026gt; \u0026lt;section\u0026gt;Hello World!\u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; 《西游记》 \u0026lt;section\u0026gt;第一回 灵根育孕源流出 心性修持大道生\u0026lt;/section\u0026gt; \u0026lt;section\u0026gt;第二回 悟彻菩提真妙理 断魔归本合元神\u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 分段显示 如果需要在演示时分段显示，可以使用：\n1 2 3 4 5 6 \u0026lt;section\u0026gt; \u0026lt;p class=\u0026#34;fragment\u0026#34; style=\u0026#34;font-size: larger;\u0026#34;\u0026gt;《泊秦淮》\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;fragment\u0026#34; style=\u0026#34;font-size: smaller;\u0026#34;\u0026gt;杜牧\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;fragment\u0026#34;\u0026gt;\u0026amp;nbsp;烟笼寒水月笼沙，夜泊秦淮近酒家。\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;fragment\u0026#34;\u0026gt;\u0026amp;nbsp;商女不知亡国恨，隔江犹唱后庭花。\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; reveal.js 分段显示 支持 markdown 语法 reveal.js 支持简单的 markdown 的写法，在\u0026lt;section\u0026gt; 标签里添加data-markdown 属性，表示该段内容用 markdown 引擎解析：\nreveal.js markdown演示 对应的代码为： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;div class=\u0026#34;reveal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slides\u0026#34;\u0026gt; \u0026lt;section\u0026gt; \u0026lt;section data-markdown\u0026gt; ### 怎么把大象放进冰箱？ \u0026gt; How to put an elephant in the refrigerator? ![](/Users/yuki/Pictures/elephant_icon.png) 1. 打开冰箱门； 2. 放入大象； 3. 关上冰箱门。 --- | 左对齐标题 | 右对齐标题 | 居中对齐标题 | | :------| ------: | :------: | | 短文本 | 中等文本 | 稍微长一点的文本 | | 稍微长一点的文本 | 短文本 | 中等文本 | \u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 背景 支持使用\u0026lt;section data-background=\u0026quot;\u0026quot;\u0026gt;设置不同颜色的背景：\n1 2 3 \u0026lt;section data-background=\u0026#34;#F0FFF0\u0026#34;\u0026gt; This page\u0026#39;s color called \u0026lt;b\u0026gt;Honeydew\u0026lt;/b\u0026gt;. \u0026lt;/section\u0026gt; 可以使用图片背景：\n1 2 3 4 \u0026lt;section data-background-image=\u0026#34;/Users/yuki/Pictures/95698585_p0_master1200.jpeg\u0026#34;\u0026gt; \u0026lt;h3 style=\u0026#34;background-color: rgba(0, 0, 0, 0.8);\u0026#34;\u0026gt;その可憐な少女は魔女であり、旅人でした。 ―― そう、私です。\u0026lt;/h3\u0026gt; \u0026lt;blockquote style=\u0026#34;color: gray; background-color: rgba(0, 0, 0, 0.8);\u0026#34;\u0026gt;请别在意，我是个旅人，得继续旅行才行。\u0026lt;/blockquote\u0026gt; \u0026lt;/section\u0026gt; reveal.js 图片背景 甚至可以使用视频作为背景：\n1 2 3 \u0026lt;section data-background-video=\u0026#34;https://oss.ppter8.com/lobZ-1_HVl-QWpIZr6NhlBAVOajm-1050x.mp4\u0026#34;\u0026gt; This page\u0026#39;s video video background from \u0026lt;a href=\u0026#34;https://oss.ppter8.com/lobZ-1_HVl-QWpIZr6NhlBAVOajm-1050x.mp4\u0026#34;\u0026gt;PPTer\u0026lt;/a\u0026gt;. \u0026lt;/section\u0026gt; reveal.js 视频背景 自动动画 有些幻灯片中我们想实现如渐变、滑动、新增或者删除元素等动画效果。reveal.js 会自动为幻灯片中的元素设置动画效果，我们需要做的就是在相邻的两页section元素上添加data-auto-animate属性，这样 reveal.js 会为所有匹配的元素设置动画：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h3\u0026gt;reveal.js 的优点\u0026lt;/h3\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h3\u0026gt;Reveal.js的优点\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;界面优美\u0026lt;/li\u0026gt; \u0026lt;!-- \u0026lt;li\u0026gt; 元素表示列表里的条目。它必须包含在一个父元素里：一个有序列表 (\u0026lt;ol\u0026gt;)，一个无序列表 (\u0026lt;ul\u0026gt;)，或者一个菜单 (\u0026lt;menu\u0026gt;)。 --\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h3\u0026gt;Reveal.js的优点\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;界面优美\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;运行简单\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h3\u0026gt;Reveal.js的优点\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;界面优美\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;运行简单\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;功能强大\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; reveal.js 自动动画演示 自动动画标签 对于图片、视频和 iframe 等多媒体元素，reveal.js 通过比较他们的 src 属性来自动匹配相同的元素，即相邻的幻灯片，文本内容改变了（比如上面第二张幻灯片“界面优美”→“界面好看”），那么动画效果就会失效。我们可以在元素上添加data-id属性来强制进行动画效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!-- 自动动画标签 --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h2\u0026gt;自动动画\u0026lt;/h2\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h2 data-id=\u0026#34;tag_1\u0026#34; style=\u0026#34;text-align: left; color: rgb(0, 255, 94);\u0026#34;\u0026gt;自动动画 1\u0026lt;/h2\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h2 data-id=\u0026#34;tag_1\u0026#34; style=\u0026#34;text-align: right; color: rgb(87, 87, 212);\u0026#34;\u0026gt;自动动画 2\u0026lt;/h2\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; reveal.js 自动动画标签演示 我们看到第一个动画到第二个动画之间，由于自动匹配失效，因此没有动画；第二个动画到第三个动画之间由于我们强制加上了data-id属性，因此动画效果依然是生效的。\n自动动画ID 有时候我们会存在多个动画，相邻的动画有可能会互相干扰，可以通过data-auto-animate-id和data-auto-animate-restart对动画进行分组。我们可以对相邻分组的幻灯片上加上data-auto-animate-id属性，属性的值可以是任意的，相同组保证值相同即可；这样，相邻的幻灯片会识别相同的id进行动画效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!-- 自动动画ID --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-id=\u0026#34;one\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: white;\u0026#34;\u0026gt;第一组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-id=\u0026#34;one\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: #3B82F6;\u0026#34;\u0026gt;第一组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-id=\u0026#34;two\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: white;\u0026#34;\u0026gt;第二组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-id=\u0026#34;two\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: #10B981;\u0026#34;\u0026gt;第二组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-id=\u0026#34;three\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: white;\u0026#34;\u0026gt;第三组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-id=\u0026#34;three\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: #EC4899;\u0026#34;\u0026gt;第三组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; reveal.js 自动动画ID演示 如果同一组的幻灯片比较多，我们需要加上很多的 id，上面的方式显得比较繁琐。因此 reveal.js 提供另一种控制动画的方式：data-auto-animate-restart属性；这个属性会阻止上一张幻灯片和本组幻灯片之间的动画效果（即使他们有相同的 id）:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!-- 自动动画ID（方法2） --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h1 style=\u0026#34;color: white;\u0026#34;\u0026gt;第一组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h1 style=\u0026#34;color: #3B82F6;\u0026#34;\u0026gt;第一组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-restart\u0026gt; \u0026lt;!-- id restart --\u0026gt; \u0026lt;h1 style=\u0026#34;color: white;\u0026#34;\u0026gt;第二组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h1 style=\u0026#34;color: #10B981;\u0026#34;\u0026gt;第二组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-restart\u0026gt; \u0026lt;!-- id restart --\u0026gt; \u0026lt;h1 style=\u0026#34;color: white;\u0026#34;\u0026gt;第三组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h1 style=\u0026#34;color: #EC4899;\u0026#34;\u0026gt;第三组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; 代码 reveal.js 使用 highlight.js 来支持代码高亮。可以直接写\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;标签来实现, data-trim表示去除多余的空格，data-line-numbers表示突出显示，data-noescape 来避免自动转义。这里代码块是套在\u0026lt;script type='text/html' style='display:block'\u0026gt;\u0026lt;/script\u0026gt;中间，以防代码格式异常（根据实际情况选择使用）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!-- 代码 --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code class=\u0026#34;hljs cpp\u0026#34; data-trim data-line-numbers=\u0026#34;5-7\u0026#34; data-noescape\u0026gt; \u0026lt;script type=\u0026#39;text/html\u0026#39; style=\u0026#39;display:block\u0026#39;\u0026gt;// 使用返回 tuple 和 decomposition declarations 语法来模拟 Go 语言函数多返回值功能 #include \u0026lt;iostream\u0026gt; #include \u0026lt;tuple\u0026gt; std::tuple\u0026lt;std::string, bool\u0026gt; foo() { return std::make_tuple(\u0026#34;hello\u0026#34;, true); } int main() { auto [val, flag] = foo(); if (flag) { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } return 0; } \u0026lt;/script\u0026gt; \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;/section\u0026gt; reveal.js 代码显示 数学公式 导入脚本：\n1 \u0026lt;script src=\u0026#34;plugin/math/math.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 初始化设置：\n1 2 3 4 5 6 7 8 9 10 11 12 Reveal.initialize({ math: { mathjax: \u0026#39;https://cdn.jsdelivr.net/gh/mathjax/mathjax@2.7.8/MathJax.js\u0026#39;, config: \u0026#39;TeX-AMS_HTML-full\u0026#39;, TeX: { Macros: { RR: \u0026#34;{\\\\bf R}\u0026#34; } } }, plugins: [RevealMath] }); 代码：\n1 2 3 4 5 6 7 \u0026lt;!-- 公式 --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;a style=\u0026#34;font-family: \u0026#39;Times New Roman\u0026#39;, Times, serif; color: white;\u0026#34;\u0026gt; $$ \\lim_{x \\to \\infty} x^2_{22} - \\int_{1}^{5}x\\mathrm{d}x + \\sum_{n=1}^{20} n^{2} = \\prod_{j=1}^{3} y_{j} + \\lim_{x \\to -2} \\frac{x-2}{x} $$ \u0026lt;/a\u0026gt; \u0026lt;/section\u0026gt; reveal.js 数学公式 其他 浏览器播放幻灯片时，按“ECS”进入视图模式；\n浏览器播放幻灯片时，按“B”暂停播放（熄灭屏幕）；\n默认的字体普遍偏大，可以在/reveal.js/dist/theme/目录下更改；\n在演说时，会用到注释，对于注释，可以通过\u0026lt;aside class=\u0026quot;notes\u0026quot;\u0026gt;来实现：\n1 2 3 \u0026lt;aside class=\u0026#34;notes\u0026#34;\u0026gt; 这里是注释。 \u0026lt;/aside\u0026gt; 在幻灯片页面，按下s键，就可以调出注释页面，注释页面包含了当前幻灯片、下一章幻灯片、注释，以及幻灯片播放时间。\n更多功能请参考/reveal.js/demo.html以及 reveal.js 的官网/Github，本文介绍的 reveal.js 的功能源文件如下：\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\u0026#34;\u0026gt; \u0026lt;title\u0026gt;reveal.js\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;dist/reset.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;dist/reveal.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;dist/theme/dracula.css\u0026#34;\u0026gt; \u0026lt;!-- Theme used for syntax highlighted code --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;plugin/highlight/monokai.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;reveal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slides\u0026#34;\u0026gt; \u0026lt;section\u0026gt; \u0026lt;p class=\u0026#34;fragment\u0026#34; style=\u0026#34;font-size: larger;\u0026#34;\u0026gt;《泊秦淮》\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;fragment\u0026#34; style=\u0026#34;font-size: smaller;\u0026#34;\u0026gt;杜牧\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;fragment\u0026#34;\u0026gt;\u0026amp;nbsp;烟笼寒水月笼沙，夜泊秦淮近酒家。\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;fragment\u0026#34;\u0026gt;\u0026amp;nbsp;商女不知亡国恨，隔江犹唱后庭花。\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;!-- markdown 写法 --\u0026gt; \u0026lt;section data-markdown\u0026gt; ### 怎么把大象放进冰箱？ \u0026gt; How to put an elephant in the refrigerator? ![](/Users/yuki/Pictures/elephant_icon.png) 1. 打开冰箱门； 2. 放入大象； 3. 关上冰箱门。 --- | 左对齐标题 | 右对齐标题 | 居中对齐标题 | | :------| ------: | :------: | | 短文本 | 中等文本 | 稍微长一点的文本 | | 稍微长一点的文本 | 短文本 | 中等文本 | \u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 背景颜色 --\u0026gt; \u0026lt;section data-background=\u0026#34;#F0FFF0\u0026#34;\u0026gt; This page\u0026#39;s color called \u0026lt;b\u0026gt;Honeydew\u0026lt;/b\u0026gt;. \u0026lt;/section\u0026gt; \u0026lt;!-- 图片背景和不透明度调节 --\u0026gt; \u0026lt;section data-background-image=\u0026#34;/Users/yuki/Pictures/95698585_p0_master1200.jpeg\u0026#34;\u0026gt; \u0026lt;h3 style=\u0026#34;background-color: rgba(0, 0, 0, 0.8);\u0026#34;\u0026gt;その可憐な少女は魔女であり、旅人でした。 ―― そう、私です。\u0026lt;/h3\u0026gt; \u0026lt;blockquote style=\u0026#34;color: gray; background-color: rgba(0, 0, 0, 0.8);\u0026#34;\u0026gt;请别在意，我是个旅人，得继续旅行才行。\u0026lt;/blockquote\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 视频背景 --\u0026gt; \u0026lt;section data-background-video=\u0026#34;https://oss.ppter8.com/lobZ-1_HVl-QWpIZr6NhlBAVOajm-1050x.mp4\u0026#34;\u0026gt; This page\u0026#39;s video video background from \u0026lt;a href=\u0026#34;https://oss.ppter8.com/lobZ-1_HVl-QWpIZr6NhlBAVOajm-1050x.mp4\u0026#34;\u0026gt;PPTer\u0026lt;/a\u0026gt;. \u0026lt;/section\u0026gt; \u0026lt;!-- 自动动画 --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h3\u0026gt;reveal.js 的优点\u0026lt;/h3\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h3\u0026gt;Reveal.js的优点\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;界面优美\u0026lt;/li\u0026gt; \u0026lt;!-- \u0026lt;li\u0026gt; 元素表示列表里的条目。它必须包含在一个父元素里：一个有序列表 (\u0026lt;ol\u0026gt;)，一个无序列表 (\u0026lt;ul\u0026gt;)，或者一个菜单 (\u0026lt;menu\u0026gt;)。 --\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h3\u0026gt;Reveal.js的优点\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;界面优美\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;运行简单\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h3\u0026gt;Reveal.js的优点\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;界面优美\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;运行简单\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;功能强大\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 自动动画标签 --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h2\u0026gt;自动动画\u0026lt;/h2\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h2 data-id=\u0026#34;tag_1\u0026#34; style=\u0026#34;text-align: left; color: rgb(0, 255, 94);\u0026#34;\u0026gt;自动动画 1\u0026lt;/h2\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h2 data-id=\u0026#34;tag_1\u0026#34; style=\u0026#34;text-align: right; color: rgb(87, 87, 212);\u0026#34;\u0026gt;自动动画 2\u0026lt;/h2\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 自动动画ID --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-id=\u0026#34;one\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: white;\u0026#34;\u0026gt;第一组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-id=\u0026#34;one\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: #3B82F6;\u0026#34;\u0026gt;第一组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-id=\u0026#34;two\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: white;\u0026#34;\u0026gt;第二组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-id=\u0026#34;two\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: #10B981;\u0026#34;\u0026gt;第二组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-id=\u0026#34;three\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: white;\u0026#34;\u0026gt;第三组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-id=\u0026#34;three\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;color: #EC4899;\u0026#34;\u0026gt;第三组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 自动动画ID（方法2） --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h1 style=\u0026#34;color: white;\u0026#34;\u0026gt;第一组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h1 style=\u0026#34;color: #3B82F6;\u0026#34;\u0026gt;第一组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-restart\u0026gt; \u0026lt;!-- id restart --\u0026gt; \u0026lt;h1 style=\u0026#34;color: white;\u0026#34;\u0026gt;第二组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h1 style=\u0026#34;color: #10B981;\u0026#34;\u0026gt;第二组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate data-auto-animate-restart\u0026gt; \u0026lt;!-- id restart --\u0026gt; \u0026lt;h1 style=\u0026#34;color: white;\u0026#34;\u0026gt;第三组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section data-auto-animate\u0026gt; \u0026lt;h1 style=\u0026#34;color: #EC4899;\u0026#34;\u0026gt;第三组动画\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 代码 --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code class=\u0026#34;hljs cpp\u0026#34; data-trim data-line-numbers=\u0026#34;5-7\u0026#34; data-noescape\u0026gt; \u0026lt;script type=\u0026#39;text/html\u0026#39; style=\u0026#39;display:block\u0026#39;\u0026gt;// 使用返回 tuple 和 decomposition declarations 语法来模拟 Go 语言函数多返回值功能 #include \u0026lt;iostream\u0026gt; #include \u0026lt;tuple\u0026gt; std::tuple\u0026lt;std::string, bool\u0026gt; foo() { return std::make_tuple(\u0026#34;hello\u0026#34;, true); } int main() { auto [val, flag] = foo(); if (flag) { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } return 0; } \u0026lt;/script\u0026gt; \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 公式 --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;a style=\u0026#34;font-family: \u0026#39;Times New Roman\u0026#39;, Times, serif; color: white;\u0026#34;\u0026gt; $$ \\lim_{x \\to \\infty} x^2_{22} - \\int_{1}^{5}x\\mathrm{d}x + \\sum_{n=1}^{20} n^{2} = \\prod_{j=1}^{3} y_{j} + \\lim_{x \\to -2} \\frac{x-2}{x} $$ \u0026lt;/a\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;dist/reveal.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;plugin/notes/notes.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;plugin/markdown/markdown.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;plugin/highlight/highlight.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;plugin/math/math.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // More info about initialization \u0026amp; config: // - https://revealjs.com/initialization/ // - https://revealjs.com/config/ Reveal.initialize({ math: { mathjax: \u0026#39;https://cdn.jsdelivr.net/gh/mathjax/mathjax@2.7.8/MathJax.js\u0026#39;, config: \u0026#39;TeX-AMS_HTML-full\u0026#39;, TeX: { Macros: { RR: \u0026#34;{\\\\bf R}\u0026#34; } } }, hash: true, controls: true, // 在右下角显示控制面板 slideNumber: true, // 显示幻灯片页码，可使用代码 slideNumber: \u0026#39;c/t\u0026#39;，表示 \u0026#39;当前页/总页数\u0026#39; // Learn about plugins: https://revealjs.com/plugins/ plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath] }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 【参考】：\nReveal.js：把你的 Markdown 文稿变成 PPT\n网页幻灯片演示框架：Reveal.js\nHTML5幻灯片库reveal.js使用\n","permalink":"https://kdjlyy.github.io/posts/tech/revealjs-start/","summary":"reveal.js, revealjs","title":"reveal.js体验"},{"content":"二叉树定义与基础操作 二叉树结点定义 1 2 3 4 5 6 struct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right): val(x), left(left), right(right) {} }; 建立二叉树 1 2 3 4 5 6 7 8 9 10 11 // 先序建立二叉树，返回根节点，空节点用 0 表示 TreeNode* createBiTree(TreeNode *root) { int val; cin \u0026gt;\u0026gt; val; if (val) { root = new TreeNode(val); root-\u0026gt;left = createBiTree(root-\u0026gt;left); root-\u0026gt;right = createBiTree(root-\u0026gt;right); } return root; } 例如输入：1 2 3 0 0 4 0 0 5 0 0，对应的二叉树为：\n1 2 3 4 5 1 / \\ 2 5 / \\ 3 4 二叉树的遍历 先序遍历 中序遍历 后序遍历 通用版本 ","permalink":"https://kdjlyy.github.io/posts/algorithm/algorithm-tree/","summary":"数, 二叉树, 遍历, 先序遍历, 中序遍历，后序遍历","title":"二叉树专题"},{"content":"链表定义与基础操作 链表的结点定义 1 2 3 4 5 6 7 struct ListNode { int val; ListNode *next; ListNode(): val(0), next(nullptr) {} ListNode(int x): val(x), next(nullptr) {} ListNode(int x, ListNode *next): val(x), next(next) {} }; 建立单链表 建立单链表可以使用尾插法和头插法，为了方便操作这里申请了一个“dummy_head”结点，指向链表头部。使用头插法建立的链表和输入序列相反，例如输入：“1 2 3 4 5”，建立的链表为：5→4→3→2→1。\n尾插法 1 2 3 4 5 6 7 8 9 10 11 ListNode *create_linklist_tail_insert() { ListNode *dummy_head = new ListNode(-1); ListNode *node = dummy_head; int t; while (cin \u0026gt;\u0026gt; t) { node-\u0026gt;next = new ListNode(t); node = node-\u0026gt;next; } return dummy_head-\u0026gt;next; } 头插法 1 2 3 4 5 6 7 8 9 10 11 12 ListNode *create_linklist_front_insert() { ListNode *dummy_head = new ListNode(-1); ListNode *node = nullptr; int t; while(cin \u0026gt;\u0026gt; t) { node = new ListNode(t); node-\u0026gt;next = dummy_head-\u0026gt;next; dummy_head-\u0026gt;next = node; } return dummy_head-\u0026gt;next; } 合并两个有序单链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ListNode *merge_two_ordered_linklist(ListNode *l1, ListNode *l2) { if (l1 == nullptr) return l2; if (l2 == nullptr) return l1; ListNode *dummy_head = new ListNode(-1); ListNode *node = dummy_head; while(l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { node-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { node-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } node = node-\u0026gt;next; } node-\u0026gt;next = l1? l1: l2; return dummy_head-\u0026gt;next; } 判断链表是否有环 通过快慢指针有效解决此类问题。快指针每次相对慢指针多走一步，当快慢指针都在链表的环内时，快指针最多多走一圈能追上慢指针。\n1 2 3 4 5 6 7 8 9 10 bool hasCycle(ListNode *head) { if (head == nullptr || head -\u0026gt;next == nullptr) return false; ListNode *slow = head, *fast = head; while(fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) return true; } return false; } 进阶：找到环形链表的入口结点 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n[解析]：我们找到快慢指针 $f,s$ 相遇的环内结点，此时让指针 $t$ 从链表头部出发，让 $s$ 和 $t$ 同步移动，当 $s$ 和 $t$ 相遇时，该处即为环形链表的入口结点。证明如下：\n证明 设链表中环外部分的长度为 $a$，慢指针进入环后，又走了 $b$ 的距离与快指针相遇。此时，设快指针已经走完了环的 $n$ 圈，因此它走过的总距离为 $a+n(b+c)+b$。\n又因为快指针走过的距离一定为慢指针的两倍，所以有：\n\\begin{equation} \\begin{aligned} \u0026amp;a+n(b+c)+b=2(a+b)\\\\ \\Rightarrow\\quad \u0026amp;a=c+(n-1)(b+c) \\end{aligned} \\end{equation}\n我们发现：从相遇点到入环点的距离加上 $n−1$ 圈的环长，恰好等于从链表头部到入环点的距离，所以 $s$ 和 $t$ 会在环形链表的入口结点相遇。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ListNode *detectCycle(ListNode *head) { if (head == nullptr || head-\u0026gt;next == nullptr) return nullptr; ListNode *s = head, *f = head, *t = head; while(f \u0026amp;\u0026amp; f-\u0026gt;next) { s = s-\u0026gt;next; f = f-\u0026gt;next-\u0026gt;next; if (f == s) break; } if (f != s) return nullptr; // 无环 while(t != s) { t = t-\u0026gt;next, s = s-\u0026gt;next; } return t; } ","permalink":"https://kdjlyy.github.io/posts/algorithm/algorithm-linkedlist/","summary":"链表, linkedlist, 尾插法, 头插法, 合并两个有序单链表, 判断链表是否有环","title":"链表专题"},{"content":" 这里的搜索算法指的是 DFS、BFS等常见的基础算法。\nTODO: leetcode 迷宫II 迷宫III\nDFS\u0026amp;BFS 记忆化搜索 记忆化搜索不像深度优先搜索那样重复枚举所有情况，而是把已经计算的子问题保存下来，所以说：记忆化搜索 = 深度优先搜索的实现 + 动态规划的思想。\n例1：矩阵中的最长递增路径\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int n, m, path[202][202], res = 0; // path[i][j] 表示 matrix[i][j] 位置的最长递增路径 int d[5] = {-1, 0, 1, 0, -1}; int dfs(int x, int y, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { if (path[x][y] != 0) return path[x][y]; // 使用已经存储的数据 path[x][y] = 1; // 初始化为1 for (int i = 0; i \u0026lt; 4; i++) { int nx = x + d[i], ny = y + d[i+1]; if (nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; n \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; m \u0026amp;\u0026amp; matrix[nx][ny] \u0026gt; matrix[x][y]) path[x][y] = max(path[x][y], dfs(nx, ny, matrix) + 1); } return path[x][y]; } int longestIncreasingPath(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { n = matrix.size(), m = matrix[0].size(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { res = max(res, dfs(i, j, matrix)); } } return res; } }; 此外这道题也可以用动态规划的方法解决，参考：动态规划\n","permalink":"https://kdjlyy.github.io/posts/algorithm/algorithm-search/","summary":"搜索算法, DFS, BFS, 记忆化搜索","title":"搜索算法专题"},{"content":"动态规划入门 例1：最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n【解法1】：\n[解析]：对于每一位数字，都有选和不选两种抉择。用 $dp[i]$ 表示以 $nums[i]$ 结尾的连续子数组的最大和。\n如果数组的数都是正数，对于第 $i$ 个数，很明显有：$dp[i]=dp[i-1]+nums[i],\\quad (i\u0026gt;0)$，这里的 $dp[i-1]$ 恒大于 0。\n当 $dp[i-1]\u0026lt;0$ 时，很明显 $dp[i]=nums[i]$，即重新计算最大子数组和，因为 $dp[i-1]$ 已经产生了负收益。\n初始时 $dp[0]=nums[0]$，最终数组中最大子数组和为 $dp[i]$ 中的最大值。\n代码 1 2 3 4 5 6 7 8 9 int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; dp(n); dp[0] = nums[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i] = max(nums[i], dp[i-1] + nums[i]); } return *max_element(dp.begin(), dp.end()); } 【解法2】：\n从解法1的动态规划方程可以看出，$dp[i]$ 仅与 $dp[i-1]$ 相关，所以我们可以利用滚动数组的思想继续优化时间复杂度。\n代码 1 2 3 4 5 6 7 8 int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int currmax = 0, res = nums[0]; for (int x : nums) { currmax = max(currmax + x, x); res = max(res, currmax); } return res; } 二维动态规划 例1：滑雪/矩阵中的最长递增路径 给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。\nmatrix example: result is 4 [解析]：我们用 $dp[i][j]$ 表示 $matrix$ 中以 $matrix[i][j]$ 为起点的最长递增路径，$dp[i][j]$ 初始为1，表示每个位置至少是长度为1的递增路径。 设 $(i^{\u0026rsquo;},j^{\u0026rsquo;})$ 为 $(i,j)$ 周围的某一点，则状态转移方程为：$$dp[i][j]=max(dp[i][j],\\ dp[i^{\u0026rsquo;}][j^{\u0026rsquo;}]+1),\\quad if \\ matrix[i^{\u0026rsquo;}][j^{\u0026rsquo;}]\u0026lt;matrix[i][j]$$\n需要注意的是，更新 $dp[i][j]$ 时是从高度更小的 $dp[i^{\u0026rsquo;}][j^{\u0026rsquo;}]$ 转移过来的，所以为了保证我们更新 $dp[i][j]$ 时 $dp[i^{\u0026rsquo;}][j^{\u0026rsquo;}]$ 已经准备好，我们需要新建一个 $M[m*n]$ 存储 $matrix$ 矩阵，并且按照高度对 $M$ 从小到大排序，按照排序后的 $M$ 数组的顺序更新 $dp[i][j]$。\n时间复杂度取决于排序操作，为 $O(nm\\log(nm))$。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: int n, m, dp[202][202]; // dp[i][j] 表示 matrix[i][j] 位置的最长递增路径 vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; M; // 矩阵的位置和高度 int d[5] = {-1, 0, 1, 0, -1}; int longestIncreasingPath(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { n = matrix.size(), m = matrix[0].size(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { M.emplace_back(make_tuple(i, j, matrix[i][j])); dp[i][j] = 1; } } sort(M.begin(), M.end(), [\u0026amp;](auto \u0026amp;x, auto \u0026amp;y){ auto \u0026amp;\u0026amp;[i1, j1, k1] = x; auto \u0026amp;\u0026amp;[i2, j2, k2] = y; return k1 \u0026lt; k2; }); for (int i = 0; i \u0026lt; n*m; i++) { auto [x, y, z] = M[i]; for (int j = 0; j \u0026lt; 4; j++) { // 比较周围的四个方向的点(x\u0026#39;,y\u0026#39;)，判断(x\u0026#39;,y\u0026#39;)的高度是否更小并且dp[x\u0026#39;][y\u0026#39;]+1是否比dp[x][y]更大 int nx = x + d[j], ny = y + d[j+1]; if (nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; n \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; m \u0026amp;\u0026amp; matrix[nx][ny] \u0026lt; z) dp[x][y] = max(dp[x][y], dp[nx][ny] + 1); } } int res = INT_MIN; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { res = max(res, dp[i][j]); } } return res; } }; 该题更推荐使用记忆化搜索的解法。\n路径问题 ","permalink":"https://kdjlyy.github.io/posts/algorithm/algorithm-dp/","summary":"动态规划, dp, 记忆化搜索, 滑雪， 矩阵中的最长递增路径","title":"动态规划专题"},{"content":"差分数组 差分数组本质上来说就是一个数组，可以用 $O(1)$ 的时间处理区间修改。\n设原数组为 $a$ 数组，差分数组为 $d$ 数组，则对于 $i\\in[2,n]$，都有 $d[i]=a[i]-a[i-1]$。\n性质：\n更新区间 $[l, r]$ 时（区间加减运算），我们可以只更新 $d[l] += x, \\quad d[r+1] -= x$ 查询原数组 $a[i]$ 时，令 $S_n$ 为 $d[i]$ 的前缀和，那么 $a[i]=S[i]$ 求原数组 $a[i]$ 的前缀和时，设前 $x$ 项的前缀和为 $sum_x$，则有：$$sum_x=\\sum_{i=1}^{x}a[i]=\\sum_{i=1}^{x}\\sum_{j=1}^{i}d[j]=\\sum_{i=1}^{x}(x-i+1)d[i]$$ 例题 例1：Leetcode 2406. 将区间分为最少组数\n[解析]：对于所有 intervals 区间组来说，如果有重叠我们将其分开，枚举所有的区间组，最高的重叠次数就是答案。从前往后枚举，用差分数组记录对应每个区间的计数，最后通过前缀和计算所有区间的最大计数即可（差分数组的前缀和 $Sum_d[i]$ 即为位置 $i$ 的重叠次数）。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int minGroups(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { // 用 map 记录，防止a[i]的数组过大超内存 // 不能用 unordered_map，因为我们统计时从小到大统计 map\u0026lt;int, int\u0026gt; d; for (auto i : intervals) { d[i[0]]++; d[i[1]+1]--; } int res = 0, sum = 0; for (auto [_, v] : d) { res = max(res, sum += v); } return res; } }; 并查集 并查集主要用于解决一些元素分组的问题。它管理一系列不相交的集合，并支持两种操作：\n合并（Union）：把两个不相交的集合合并为一个集合。 查询（Find）：查询两个元素是否在同一个集合中。 进行多次合并和查询操作之后，根节点的个数即为集合的数量（fa[i] == i ）。\n朴素的并查集 1 2 3 4 5 6 7 8 9 10 11 12 const int MAXN = 1e5+10; int fa[MAXN]; void init(int n) { for (int i = 1; i \u0026lt;= n; i++) fa[i] = i; } int _find(int x) { return x == fa[x]? x: (fa[x] = _find(fa[x])); // 路径压缩（注意赋值运算符 = 的优先级没有三元运算符 ?: 高，这里要加括号） } void merge(int i, int j) { int x = _find(i), y = _find(j); fa[y] = x; } “优化后”的并查集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const int MAXN = 1e5+10; int fa[MAXN]， rk[MAXN]; void init(int n) { for (int i = 1; i \u0026lt;= n; i++) fa[i] = i, rk[i] = 1; } int _find(int x) { return x == fa[x]? x: (fa[x] = _find(fa[x])); // 路径压缩 } void merge(int i, int j) { int x = _find(i), y = _find(j); if (rk[x] \u0026lt;= rk[y]) fa[x] = y; // 按秩合并 else fa[y] = x; if (rk[x] == rk[y] \u0026amp;\u0026amp; x != y) rk[y]++; // 如果深度相同且根节点不同，则新的根节点的深度+1 } 注：优化后的并查集在合并时先调用_find进行了路径压缩，改变了树的秩，实际上路径压缩和按秩合并可以混用（不过此时秩失去了“子树高度”这个意义，但他的一些性质还是保留了下来）。不过大部分情况下按秩合并是一种负优化, 因为调整的代价过大，所以一般情况下推荐使用朴素的并查集。\n例题 例1：Leetcode 剑指 Offer II 116. 省份数量\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int fa[205]; void init(int n) { for (int i = 1; i \u0026lt;= n; i++) fa[i] = i; } int _find(int x) { return x==fa[x]? x: (fa[x] = _find(fa[x])); } void merge(int i, int j) { int x = _find(i), y = _find(j); fa[y] = x; } int findCircleNum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; isConnected) { int n = isConnected.size(); init(n); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (isConnected[i][j]) merge(i+1, j+1); } } int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { if (fa[i] == i) ++cnt; } return cnt; } }; 例2：Leetcode 剑指 Offer II 118. 多余的边\n[解析]：并查集查找第一个能形成环的边（加入该边会导致成环）。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int fa[1005]; void init(int n) { for (int i = 1; i \u0026lt;= n; i++) fa[i] = i; } int _find(int x) { return x==fa[x]? x: (fa[x] = _find(fa[x])); } void merge(int i, int j) { int x = _find(i), y = _find(j); fa[y] = x; } vector\u0026lt;int\u0026gt; findRedundantConnection(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { int n = edges.size(); init(n); for (auto v : edges) { if (_find(v[0]) != _find(v[1])) merge(v[0], v[1]); else return v; } return vector\u0026lt;int\u0026gt;{}; } }; 例3：Leetcode 1631. 最小体力消耗路径\n[解析]：该题有多种解法，例如 DFS + 二分，Dijkstra 算法等，这里介绍使用并查集的思路。首先题目允许往任意方向移动，大概率排除 DP 的可能，从图论的方向思考：\n先把这张图存起来：边为所有上下左右相邻的顶点构成，边权是相邻顶点之间的高度差；\n假设整张图 m*n 个节点最开始都是孤立点，需要添加一条条的边，使得各个顶点相连，直到起点和终点在同一个集合中，路径就结束了；\n体力消耗值是路径上相邻节点高度差中的最大值，我们一直向整张图中添加权值最小的边，就算添加进来的这条边，在最后的路径中用不到，它也不会让当前图中的路径体力消耗值变得更多。直到加上某条边时候，起点和终点处于同一个集合下，那么路径就找到了。又因为咱们是从最小高度差的边一个个添加进来的，所以最后加进来的这条边的权值就是题目要的最小消耗的体力值。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public: int fa[10002]; void init(int n) { for (int i = 0; i \u0026lt; n; i++) fa[i] = i; } int _find(int x) { return (x == fa[x])? x: (fa[x] = _find(fa[x])); } void merge(int i, int j) { int x = _find(i), y = _find(j); fa[y] = x; } vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; G; int minimumEffortPath(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; heights) { int n = heights.size(), m = heights[0].size(); // 建图 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { int id = i * m + j; if (i \u0026gt; 0) G.emplace_back(id-m, id, abs(heights[i-1][j] - heights[i][j])); if (j \u0026gt; 0) G.emplace_back(id-1, id, abs(heights[i][j-1] - heights[i][j])); } } // 按权值从小到大排序 sort(G.begin(), G.end(), [](const auto\u0026amp; t1, const auto\u0026amp; t2){ auto\u0026amp;\u0026amp; [x1, y1, w1] = t1; auto\u0026amp;\u0026amp; [x2, y2, w2] = t2; return w1 \u0026lt; w2; }); init(m*n); int res = 0; for (auto [x, y, w] : G) { if (_find(0) == _find(m * n - 1)) break; res = w; merge(x, y); } return res; } }; 拓扑排序 拓扑排序（Topological sort）是在 DAG（Directed Acyclic Graph, 有向无环图）上找到一个可以执行的线性顺序。图上存在拓扑序列与图是 DAG 之间形成充分必要条件。\n拓扑排序 一种比较常用的拓扑排序方法：\n从 DAG 中选择一个没有前驱（即入度为0）的顶点并输出； 从图中删除该顶点和所有以它为起点的有向边； 重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。 对应的算法步骤为：\n每次从入度为 0 的结点开始，加入队列。入度为 0 ，表示没有前置结点； 处理入度为 0 的结点，把这个结点指向的结点的入度 -1； 重复 1 和 2，如果队列都处理完毕，但是和总结点数不符，说明有些结点形成环。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* M = {{0,1}, {0,3}, {1,3}, {1,2}, {3,2}, {3,4}, {2,4}} 0 → 3 ↘︎ ↓ ↗ ↓ 4 1 → 2 ↗ n = 5 表示编号 0-4 共 5 个结点 */ vector\u0026lt;int\u0026gt; topologicSort(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; M, int n) { vector\u0026lt;int\u0026gt; inDegree(n, 0); // 结点入度 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G(n, vector\u0026lt;int\u0026gt;()); // 存储图 G[a] = {x, y} 表示 a-\u0026gt;x, a-\u0026gt;y queue\u0026lt;int\u0026gt; q; // 存储入度为 0 的结点 vector\u0026lt;int\u0026gt; res; // 存储图和节点入度 for (auto v : M) { G[v[0]].emplace_back(v[1]); inDegree[v[1]]++; } // 入度为0的结点入队 for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) q.push(i); } // 处理入度为 0 的结点，把这个结点指向的结点的入度 -1 while(!q.empty()) { int st = q.front(); q.pop(); res.emplace_back(st); for (auto to : G[st]) { if(--inDegree[to] == 0) q.push(to); } } return (res.size() == n)? res: vector\u0026lt;int\u0026gt;{}; } 例题 例1：Leetcode 210. 课程表 II\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: vector\u0026lt;int\u0026gt; findOrder(int numCourses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { vector\u0026lt;int\u0026gt; inDegree(numCourses, 0); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G(numCourses, vector\u0026lt;int\u0026gt;()); for (auto v : prerequisites) { inDegree[v[0]]++; G[v[1]].emplace_back(v[0]); } queue\u0026lt;int\u0026gt; q; for (int i = 0; i \u0026lt; numCourses; i++) { if (inDegree[i] == 0) q.push(i); } vector\u0026lt;int\u0026gt; res; while(!q.empty()) { int node = q.front(); q.pop(); res.emplace_back(node); for (auto i : G[node]) { if (--inDegree[i] == 0) q.push(i); } } return (res.size() == numCourses)? res: vector\u0026lt;int\u0026gt;(); } }; Dijkstra算法 Dijkstra 算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径，即图的单源最短路径问题。它的主要特点是以起点为中心向外层层扩展（广度优先遍历思想），直到扩展到终点为止。\nDijkstra 算法时间复杂度为 $O(n^2)$，使用优先队列优化的 Dijkstra 算法时间复杂度可降低至 $O((m+n)\\thinspace log\\thinspace n)$，其中 $n=|V|$，$m=|E|$。\n需要注意的是 Dijkstra 算法适用于有环图，但不能有效处理带负权边的图，如果边权是负数情况，则应该试用 Bellman-Ford 算法和 SPFA 算法。\n算法思想：\nDijkstra 算法流程 在一个图中，把所有顶点分为两个集合 $P$，$Q$（$P$ 为最短路径集合，$Q$ 为待选集合），用 $dis$ 数组保存源点到各个顶点的最短路径（到自身为0）； 初始化 $P$ 集合，就是加入源点到该集合，并在 $vis$ 数组标记（代码中的 vis[st] = 1），那么 $Q$ 集合就是剩下的顶点构成了； 在 $Q$ 集合中找到这样一个顶点：源点到该顶点（记为 $curr$）的路径最短，把该点加入 $P$ 集合，列出以 $curr$ 为起点的所有边（终点记为 $t$），判断从源点到每一个 $t$ 顶点（因为以 $curr$ 为起点的边有多个）经过 $curr$ 顶点的路径是否会变小，更新 $dis[t]$ 的值； 重复步骤3，直到 $Q$ 集合为空，算法结束，此时 $dis$ 数组就存储了从源点到各个顶点的最短路径。 Dijkstra算法模版 代码 O(n^2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // n个结点 m条有向边 源点st // vis[i] = true/false 表示在 P/Q 集合 // dis[i] 保存了从源点到其他点的距离 int n, m, st; bool vis[105]; int e[105][105], dis[105]; void dijkstra(int st) { // 初始化dis数组 memset(dis, 0x3f, sizeof(dis)); dis[st] = 0; for (int i = 1; i \u0026lt;= n; i++) { // loop n rounds int curr = -1, minDis = 0x3f3f3f3f; for (int j = 1; j \u0026lt;= n; j++) { // 找到未访问的最小距离 if (!vis[j] \u0026amp;\u0026amp; dis[j] \u0026lt; minDis) { minDis = dis[j]; curr = j; } } if (curr == -1) break; vis[curr] = true; for (int t = 1; t \u0026lt;= n; t++) if (!vis[t]) dis[t] = min(dis[t], dis[curr] + e[curr][t]); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; st; int x, y, cost; // 初始化图结构 for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (i == j) e[i][j] = 0; else e[i][j] = 0x3f3f3f3f; } } // 输入并构建邻接矩阵 for (int i = 0; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; cost; e[x][y] = cost; } dijkstra(st); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; dis[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } /* 6 9 1 1 2 1 1 3 12 2 3 9 2 4 3 3 5 5 4 3 4 4 5 13 4 6 15 5 6 4 */ 优先队列优化的Dijkstra算法 使用优先队列（小根堆）维护，能在 $O(1)$ 时间内找到未访问的最小距离（curr_w）和对应的结点（curr）。\n代码 O((n\u0026#43;m) log n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct edge{ int to, w; // 结点编号 源点到该结点的最短距离 edge(int _to, int _w): to(_to), w(_w) {} // 运算符重载 让priority_queue\u0026lt;edge\u0026gt;为小顶堆 bool operator \u0026lt; (const edge\u0026amp; x) const { return w \u0026gt; x.w; } }; // n个结点 m条有向边 源点st // vis[i] = true/false 表示在 P/Q 集合 // dis[i] 保存了从源点到其他点的距离 // 优先队列维护的是Q集合，可以在O(1)时间内找到未访问的最小距离 int n, m, st, dis[105]; bool vis[105]; vector\u0026lt;edge\u0026gt; G[105]; priority_queue\u0026lt;edge\u0026gt; q; void dijkstra(int st){ // 初始化dis数组 memset(dis, 0x3f, sizeof(dis)); dis[st] = 0; q.emplace(st, 0); // 初始源点在Q集合，从st到st的最短距离为0 while(!q.empty()) { auto [curr, curr_w] = q.top(); q.pop(); if(vis[curr]) continue; // P集合已经扩散过了 vis[curr] = true; for (auto [t, t_w] : G[curr]) { if (dis[t] \u0026gt; dis[curr] + t_w) { dis[t] = dis[curr] + t_w; q.emplace(t, dis[t]); // 加入P集合 } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; st; int x, y, cost; for (int i = 0; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; cost; G[x].emplace_back(y, cost); } dijkstra(st); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; dis[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } 例题 例1：Leetcode 743. 网络延迟时间\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: typedef pair\u0026lt;int, int\u0026gt; PII; vector\u0026lt;PII\u0026gt; G[102]; bool vis[102]; int dis[102]; priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, greater\u0026lt;PII\u0026gt;\u0026gt; q; void dijkstra(int st) { // init dis[] memset(dis, 0x3f, sizeof(dis)); dis[st] = 0; q.emplace(0, st); // 注意这里的顺序是(距离, 结点编号) while(!q.empty()) { auto [curr_w, curr] = q.top(); q.pop(); if (vis[curr]) continue; vis[curr] = true; for (auto [t, t_w] : G[curr]) { if (dis[curr] + t_w \u0026lt; dis[t]) { dis[t] = dis[curr] + t_w; q.emplace(dis[t], t); } } } } int networkDelayTime(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; times, int n, int k) { for (auto v : times) G[v[0]].emplace_back(make_pair(v[1], v[2])); dijkstra(k); int res = 0; return ((res = *max_element(dis+1, dis+n+1)) == 0x3f3f3f3f)? -1: res; } }; 例2：LeetCode 1334. 阈值距离内邻居最少的城市\n[解析]：建双向图，跑 n 遍 Dijkstra 算法。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public: typedef pair\u0026lt;int, int\u0026gt; PII; vector\u0026lt;PII\u0026gt; G[102]; int dis[102][102]; // dis[i][] 表示源点为 i 的 dis 数组 bool vis[102]; void dijkstra(int st) { priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, greater\u0026lt;PII\u0026gt;\u0026gt; q; memset(vis, 0, sizeof(vis)); memset(dis[st], 0x3f, 102 * sizeof(int)); dis[st][st] = 0; q.emplace(0, st); while (!q.empty()) { auto [curr_w, curr] = q.top(); q.pop(); if (vis[curr]) continue; vis[curr] = true; for (auto [t, t_w] : G[curr]) { if (dis[st][t] \u0026gt; dis[st][curr] + t_w) { dis[st][t] = dis[st][curr] + t_w; q.emplace(dis[st][t], t); } } } } // 从 city_i 出发，路径距离小于等于 distanceThreshold 的城市数量 int cityCount(int i, int n, int distanceThreshold) { int res = 0; for (int j = 0; j \u0026lt; n; j++) { if (dis[i][j] \u0026lt;= distanceThreshold) ++res; } return res - 1; } int findTheCity(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int distanceThreshold) { for (auto v : edges) { G[v[0]].emplace_back(make_pair(v[1], v[2])); G[v[1]].emplace_back(make_pair(v[0], v[2])); } int res = 0, cnt = INT_MAX; for (int i = 0; i \u0026lt; n; i++) { dijkstra(i); if (cityCount(i, n, distanceThreshold) \u0026lt;= cnt) { cnt = cityCount(i, n, distanceThreshold); res = i; } } return res; } }; 例3：Leetcode 1786. 从第一个节点出发到最后一个节点的受限路径数\n[解析]：优化的 Dijkstra 算法 + 动态规划。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public: vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; G[20002]; priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; q; bool vis[20005]; int dis[20005]; void dijkstra(int st) { memset(dis, 0x7f, sizeof(dis)); dis[st] = 0; q.emplace(make_pair(0, st)); while(!q.empty()) { auto [curr_w, curr] = q.top(); q.pop(); if (vis[curr]) continue; vis[curr] = true; for (auto [t, t_w] : G[curr]) { if (dis[t] \u0026gt; dis[curr] + t_w) { dis[t] = dis[curr] + t_w; q.emplace(make_pair(dis[t], t)); } } } } int countRestrictedPaths(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { for (auto e : edges) { G[e[0]].emplace_back(make_pair(e[1], e[2])); G[e[1]].emplace_back(make_pair(e[0], e[2])); } dijkstra(n); vector\u0026lt;long long\u0026gt; dp(n + 1, 0); dp[n] = 1LL; // 构建索引数组，按照dis从小到大排列 vector\u0026lt;int\u0026gt; idx(n+1); for (int i = 1; i \u0026lt;= n; i++) idx[i] = i; sort(idx.begin(), idx.end(), [\u0026amp;](const int i, const int j) { return dis[i] \u0026lt; dis[j]; }); for (int i : idx) { for (auto [to, w] : G[i]) { if (dis[i] \u0026gt; dis[to]) { dp[i] += dp[to]; dp[i] %= 1000000007; } } if (i == 1) break; // 剪枝，比1的距离还大的点，最短路径一定不会经过他们，不用考虑 } return dp[1]; return 0; } }; 单调栈 单调队列 最长上升子序列（LIS） ","permalink":"https://kdjlyy.github.io/posts/algorithm/algorithm-template/","summary":"算法, 差分数组, 并查集, 拓扑排序, Dijkstra, 点面关系, 判断点是否在三角形内, 最小生成树, kruskal, 排列数, 组合数, 最长上升子序列, LIS, 最长公共子序列, LCS, 编辑距离","title":"常用算法模版"},{"content":"set set 容器的功用就是维护一个集合，其中的元素默认升序排列。其底层由红黑树实现，insert、erase、find 操作的时间复杂度均为$O(logN)$。\n自定义从大到小排序 1 2 3 4 set\u0026lt;int, greater\u0026lt;\u0026gt;\u0026gt; st; // 或者 auto func = [](const int\u0026amp; x, const int\u0026amp; y) { return x \u0026gt; y; }; set\u0026lt;int, decltype(func)\u0026gt; st(func); map map 容器存储的都是 pair 对象，该容器会自动根据各键值对的键的大小，默认选用std::less\u0026lt;T\u0026gt;排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。其底层由红黑树实现。\n自定义从大到小排序 1 2 3 4 map\u0026lt;int, int, greater\u0026lt;\u0026gt;\u0026gt; mp; // 或者 auto func = [](const int\u0026amp; x, const int\u0026amp; y) { return x \u0026gt; y; }; map\u0026lt;int, int, decltype(func)\u0026gt; mp(func); priority_queue 在优先队列中，优先级高的元素先出队列，并非按照先进先出的要求，类似一个堆。优先队列默认大根堆，重载方式与 sort、set、map 相反。\nvector转priority_queue 1 2 3 vector\u0026lt;int\u0026gt; nums = {3, 4, 1, 2, 5}; // vector快速建立大根堆 priority_queue\u0026lt;int\u0026gt; q(less\u0026lt;int\u0026gt;(), move(nums)); 建立小根堆 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 方法1 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; q; // 方法2 auto func = [](const int\u0026amp; x, const int\u0026amp; y) { return x \u0026lt; y; }; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, decltype(func)\u0026gt; q(func); // 方法3 struct edge{ int to, w; edge(int _to, int _w): to(_to), w(_w) {} // 运算符重载 让priority_queue\u0026lt;edge\u0026gt;为小顶堆 bool operator \u0026lt; (const edge\u0026amp; x) const { return w \u0026gt; x.w; } }; erase和remove erase 1 2 iterator erase(iterator position); iterator erase(iterator first, iterator last); erase()函数可以用于删除 vector 容器（或 string）中的一个或者一段元素，在删除一个元素的时候，其参数为指向相应元素的迭代器，而在删除一段元素的时候，参数为指向一段元素的开头的迭代器以及指向结尾元素的下一个元素的迭代器。\n在进行单个元素删除后，传入的迭代器指向不变，仍然指向被删除元素的位置，而被删除元素之后的所有元素都向前移动一位，也就是该迭代器实际上是指向了原来被删除元素的下一个元素。\nremove 1 iterator remove(iterator first, iterator last, val); remove()的作用是将等于 val 的元素放到 vector（或 string）的尾部，但并不减少 vector 的 size。执行 remove 之后返回新的 end() 迭代器，但是不改变原来数组的 end() 迭代器的值。也就是数组中新的 end() 至原 end() 范围内的值是原数组中等于 val 的值，但是这部分状态不可靠。begin() 到新的 end() 这部分是不等于 val 的值。\n区别 也就是说 erase 和 remove 的区别在于执行函数之后返回值不同，被执行的 vector 的大小会不会改变。\nvector 中 erase 的作用是删除掉某个位置或一段区域中的元素，减少其 size，返回被删除元素下一个元素的位置。\nvector 中 remove 的作用是将范围内为 val 的值都 remove 到后面，返回新的 end() 值（非 val 部分的end）,但传入的原 vector 的 end 并没有发生改变，因此 size 也就没有变化。\n所以说remove()不是真正的删除，而是移除。erase()结合remove()能做到删除一段范围内的某个元素。\n1 2 3 4 5 // 删除vector中值为x的元素 vec.erase(remove(vec.begin(), vec.end(), x), vec.end()); // 删除string中所有的\u0026#39;_\u0026#39; s.erase(remove(s.begin(), s.end(), \u0026#39;_\u0026#39;), s.end()); 图的存储方式 常用的图的存储方式很多，例如邻接矩阵、邻接链表、链式前向星等，兼顾性能和效率，一般使用的最多的是邻接链表。\n不需要保存权值 当不需要保存边的权值信息（或每条边的权值固定）时，直接使用二维 vector 即可（假设有10000个结点，编号从1到10000）：\n1 2 3 4 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G(10002, vector\u0026lt;int\u0026gt;()); G[i].emplace_back(j); // 表示有一条 i→j 的边 G[i].size();\t// 表示结点 i 的出度 使用 pair 使用 pair 能很方便地保存边的权值。\n1 2 3 4 typedef pair\u0026lt;int, int\u0026gt; PII; vector\u0026lt;PII\u0026gt; G[10002]; G[i].emplace_back(make_pair(j, 100)); // 表示有一条 i→j 的边，权值为100 需要进行排序的情况 有时候需要按边权对结点进行排序，这时候我们可以使用以下存储结构：\n1 2 3 4 5 6 7 8 9 struct edge{ int s, t, cost; edge(int _s, int _t, int _cost): s(_s), t(_t), cost(_cost) {} bool operator \u0026lt; (const edge\u0026amp; o) const { return cost \u0026lt; o.cost; } }; vector\u0026lt;edge\u0026gt; G; G.emplace_back(edge(i, j, 100)); //表示有一条 i→j 的边，权值为100 sort(G.begin(), G.end()); 或者使用 tuple\u0026lt;int, int, int\u0026gt;：\n1 2 3 4 5 6 7 8 9 vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; edges; // 结点i 结点j 权值 edges.emplace_back(make_tuple(i, j, 100)); // 表示有一条 i→j 的边，权值为100 // 按权值从小到大排序 sort(edges.begin(), edges.end(), [](const auto\u0026amp; e1, const auto\u0026amp; e2) { auto\u0026amp;\u0026amp; [x1, y1, v1] = e1; auto\u0026amp;\u0026amp; [x2, y2, v2] = e2; return v1 \u0026lt; v2; }); __builtin系列 以 __builtin 开头的函数，是一种相当神奇的位运算函数，熟练运用此类函数可以方便解决位运算相关问题。\n__builtin_ctz(x)和__buitlin_clz(x) __builtin_ctz(x)返回 x 的二进制表示数末尾 0 的个数；\n__builtin_clz(x)返回 x 的二进制表示数前导 0 的个数。\n对应的 64 位长整型版本分别为：__builtin_ctzll(x)和__builtin_clzll(x)\n1 2 3 4 5 cout \u0026lt;\u0026lt; __builtin_ctz(128) \u0026lt;\u0026lt; endl; // 7 cout \u0026lt;\u0026lt; __builtin_ctz(128) \u0026lt;\u0026lt; endl; // 24 cout \u0026lt;\u0026lt; __builtin_ctzll(1024L) \u0026lt;\u0026lt; endl; // 10 cout \u0026lt;\u0026lt; __builtin_clzll(1024L) \u0026lt;\u0026lt; endl; // 53 __builtin_popcount(x) 返回 x 的二进制表示数 1 的个数。\n1 cout \u0026lt;\u0026lt; __builtin_popcount(15) \u0026lt;\u0026lt; endl; // 4 __builtin_parity(x) 判断 x 的二进制表示数 1 的个数的奇偶性(偶数返回 0，奇数返回 1)。\n1 2 cout \u0026lt;\u0026lt; __builtin_parity(14) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; __builtin_parity(15) \u0026lt;\u0026lt; endl; // 0 __builtin_ffs(x) 返回 x 的二进制表示数的最后一个 1 在第几位（从后往前算）。\n1 2 3 cout \u0026lt;\u0026lt; __builtin_ffs(1024) \u0026lt;\u0026lt; endl; // 11 cout \u0026lt;\u0026lt; __builtin_ffs(6) \u0026lt;\u0026lt; endl; // 2 cout \u0026lt;\u0026lt; __builtin_ffs(0) \u0026lt;\u0026lt; endl; // 0 ","permalink":"https://kdjlyy.github.io/posts/algorithm/stl-basic/","summary":"STL, set, map, priority_queue","title":"常用STL技巧"},{"content":"LXC简介 LXC 是 Linux 容器（Linux Containers）的简称，是 Linux 内核提供的一种虚拟化技术。它允许在 Linux 操作系统上创建和管理多个独立的容器。每个 LXC 容器都是一个轻量级的虚拟化环境，类似于传统虚拟机（如 VMware 或 VirtualBox），但更加轻巧和高效。\nLXC利用Linux内核中的诸多特性，如 cgroups（控制组）、命名空间（namespace）和 chroot（更改根目录），来实现容器的隔离和资源管理。每个 LXC 容器都可以拥有自己的文件系统、进程空间、网络和用户空间，使其能够在同一物理主机上运行多个相互隔离的应用程序或服务。\nLXC 容器与传统虚拟机相比，具有以下优势：\n轻量级：LXC 容器共享宿主机的操作系统内核，因此相比于传统虚拟机，它们占用更少的系统资源。 快速启动：由于不需要启动完整的操作系统内核，LXC 容器的启动速度通常更快。 高效性能：LXC 容器在与宿主机共享内核的情况下，能够更高效地利用系统资源，提供更好的性能。 灵活性：LXC 容器提供了更灵活的配置选项，可以定制容器的资源限制、网络设置和文件系统等。 LXC 是开源项目1，已经成为 Linux 系统中广泛使用的容器技术之一。它的成功启发了其他容器技术的发展，例如，早期 Docker 就是建立在 LXC 的基础上2。\nDocker简介 Docker 是一个开源的应用容器引擎，基于 go 语言开发，可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 服务器。容器是一个沙箱机制，相互之间不会有影响（类似于我们手机上运行的 app），并且容器开销是很低的。\nDocker 容器的特点有：\n轻量化：同一台机器上运行的 Docker 容器共享该机器的操作系统内核； 跨平台：Docker 能够在所有主流 Linux 版本、Windows 以及包括 VM、裸机服务器和云在内的任何基础设施上运行，这种兼容性决定了 Docker 容器易于迁移和部署的特点，从而提高开发效率和减少部署的工作量； 系统资源利用率高：容器除了运行其中应用外，基本不消耗额外的系统资源； 安全可靠：应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施，因此应用出现问题，也只是单个容器的问题，而不会波及到整台主机； 简单易用：Docker 提供了方便的命令行工具和图形界面，使开发和运维人员可以快速创建、测试和部署容器。 作为一种新兴的虚拟化方式，Docker 容器能够提升交付和部署效率，并大大减少了部署过程中的潜在风险。\nLXC 和 Docker 的区别 Docker 将应用的所有配置打包到一个容器中，具有可移植性，LXC 仅仅实现了进程沙盒化，并不能在不同机器上进行移植； Docker 针对应用的API、用户接口、设计原理及文档上面部署做了优化，而 LXC 仅关注容器并没有过多的优化。 注解 LXC 简介：https://linuxcontainers.org/lxc/introduction/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDocker 原本的底层技术是 LXC（Linux Containers），但自从 Docker 0.9 版本之后就移除了对 LXC 的依赖，转而采用自己开发的 libcontainer 作为默认的容器运行时库。因此，现在的 Docker 并不依赖 LXC。不过，LXC 仍然可以作为 Docker 运行时的后端，可以通过配置来设置 Docker 使用 LXC 作为容器运行时。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://kdjlyy.github.io/posts/tech/docker-basic/","summary":"Docker基础","title":"Docker基础"},{"content":"Shortcodes简介 大多数的静态博客会使用 Markdown 进行写作，因为它格式简单、所见即所得，但是 Markdown 也有它的不足之处。当我们想要将图片或者视频等插入到文章内容中时，Markdown 本身并不能提供很好的支持，因此不得不将一些 HTML 片段加入到 Markdown 内容中。尽管在一些简单的场景中这样做能够解决问题，但是却破坏了 Markdown 文件的简洁性质。另外如果想对一些内容进行装饰也变得非常麻烦，而且不能起到复用的效果。为此，Hugo 引入了 shortcodes，允许我们在 Markdown 文件中以一种简洁的形式书写 HTML。\n这种方式可以理解为“模版的模版”，Hugo 框架的模版会解析我们自定义的 shortcodes 模版，生成对应的 HTML 代码。本人博客的 shortcodes 使用方式参考该博文的第7节：\nPaperMod主题Markdown示例 日期: 2023-05-08 \u0026nbsp; 标签: #教程\u0026nbsp; #markdown\u0026nbsp; #Hugo\u0026nbsp; #PaperMod\u0026nbsp; 主要展示 PaperMod 主题中 Markdown 语法的页面效果 ...... 在线PPT/PDF 新建themes/PaperMod/layouts/shortcodes/ppt.html，输入以下内容：\n1 2 3 4 5 {{ $src := .Get \u0026#34;src\u0026#34; }} \u0026lt;iframe src=\u0026#34;{{ $src }}\u0026#34; marginwidth=\u0026#34;0\u0026#34; marginheight=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34; style=\u0026#34;border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px\u0026#34; allowfullscreen=\u0026#34;\u0026#34; webkitallowfullscreen=\u0026#34;\u0026#34; mozallowfullscreen=\u0026#34;\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;600\u0026#34; frameborder=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 在线Bilibili视频 新建themes/PaperMod/layouts/shortcodes/bilibili.html，输入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .bilibili_shortcodes { position: relative; width: 100%; height: 0; padding-bottom: 66%; margin: auto; overflow: hidden; text-align: center; } .bilibili_shortcodes iframe { position: absolute; width: 100%; height: 100%; left: 0; top: 0; } \u0026lt;/style\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;bilibili_shortcodes\u0026#34;\u0026gt; \u0026lt;iframe src=\u0026#34;https://player.bilibili.com/player.html?bvid={{.Get 0 }}\u0026amp;page={{ if .Get 1 }}{{.Get 1}}{{ else }}1\u0026amp;high_quality=1\u0026amp;danmaku=0\u0026amp;as_wide=0{{end}}\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 博客文章内链 新建themes/PaperMod/layouts/shortcodes/innerlink.html，输入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;div style=\u0026#34;height: 150px;margin: 1em auto;position: relative; box-shadow: 0 2px 4px rgb(0 0 0 / 25%), 0 0 2px rgb(0 0 0 / 25%); border-radius: 15px;padding: 23px;max-width: 780px;background: var(--entry);\u0026#34;\u0026gt; {{ $url := .Get \u0026#34;src\u0026#34; }} {{ with .Site.GetPage $url }} \u0026lt;div style=\u0026#34;font-size: 22px; font-weight: 600\u0026#34;\u0026gt; \u0026lt;a target=\u0026#34;_blank\u0026#34; href=\u0026#34;{{ .Permalink }}\u0026#34; style=\u0026#34;box-shadow: none\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;span style=\u0026#34;font-size: 14px; color: #999\u0026#34;\u0026gt; 日期: {{ .Date.Format ( default \u0026#34;2006-01-02\u0026#34;) }} {{ if .Params.tags }}\u0026amp;nbsp; 标签: {{ range .Params.tags }} #{{ . }}\u0026amp;nbsp; {{ end }} \u0026lt;/span\u0026gt; \u0026lt;div style=\u0026#34;font-size: 14px; line-height: 1.825;max-height: 75px; overflow: hidden;margin-top: 5px;\u0026#34;\u0026gt; {{ .Summary | plainify}} ...... \u0026lt;/div\u0026gt; {{ end }} {{ end }} \u0026lt;/div\u0026gt; 代码折叠 新建themes/PaperMod/layouts/shortcodes/code.html，输入以下内容：\n1 2 3 4 5 6 7 8 9 {{ $_hugo_config := `{ \u0026#34;version\u0026#34;: 1 }` }} \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt; \u0026lt;!-- \u0026lt;span style=\u0026#34;background-color:rgb(255, 255, 255);\u0026#34;\u0026gt;\u0026lt;b\u0026gt; 代码 🔍\u0026lt;/b\u0026gt;\u0026lt;/span\u0026gt; --\u0026gt; \u0026lt;b\u0026gt; 代码 \u0026lt;/b\u0026gt; \u0026lt;/summary\u0026gt; {{.Inner}} \u0026lt;/details\u0026gt; Github卡片 新建themes/PaperMod/layouts/shortcodes/github.html，输入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 {{ $title := .Get \u0026#34;title\u0026#34; }} \u0026lt;!-- {{ $detail := .Get \u0026#34;detail\u0026#34; }} --\u0026gt; \u0026lt;article class=\u0026#34;shortcode-card\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://github.com/{{ $title }}\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;img alt=\u0026#34;{{ $title }}\u0026#34; src=\u0026#34;https://opengraph.githubassets.com/1/{{ $title }}\u0026#34; width=\u0026#34;50%\u0026#34; height=\u0026#34;50%\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;!-- \u0026lt;div class=\u0026#34;shortcode-card-content\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{ .Get \u0026#34;title\u0026#34; }}\u0026lt;/h2\u0026gt; {{ with $detail }} \u0026lt;p\u0026gt;{{ . }}\u0026lt;/p\u0026gt; {{ end }} \u0026lt;span\u0026gt;github.com\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/article\u0026gt; 更多内容参考：Hugo Shortcodes 示例、Shortcodes、Hugo博客自定义shortcodes\n","permalink":"https://kdjlyy.github.io/posts/site/hugo_shortcodes/","summary":"Shortcodes简介 大多数的静态博客会使用 Markdown 进行写作，因为它格式简单、所见即所得，但是 Markdown 也有它的不足之处。当我们想要将图片或者视频等插入到文章内容中时，Markdown 本身并不","title":"Hugo博客shortcodes使用"},{"content":"准备工作 基于 Hugo 搭建的静态博客网页代码托管在 Github 上，我们可以直接使用 Github 的地址访问。但是为了提高加载速度，我们也可以选择将博客部署到各大厂商的云服务器上。\n在此之前，需要完成包括但不限于以下准备工作：\n购买云服务器； 购买域名； 域名解析和 ICP 备案; 防火墙/安全组设置。 安装宝塔面板 该步骤不是必选项，但是为了方便后续使用，建议安装宝塔面板，安装后可以使用图形化界面操作云服务器。\n参考链接：宝塔面板安装教程\n安装SSL证书 该步骤不是必选项，但是安装 SSL 证书后我们的博客网站支持 https 访问，推荐安装。\n一般我们购买的阿里云/腾讯云等平台的服务器，都可以使用免费的 SSL 证书。证书的有效期一般为一年，到期时可以提前免费续约。以阿里云为例，参考教程：在Nginx或Tengine服务器上安装证书。\n配置Nginx 在步骤2中，我们安装宝塔面板的同时一般已经安装了 Nginx，输入nginx -v查看。\n输入ps -ef | grep nginx可以查看正在运行的 Nginx 进程，我们可以看到宝塔面板安装的 Nginx 配置文件是：/www/server/nginx/conf/nginx.conf，个人配置如下：\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 user www www; worker_processes auto; error_log /www/wwwlogs/nginx_error.log crit; pid /www/server/nginx/logs/nginx.pid; worker_rlimit_nofile 51200; stream { log_format tcp_format \u0026#39;$time_local|$remote_addr|$protocol|$status|$bytes_sent|$bytes_received|$session_time|$upstream_addr|$upstream_bytes_sent|$upstream_bytes_received|$upstream_connect_time\u0026#39;; access_log /www/wwwlogs/tcp-access.log tcp_format; error_log /www/wwwlogs/tcp-error.log; include /www/server/panel/vhost/nginx/tcp/*.conf; } events { use epoll; worker_connections 51200; multi_accept on; } http { include mime.types; include proxy.conf; default_type application/octet-stream; server_names_hash_bucket_size 512; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 50m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 256k; fastcgi_intercept_errors on; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.1; gzip_comp_level 2; gzip_types text/plain application/javascript application/x-javascript text/javascript text/css application/xml; gzip_vary on; gzip_proxied expired no-cache no-store private auth; gzip_disable \u0026#34;MSIE [1-6]\\.\u0026#34;; limit_conn_zone $binary_remote_addr zone=perip:10m; limit_conn_zone $server_name zone=perserver:10m; server_tokens off; access_log off; server { listen 443 ssl; server_name kdjlyy.cn; root html; index index.html index.htm index.php; #填写证书文件名称 ssl_certificate cert/xxxxxxx_kdjlyy.cn.pem; #填写证书私钥文件名称 ssl_certificate_key cert/xxxxxxx_kdjlyy.cn.key; ssl_session_timeout 5m; #表示使用的加密套件的类型 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的TLS协议的类型，您需要自行评估是否配置TLSv1.1协议。 ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers on; location / { root /www/wwwroot/public/ ; # 站点目录设置为之前Hugo生成的public路径即可 index index.html; } access_log /www/wwwlogs/access.log; } # 设置HTTP请求自动跳转HTTPS server { listen 80; server_name kdjlyy.cn; #需要将yourdomain替换成证书绑定的域名。 rewrite ^(.*)$ https://$host$1; #将所有HTTP请求通过rewrite指令重定向到HTTPS。 location / { index index.html index.htm; } } include /www/server/panel/vhost/nginx/*.conf; } 需要更改的地方为第68、73、75、83、91行，配置完 Nginx 后把博客的public目录上传到云服务器上，对应 Nginx 配置的 location 中的 root 字段。\n然后输入命令重启 Nginx 即可通过域名访问博客。\n1 /www/server/nginx/sbin/nginx -s reload ","permalink":"https://kdjlyy.github.io/posts/site/ecs_deploy/","summary":"Hugo博客部署, 云服务器, ICP备案, 宝塔面板, SSL, Nginx","title":"Hugo博客部署到云服务器"},{"content":"配置标签页面 PaperMod 主题是支持多语言的，但是标签页不支持，需要修改对应的 html 模板。\n主题提供的语言支持文件在themes/PaperMod/il8n里面，其中zh.yaml即简体中文。\n为了防止更新主题时还原修改过的文件，需要在网站根目录进行修改，这样可以覆盖主题原有文件的效果。在网站根目录新建i18n/文件夹，复制themes/PaperMod/i18n/zh.yaml到i18n/zh.yaml，并按需设置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 - id: prev_page translation: \u0026#34;上一页\u0026#34; - id: next_page translation: \u0026#34;下一页\u0026#34; - id: read_time translation: one : \u0026#34;1 分钟\u0026#34; other: \u0026#34;{{ .Count }} 分钟\u0026#34; - id: words translation: one: \u0026#34;字\u0026#34; other: \u0026#34;{{ .Count }} 字\u0026#34; - id: toc translation: \u0026#34;目录\u0026#34; - id: translations translation: \u0026#34;语言\u0026#34; - id: home translation: \u0026#34;主页\u0026#34; - id: edit_post translation: \u0026#34;编辑\u0026#34; - id: code_copy translation: \u0026#34;Copy\u0026#34; - id: code_copied translation: \u0026#34;Done\u0026#34; 添加MathJax 创建themes/PaperMod/layouts/partials/mathjax.html，输入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; async src=\u0026#34;https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[\u0026#39;$\u0026#39;, \u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;]], displayMath: [[\u0026#39;$$\u0026#39;, \u0026#39;$$\u0026#39;], [\u0026#39;\\[\\[\u0026#39;, \u0026#39;\\]\\]\u0026#39;]], processEscapes: true, processEnvironments: true, skipTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;], TeX: { equationNumbers: { autoNumber: \u0026#34;AMS\u0026#34; }, extensions: [\u0026#34;AMSmath.js\u0026#34;, \u0026#34;AMSsymbols.js\u0026#34;] } }, \u0026#34;HTML-CSS\u0026#34;: { availableFonts: [\u0026#34;Arial\u0026#34;, \u0026#34;TeX\u0026#34;], preferredFont: \u0026#34;TeX\u0026#34;, webFont: \u0026#34;TeX\u0026#34; } }); MathJax.Hub.Queue(function () { // Fix \u0026lt;code\u0026gt; tags after MathJax finishes running. This is a // hack to overcome a shortcoming of Markdown. Discussion at // https://github.com/mojombo/jekyll/issues/199 var all = MathJax.Hub.getAllJax(), i; for (i = 0; i \u0026lt; all.length; i += 1) { all[i].SourceElement().parentNode.className += \u0026#39; has-jax\u0026#39;; } }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; code.has-jax { font: inherit; font-size: 100%; background: inherit; border: inherit; color: #515151; } \u0026lt;/style\u0026gt; 打开themes/PaperMod/layouts/partials/extend_head.html文件，添加如下内容：\n1 2 \u0026lt;!-- MathJax Support --\u0026gt; {{ partial \u0026#34;mathjax.html\u0026#34; . }} 下面是一个泰勒级数展开的例子：\n$$f(x) = f(a) + f\u0026rsquo;(a)(x-a) + \\frac{f\u0026rsquo;\u0026rsquo;(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n)}(a)}{n!}(x-a)^n + R_n(x)$$\n其中，$f(a)$表示在点$a$处的函数值，$f\u0026rsquo;(a)$表示在点$a$处的导数值，$f\u0026rsquo;\u0026rsquo;(a)$表示在点$a$处的二阶导数值，以此类推，$R_n(x)$为余项：$$R_n(x) = \\frac{f^{(n+1)}(c)}{(n+1)!}(x-a)^{n+1}$$\n自定义头部 Hugo 提供了一个默认的文章使用模板，位于archetypes/default.md，里面包括一些基本内容标题、日期以及是否为草稿。\n为方便写作，在文件夹 archetypes 中创建post.md 文件，并写入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} lastmod: {{ .Date }} author: [\u0026#34;kdjlyy\u0026#34;] summary: \u0026#34;\u0026#34; # 简单描述，会展示在主页，可被搜索 weight: # 输入1可以顶置文章 draft: false # 是否为草稿 comments: true # 是否开启评论 showToc: true # 显示目录 TocOpen: true # 自动展开目录 autonumbering: true # 目录自动编号 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 searchHidden: false # 该页面不能被搜索到 showbreadcrumbs: true # 顶部显示当前路径 mermaid: true # 是否开启mermaid cover: image: \u0026#34;\u0026#34; # 封面图片 hidden: true # 文章页面隐藏封面图片 tags: - tag 1 - tag 2 --- 根据定义好的模板，在此利用该模板生成关于页面，根目录执行执行命令：\n1 hugo new --kind post content/posts/tech/xx.md 自定义字体 本博客使用落霞孤鹜系列字体，正文使用 LXGW WenKai Lite 字体，代码块英文使用 JetBrains Mono 字体，中文使用 LXGW WenKai Screen 字体，公式使用 Arial 字体。\n打开themes/PaperMod/layouts/partials/extend_head.html文件，这个是会插入到 \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; 中间的内容，添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!-- 文章字体设置 --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; body { font-family: \u0026#34;LXGW WenKai Lite\u0026#34;, sans-serif; font-family: \u0026#34;LXGW WenKai Screen\u0026#34;, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; 详细内容参考：https://github.com/lxgw/LxgwWenKai/issues/24\n打开themes/PaperMod/assets/css/extended/blank.css ，这个是可以自定义样式的地方，添加：\n1 2 3 4 5 6 7 8 9 /* ========== 正文字体：落霞孤鹜 ========== */ body { font-family: \u0026#34;LXGW WenKai Lite\u0026#34;, sans-serif !important; } /* ========== 代码字体：JetBrains Mono ========== */ code { font-family: \u0026#34;JetBrains Mono\u0026#34;, \u0026#34;LXGW WenKai Screen\u0026#34;, \u0026#34;LXGW WenKai Lite\u0026#34;, sans-serif; } 为了让 MathJax 公式更加美观，需要在themes/PaperMod/layouts/partials/mathjax.html文件的MathJax.Hub.Config配置中添加：\n1 2 3 4 5 \u0026#34;HTML-CSS\u0026#34;: { availableFonts: [\u0026#34;Arial\u0026#34;, \u0026#34;TeX\u0026#34;], preferredFont: \u0026#34;TeX\u0026#34;, webFont: \u0026#34;TeX\u0026#34; } ​\t示例：$\\sum_{i=0}^N\\int_{a}^{b}g(t,i)\\text{d}t$\n添加busuanzi busuanzi 插件可以提供站点访问量和文章阅读数的计数服务，因为打开该功能会略微降低网站加载速度，所以默认关闭该功能。\n打开themes/PaperMod/layouts/partials/head.html，在{{- /* Styles */}}这一行前面添加如下代码：\n1 2 3 4 5 \u0026lt;!-- busuanzi --\u0026gt; {{- if site.Params.busuanzi.enable -}} \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;no-referrer-when-downgrade\u0026#34;\u0026gt; {{- end }} 在站点底部显示总访问量与访客数，打开footer.html一般和head.html同目录，添加如下代码，注意添加在\u0026lt;footer\u0026gt;代码块里：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- busuanzi --\u0026gt; {{ if .Site.Params.busuanzi.enable -}} \u0026lt;div class=\u0026#34;busuanzi-footer\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_site_pv\u0026#34;\u0026gt; 本站总访问量\u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次 \u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_site_uv\u0026#34;\u0026gt; 本站访客数\u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;人次 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} 用于显示每篇文章阅读量，在themes/PaperMod/layouts/_default/single.html，一样注意加在\u0026lt;header\u0026gt;代码块内：\n1 2 3 4 5 6 \u0026lt;!-- busuanzi --\u0026gt; {{ if .Site.Params.busuanzi.enable -}} \u0026lt;div class=\u0026#34;meta-item\u0026#34;\u0026gt;\u0026amp;nbsp·\u0026amp;nbsp \u0026lt;span id=\u0026#34;busuanzi_container_page_pv\u0026#34;\u0026gt;本文阅读量\u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{- end }} 回到根目录改config.yml，在params里加上两行：\n1 2 3 params: busuanzi: enable: true 修改post_meta头部信息 post_meta 样式 定位到文件：themes/PaperMod/layouts/partials/post_meta.html，替换如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 {{- $scratch := newScratch }} \u0026lt;!-- 创建时间 --\u0026gt; {{- if not .Date.IsZero -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (printf \u0026#34;创建:\u0026amp;nbsp;\u0026lt;span title=\u0026#39;%s\u0026#39;\u0026gt;%s\u0026lt;/span\u0026gt;\u0026#34; (.Date) (.Date.Format (default \u0026#34;January 2, 2006\u0026#34; .Site.Params.DateFormat)))) }} {{- end }} \u0026lt;!-- 更新时间 --\u0026gt; {{- if (.Param \u0026#34;ShowLastMod\u0026#34;) -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (printf \u0026#34;更新:\u0026amp;nbsp;%s\u0026#34; (.Lastmod.Format (.Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34;)))) }} {{- end }} \u0026lt;!-- 统计字数 --\u0026gt; {{- if (.Param \u0026#34;ShowWordCounts\u0026#34;) -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (default (printf \u0026#34;字数:\u0026amp;nbsp;%d字\u0026#34; .WordCount))) }} {{- end }} \u0026lt;!-- 大概需要花费的阅读时间 --\u0026gt; {{- if (.Param \u0026#34;ShowReadingTime\u0026#34;) -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (default (printf \u0026#34;时长: %d分钟\u0026#34; .ReadingTime))) }} {{- end }} \u0026lt;!-- 作者 --\u0026gt; {{- with (partial \u0026#34;author.html\u0026#34; .) }} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice .) }} {{- end }} \u0026lt;!-- 分隔方式 --\u0026gt; {{- with ($scratch.Get \u0026#34;meta\u0026#34;) }} {{- delimit . \u0026#34;\u0026amp;nbsp;|\u0026amp;nbsp;\u0026#34; -}} {{- end -}} 作者的中文显示要找themes/PaperMod/layouts/partials/author.html，设置如下：\n1 2 3 4 5 6 7 8 9 {{- if or .Params.author site.Params.author }} 作者:\u0026amp;nbsp;{{- $author := (.Params.author | default site.Params.author) }} {{- $author_type := (printf \u0026#34;%T\u0026#34; $author) }} {{- if (or (eq $author_type \u0026#34;[]string\u0026#34;) (eq $author_type \u0026#34;[]interface {}\u0026#34;)) }} {{- (delimit $author \u0026#34;, \u0026#34; ) }} {{- else }} {{- $author }} {{- end }} {{- end -}} 因为有些字段是自己加的，所以还要在config.yml文件的params字段下加上这些字段：\n1 2 3 4 5 params: DateFormat: \u0026#34;2006-01-02\u0026#34; ShowWordCounts: true ShowReadingTime: true ShowLastMod: true 在每篇文章开头记得加上“date”、“lastmod”、“author”这三个字段，已经集成在 archetypes/post.md 里面了，这样每次创建文章就会自动生成，生成文章的命令：\n1 hugo new --kind post content/posts/tech/xx.md 参考：Hugo博客修改post_meta头部信息\n添加背景图片 通过浏览器定位 html 代码，发现背景图片在 list 标签下，所以需要：\n打开themes/PaperMod/assets/css/extended/blank.css，添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 主页背景图片 */ .list { /* 添加!important表示覆盖默认的设置 */ background-image: url(\u0026#34;../../img/white_mountains.jpg\u0026#34;) !important; /* 照片不重复出现 */ background-repeat: no-repeat; /* 照片大小 */ background-size: 100% 100%; /* 右侧滚动时照片固定大小 */ background-attachment: fixed; } .dark.list { /* 添加!important表示覆盖默认的设置 */ background-image: url(\u0026#34;../../img/white_mountains_dark.jpg\u0026#34;) !important; background-repeat: no-repeat; background-size: 100% 100%; background-attachment: fixed; } 这里我是将图片源文件放在public/img目录下，也可以使用 URL 的方式填写。\n文章自动编号 个人在写用 markdown 文章时一般用二级标题##开始，希望写文章时能有类似于 $LaTeX$ 的体验，这个在 Typora 中很容易实现，只需要添加对应的 css 样式即可，网络上很容易找到对应的教程。\n在 Hugo 的 PaperMod 主题中，以下操作可以实现目录和正文的自动编号：\n打开themes/PaperMod/layouts/_default/single.html文件，将\n1 \u0026lt;article class=\u0026#34;post-single\u0026#34;\u0026gt; 替换为：\n1 \u0026lt;article class=\u0026#34;post\u0026#34; {{- if .Param \u0026#34;autonumbering\u0026#34; }} autonumbering {{- end }}\u0026gt; 打开themes/PaperMod/assets/css/extended/blank.css，添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* ========= 文章和目录自动编号（从二级标题开始）============ */ body { counter-reset: h2 } h2 { counter-reset: h3 } h3 { counter-reset: h4 } h4 { counter-reset: h5 } article[autonumbering] h2:before { counter-increment: h2; content: counter(h2) \u0026#34;. \u0026#34; } article[autonumbering] h3:before { counter-increment: h3; content: counter(h2) \u0026#34;.\u0026#34; counter(h3) \u0026#34; \u0026#34; } article[autonumbering] h4:before { counter-increment: h4; content: counter(h2) \u0026#34;.\u0026#34; counter(h3) \u0026#34;.\u0026#34; counter(h4) \u0026#34; \u0026#34; } article[autonumbering] .toc ul { counter-reset: item } article[autonumbering] .toc li a:before { content: counters(item, \u0026#34;.\u0026#34;) \u0026#34; \u0026#34;; counter-increment: item } 在文章头部信息前面设置autonumbering: true即可完成正文和目录的自动编号功能。\n封面图片缩小并移到侧边 PaperMod 主题会因为插入了封面图片导致文章磁贴高度变大，达不到美观统一的要求，下面操作可以做到将封面图片缩小并移到右侧，效果如图：\n封面图片缩小并移到侧边 打开themes/PaperMod/layouts/_default/list.html，添加一个 class 标识，命名为post-info，把 entry-header 和 entry-content 和 entry-footer 都包裹进去，具体修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;article class=\u0026#34;{{ $class }}\u0026#34;\u0026gt; \u0026lt;!-- {{- $isHidden := (site.Params.cover.hidden | default site.Params.cover.hiddenInList) }} {{- partial \u0026#34;cover.html\u0026#34; (dict \u0026#34;cxt\u0026#34; . \u0026#34;IsHome\u0026#34; true \u0026#34;isHidden\u0026#34; $isHidden) }} --\u0026gt; \u0026lt;div class=\u0026#34;post-info\u0026#34;\u0026gt; \u0026lt;header class=\u0026#34;entry-header\u0026#34;\u0026gt; \u0026lt;h2\u0026gt; {{- .Title }} {{- if .Draft }}\u0026lt;sup\u0026gt;\u0026lt;span class=\u0026#34;entry-isdraft\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;[draft]\u0026lt;/span\u0026gt;\u0026lt;/sup\u0026gt; {{- end }} \u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; {{- if (ne (.Param \u0026#34;hideSummary\u0026#34;) true) }} \u0026lt;div class=\u0026#34;entry-content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ .Summary | plainify | htmlUnescape }}{{ if .Truncated }}...{{ end }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; {{- end }} {{- if not (.Param \u0026#34;hideMeta\u0026#34;) }} \u0026lt;footer class=\u0026#34;entry-footer\u0026#34;\u0026gt; {{- partial \u0026#34;post_meta.html\u0026#34; . -}} \u0026lt;/footer\u0026gt; {{- end }} \u0026lt;/div\u0026gt; {{- $isHidden := (.Site.Params.cover.hidden | default .Site.Params.cover.hiddenInList) }} {{- partial \u0026#34;cover.html\u0026#34; (dict \u0026#34;cxt\u0026#34; . \u0026#34;IsHome\u0026#34; true \u0026#34;isHidden\u0026#34; $isHidden) }} \u0026lt;a class=\u0026#34;entry-link\u0026#34; aria-label=\u0026#34;post link to {{ .Title | plainify }}\u0026#34; href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/article\u0026gt; 打开themes/PaperMod/assets/css/extended/blank.css，添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* 封面图片显示到右边 */ .entry-cover1 { border-radius: 10px; display: flex; justify-content: center; } .post-entry { display: flex; flex-direction: row; align-items: center; } .entry-cover { border-radius: 10px; overflow: hidden; width: 50%; margin-bottom: unset; max-height: 150px; display: grid; align-content: center; } .post-info { display: inline-block; overflow: hidden; width: 100%; padding-right: 10px; } /* 文章内使用的封面图 */ .entry-cover1 img { border-radius: var(--radius); pointer-events: none; width: 100%; height: auto; margin-bottom: 40px; } 因为上面对文章封面图片进行了调整，会影响到文章里面顶部的图片展示，所以需要解决冲突：\n定位到目录themes/PaperMod/layouts/partials/cover.html，在相同目录下创建一个名字为cover1.html的文件，并把cover.html里的文件复制一份一样的到cover1.html下；\n把cover1.html文件里的\u0026lt;figure class=\u0026quot;entry-cover\u0026quot;\u0026gt;修改为\u0026lt;figure class=\u0026quot;entry-cover1\u0026quot;\u0026gt;；\n定位到themes/PaperMod/layouts/_default/single.html，把{{- partial \u0026quot;cover.html\u0026quot; (dict \u0026quot;cxt\u0026quot; . \u0026quot;IsHome\u0026quot; false \u0026quot;isHidden\u0026quot; $isHidden) }}改为{{- partial \u0026quot;cover1.html\u0026quot; (dict \u0026quot;cxt\u0026quot; . \u0026quot;IsHome\u0026quot; false \u0026quot;isHidden\u0026quot; $isHidden) }}，这样文章封面调用的是经过修改的图片，而文章里面顶部的图片调用的是未经修改的图片。\n如果只需要封面图片，但是不需要文章顶部的图片需要在写作时设置头部：\n1 2 3 cover: image: \u0026#34;\u0026#34; # 封面图片 hidden: true # 文章页面隐藏封面图片 添加utterances评论 utterances 是一款基于 GitHub issues 的评论工具，优点是极其轻量、加载非常快、配置比较简单。\n首先创建一个 Github 仓库保存个人博客的评论内容，例如：blog_comments；\n进入 utterances app 对自己所要保存评论的仓库授权；\n创建themes/PaperMod/layouts/partials/comments.html，输入：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- github comments --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;pagination__title\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;pagination__title-h\u0026#34; style=\u0026#34;font-size: 20px;\u0026#34;\u0026gt;评论\u0026lt;/span\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;tcomment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;GitHub仓库名称（如：kdjlyy/blog_comments）\u0026#34; issue-term=\u0026#34;title\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; 在博客配置文件config.yml中的params字段添加配置：\n1 2 3 4 5 utteranc: enable: true repo: \u0026#34;kdjlyy/blog_comments\u0026#34; issueTerm: \u0026#34;title\u0026#34; theme: \u0026#34;github-light\u0026#34; ","permalink":"https://kdjlyy.github.io/posts/site/hugo-papermod-optimization/","summary":"PaperMod, 主题优化, 标签页面, MathJax, 自定义头部, 自定义字体, 卜算子, busuanzi, post_meta, 背景图片, 自动编号, utterances, 评论","title":"PaperMod主题优化"},{"content":"新建Github仓库 新建一个 GitHub Repository，库名为 username.github.io，username 即你的 GitHub 账号 username。\n新建 Github 仓库 配置文件 在上一篇文章中我们在本地快速启动了 Hugo 博客：\n基于Hugo搭建静态博客 日期: 2023-05-30 \u0026nbsp; 标签: #Hugo\u0026nbsp; #PaperMod\u0026nbsp; hugo, 静态博客, PaperMod, 快速启动 ...... 其中站点配置文件改成了 .yml 后缀的写法，因为这样比默认的 .toml 写法更易用，详细参考：Configure Hugo。\n下面是我的 config.yml 配置，注意不同的主题配置方法可能有差异，我使用的是 PaperMod 主题。部分信息根据需要自行更改，例如我绑定了个人域名所以 baseURL 设置的是自己购买的域名，也可以配置使用 Github 仓库的域名访问博客主页。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 baseURL: https://kdjlyy.cn # baseURL: https://kdjlyy.github.io languageCode: zh-cn title: 向着悠远的苍穹 theme: PaperMod paginate: 10 # 首页每页显示的文章数 hasCJKLanguage: true # 自动检测是否包含中文日文韩文,如果文章中使用了很多中文引号的话可以开启 enableInlineShortcodes: true # 允许内联短码 enableEmoji: true # 允许使用 Emoji 表情，建议 true enableRobotsTXT: true # 允许爬虫抓取到搜索引擎，建议 true summaryLength: 90 # 文章内链卡片获取的文章长度默认是70 buildDrafts: false buildFuture: false buildExpired: false # pygmentsUseClasses: true # googleAnalytics: UA-123-45 minify: disableXML: true # minifyOutput: true permalinks: # 浏览器链接显示方式 post: \u0026#34;/:title/\u0026#34; # post: \u0026#34;/:year/:month/:day/:title/\u0026#34; defaultContentLanguage: zh # 最顶部首先展示的语言页面 defaultContentLanguageInSubdir: true languages: zh: languageName: \u0026#34;Chinese\u0026#34; # contentDir: content/english weight: 1 profileMode: enabled: true title: # 主页标题 subtitle: # 主页副标题 imageUrl: \u0026#34;img/logo.ico\u0026#34; # 头像 imageTitle: imageWidth: 150 imageHeight: 150 buttons: - name: 👨🏻‍💻技术 url: posts/tech - name: 📋建站 url: posts/site - name: 📕阅读 url: posts/read - name: 🏖生活 url: posts/life menu: main: - identifier: search name: 🔍搜索 url: search weight: 1 - identifier: home name: 🏠主页 url: / weight: 2 - identifier: posts name: 📚文章 url: /posts weight: 3 - identifier: archives name: ⏱️时间轴 url: /archives weight: 20 # - identifier: categories # name: 🧩分类 # url: /categories # weight: 30 - identifier: tags name: 🔖标签 url: /tags weight: 40 - identifier: about name: 🙋🏻‍♂️关于 url: /about weight: 50 # - identifier: links # name: 🤝友链 # url: links # weight: 60 outputs: home: - HTML - RSS - JSON params: env: production # to enable google analytics, opengraph, twitter-cards and schema. description: \u0026#34;向着悠远的苍穹, kdjlyy\u0026#39;s Blog\u0026#34; author: kdjlyy # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] defaultTheme: light # defaultTheme: light or dark disableThemeToggle: false DateFormat: \u0026#34;2006-01-02\u0026#34; # ShowShareButtons: true ShowReadingTime: false # disableSpecialistPost: true displayFullLangName: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true hideFooter: false # 隐藏页脚 ShowWordCounts: true VisitCount: true ShowLastMod: true #显示文章更新时间 ShowToc: true # 显示目录 TocOpen: true # 自动展开目录 comments: true busuanzi: enable: false # 访问量统计，开启会降低加载速度 socialIcons: - name: github url: \u0026#34;https://github.com/kdjlyy\u0026#34; - name: bilibili url: \u0026#34;https://space.bilibili.com/279296780\u0026#34; - name: QQ url: \u0026#34;img/qq.jpg\u0026#34; - name: email url: \u0026#34;kdjlyy@qq.com\u0026#34; # - name: RSS # url: \u0026#34;index.xml\u0026#34; # - name: QQ # url: \u0026#34;img/qq.png\u0026#34; # - name: Phone # url: \u0026#34;img/phone.png\u0026#34; # editPost: # URL: \u0026#34;https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content\u0026#34; # Text: \u0026#34;Suggest Changes\u0026#34; # edit text # appendFilePath: true # to append file path to Edit link # label: # text: \u0026#34;Home\u0026#34; # icon: icon.png # iconHeight: 35 assets: favicon: \u0026#34;img/logo.ico\u0026#34; favicon16x16: \u0026#34;img/logo.ico\u0026#34; favicon32x32: \u0026#34;img/logo.ico\u0026#34; apple_touch_icon: \u0026#34;logo.ico\u0026#34; safari_pinned_tab: \u0026#34;logo.ico\u0026#34; # cover: # hidden: true # hide everywhere but not in structured data # hiddenInList: true # hide on list pages and home # hiddenInSingle: true # hide on single page fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 1 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;] # twikoo: # version: 1.4.11 # 评论 utteranc: enable: true repo: \u0026#34;kdjlyy/blog_comments\u0026#34; issueTerm: \u0026#34;title\u0026#34; theme: \u0026#34;github-light\u0026#34; taxonomies: category: categories tag: tags series: series markup: goldmark: renderer: unsafe: true # HUGO 默认转义 Markdown 文件中的 HTML 代码，如需开启的话 highlight: # anchorLineNos: true # 代码行号下加下划线 codeFences: true # 代码围栏功能，这个功能一般都要设为true，不然很难看 guessSyntax: true # 猜测语法，这个功能建议设置为true, 如果你没有设置要显示的语言则会自动匹配 lineNos: true # 代码行号 style: nord # monokai, darcula, solarized-dark, nord lineNumbersInTable: true # 使用表来格式化行号和代码,而不是标签。这个属性一般设置为 true # hl_Lines：高亮的行号，一般这个不设置，因为每个代码块我们可能希望让高亮的地方不一样 # lineNoStart：行号从编号几开始，一般从 1 开始 # lineNos：是否显示行号，我比较喜欢显示，所以我设置的为 true # noClasses: true # 使用 class 标签，而不是内嵌的内联样式 privacy: vimeo: disabled: false simple: true twitter: disabled: false enableDNT: true simple: true instagram: disabled: false simple: true youtube: disabled: false privacyEnhanced: true services: instagram: disableInlineCSS: true twitter: disableInlineCSS: true 目录结构 个人的目录配置如下，搭配上面的配置文件使用。\n文章目录结构 博客文章都是存放在content目录下的，具体的目录结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 content/ ├── posts/ │\t├── life/ │\t│\t└── _index.md │\t├── read/ │\t│\t└── _index.md │\t├── site/ │\t│\t├── xxx.md │\t│\t└── _index.md │\t├── tech/ │\t│\t└── _index.md │\t└── _index.md ├── about.md ├── archive.md └── search.md about.md、archive.md、search.md 分别对应右上角关于、时间轴、搜索三个页面。\nlife、read、site、tech 对应首页的四个按钮，content 里每个文件夹内都要添加一个 _index.md 文件。在对应的文件夹下创建 markdown 文件即可将文章放入对应的分类中。\nabout.md 1 2 3 4 5 6 7 8 9 10 --- title: \u0026#34;关于\u0026#34; layout: \u0026#34;about\u0026#34; url: \u0026#34;/about/\u0026#34; summary: about hidemeta: true # 是否隐藏文章的元信息，如发布日期、作者等 showbreadcrumbs: false #顶部显示当前路径 searchHidden: true showToc: false --- archive.md 1 2 3 4 5 6 --- title: \u0026#34;时间轴\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives/\u0026#34; summary: archives --- search.md 1 2 3 4 5 6 7 8 --- title: \u0026#34;搜索\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # is necessary url: \u0026#34;/search/\u0026#34; # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; placeholder: \u0026#34;请输入关键词\u0026#34; --- life/_index.md 1 2 3 4 5 --- title: \u0026#34;🏖 生活\u0026#34; # description: \u0026#34;\u0026#34; hidemeta: true # 是否隐藏文章的元信息，如发布日期、作者等 --- read/_index.md 1 2 3 4 5 --- title: \u0026#34;📕 阅读\u0026#34; # description: hidemeta: true # 是否隐藏文章的元信息，如发布日期、作者等 --- site/_index.md 1 2 3 4 5 --- title: \u0026#34;📋 建站\u0026#34; # description: hidemeta: true # 是否隐藏文章的元信息，如发布日期、作者等 --- tech/_index.md 1 2 3 4 5 --- title: \u0026#34;👨🏻‍💻 技术\u0026#34; # description: \u0026#34;\u0026#34; hidemeta: true # 是否隐藏文章的元信息，如发布日期、作者等 --- 部署到 Github 写完博客后本地预览：hugo server -D，浏览器打开：http://localhost:1313/ 访问。\n输入hugo -D生成public文件夹，这个文件夹可以部署到云服务器或者托管到github上。\n⚠️注意：这种生成方式只会往 public 文件夹里添加内容，但是不会删除外部已经不存在而 public 里面还存在的文件，所以也可以用hugo -F --cleanDestinationDir命令，表示每次生成的public都是全新的，会覆盖原来的。\n将 public 文件夹上传到步骤1中的 username.github.io 仓库中\n1 2 3 4 5 6 7 cd public git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin git@github.com:xxx/xxx.github.io.git git push -u origin main 几十秒钟后，即可通过 Github 域名访问，例如我的 Github 博客域名为：https://kdjlyy.github.io/\n","permalink":"https://kdjlyy.github.io/posts/site/hugo-papermod-configure/","summary":"hugo, papermod, 主题配置","title":"Hugo主题配置及Github部署"},{"content":"前言 一直想搭建一个记录自己学习与生活的博客，断断续续尝试过很多种方案，例如基于 Typecho 或 Wordpress 的动态博客，基于 Hexo + Coding 的静态博客。\n其中基于 Wordpress 搭建动态博客在互联网上的比例很大，有海量的模版和丰富的教程。Typecho 和 Wordpress 类似，只是前者更加轻量级，界面更加简洁，理论上加载速度更快。Wordpress 的功能更加强大，可以用于搭建论坛、购物网站等，个人觉得只用来写技术博客有点大材小用了。因为不想花费很多精力在博客网站的排版、样式等功能上，更想专注于写文章本身，所以之前使用过较长时间的 Typecho 博客。\n但是动态博客的优点和缺点都很明显，动态博客可以提供诸如在线发布、数据统计、用户注册等一系列在线服务，但是需要部署在云服务器上，一般需要搭配域名使用。然而个人并不常用以上的在线服务，所以更倾向使用静态博客。Hexo 和 Hugo 的区别不大，但是 Hexo 需要 nodejs 环境并且加载速度没有 Hugo 快，优点是 Hexo 的主题更多。\n最终权衡下还是使用 Hugo + PaperMod 主题的方案搭建了静态博客。\n技术选型 博客框架：Hugo\n博客主题：PaperMod\n博客字体：LXGW WenKai、JetBrains Mono\n托管工具：Github 或云服务器\n写作工具：Typora、Handraw\n免费图床：路过图床（不支持 GIF）、Picgo\n优点：\n不需要购买云服务器和域名，网站托管在 Github 上（也可以部署到云服务器上，绑定域名）； 网站功能简洁，加载速度快，不用花费精力维护； 使用本地 Typora 写作，所见即所得。 快速启动 搭建过程中参考了如下博客及教程：Sulv\u0026rsquo;s Blog、 田少晗的个人博客、Memory\n安装Hugo 安装前需要准备 Go 和 Git 环境，以下是个人使用的环境，合适的版本即可。\n基础环境 版本号 系统 MacOS Ventura 13.0 (M1 Pro) Go go version go1.17.7 darwin/amd64 Git git version 2.37.1 (Apple Git-137.1) Mac 用户输入：\n1 brew install hugo 安装完成后输入hugo version验证，若出现版本信息则表示安装成功。\n新建站点 新建站点目录kdjlyy_blog，并将站点配置文件改为.yml后缀写法：\n1 hugo new site kdjlyy_blog -f yml 会自动生成以下目录结构：\n1 2 3 4 5 6 7 8 9 10 11 kdjlyy_blog/ ├── archetypes/ │ └── default.md ├── assets/ ├── content/ ├── data/ ├── layouts/ ├── public/ ├── static/ ├── themes/ └── config.yml 目录结构详细介绍参考：https://gohugo.io/getting-started/directory-structure/\n下载主题 在 Hugo Themes 官网下载喜欢的主题到themes文件夹，以个人使用的 PaperMod 主题为例：\n1 2 cd themes git clone git@github.com:adityatelange/hugo-PaperMod.git ​\t把文件夹名称由 hugo-PaperMod 改为 PaperMod，方便后续配置。\n在站点文件夹下的配置文件config.yaml里配置主题：\n1 2 3 4 baseURL: \u0026#34;/\u0026#34; languageCode: \u0026#39;en-us\u0026#39; title: \u0026#39;My Blog\u0026#39; theme: \u0026#34;PaperMod\u0026#34; 新建文章 在站点目录下，新建文章：\n1 hugo new posts/first-blog.md 此时first-blog.md将自动生成在content/posts目录下:\n1 2 3 4 5 --- title: \u0026#34;First Blog\u0026#34; date: 2023-05-30T17:17:15+08:00 draft: false --- 在后面使用 markdown 格式书写即可。\n本地运行 在站点目录下执行命令：\n1 hugo server -D 进入 http://localhost:1313/ 即可访问个人主页。\n","permalink":"https://kdjlyy.github.io/posts/site/site-init/","summary":"hugo, 静态博客, PaperMod, 快速启动","title":"基于Hugo搭建静态博客"},{"content":"大数 大数加法 给定两个字符串形式的非负整数num1和num2，计算它们的和并以字符串形式返回1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 string addStrings(string num1, string num2) { int i = num1.size() - 1, j = num2.size() - 1, carry = 0; string res(\u0026#34;\u0026#34;); while(i \u0026gt;= 0 || j \u0026gt;= 0) { int x = i\u0026gt;=0? num1[i]-\u0026#39;0\u0026#39;: 0; int y = j\u0026gt;=0? num2[j]-\u0026#39;0\u0026#39;: 0; int t = x + y + carry; carry = t/10; res.insert(0, to_string(t%10)); i--, j--; } if (carry) res.insert(0, \u0026#34;1\u0026#34;); return res; } 大数乘法 给定两个字符串形式的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，计算它们的乘积并以字符串形式返回2。\n[解析]：本题有两种思路：\n方法1：模拟竖式计算 方法2：乘法规律计算 做加法：模拟竖式计算，从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加（累加时使用大数加法 addString 的思路）；\n做乘法：通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：\n乘数 $num1$ 位数为 $M$，被乘数 $num2$ 位数为 $N$， $num1 \\times num2$ 结果 $res$ 最大总位数为 $M+N$；\n$num1[i] \\times num2[j]$ 的结果为 $t$（位数为两位，\u0026quot;$0x$\u0026quot;，\u0026quot;$xy$\u0026quot; 的形式），其第一位位于 $res[i+j]$，第二位位于 $res[i+j+1]$。\n代码 方法1🤔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 string multiply(string num1, string num2) { if (num1 == \u0026#34;0\u0026#34; || num2 == \u0026#34;0\u0026#34;) return \u0026#34;0\u0026#34;; int l1 = num1.size() - 1, l2 = num2.size() - 1; string res(\u0026#34;0\u0026#34;); for (int i = l1; i \u0026gt;= 0; i--) { string curr(l1-i, \u0026#39;0\u0026#39;); // 补0 int x = num1[i] - \u0026#39;0\u0026#39;, carry = 0; for (int j = l2; j \u0026gt;= 0; j--) { int y = num2[j] - \u0026#39;0\u0026#39;; int t = x * y + carry; carry = t / 10; curr.insert(0, to_string(t%10)); } if (carry) curr.insert(0, to_string(carry)); res = addStrings(res, curr); } return res; } string addStrings(string num1, string num2) { int i = num1.size() - 1, j = num2.size() - 1, carry = 0; string res(\u0026#34;\u0026#34;); while(i \u0026gt;= 0 || j \u0026gt;= 0) { int x = i\u0026gt;=0? num1[i]-\u0026#39;0\u0026#39;: 0; int y = j\u0026gt;=0? num2[j]-\u0026#39;0\u0026#39;: 0; int t = x + y + carry; carry = t/10; res.insert(0, to_string(t%10)); i--, j--; } if (carry) res.insert(0, \u0026#34;1\u0026#34;); return res; } 代码 方法2🤔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 string multiply(string num1, string num2) { if (num1 == \u0026#34;0\u0026#34; || num2 == \u0026#34;0\u0026#34;) return \u0026#34;0\u0026#34;; int l1 = num1.size(), l2 = num2.size(); vector\u0026lt;int\u0026gt; res(l1+l2, 0); for (int i = l1 - 1; i \u0026gt;= 0; i--) { int x = num1[i] - \u0026#39;0\u0026#39;; for (int j = l2 - 1; j \u0026gt;= 0; j--) { int y = num2[j] -\u0026#39;0\u0026#39;; int sum = res[i+j+1] + x*y; res[i+j+1] = sum % 10; res[i+j] += sum / 10; // res[i+j] 可能大于等于 10，下一轮计算时会进行累加，即第9行代码 } } string ans; for (int i = 0; i \u0026lt; l1+l2; i++) { if (i == 0 \u0026amp;\u0026amp; res[i] == 0) continue; ans += res[i] + \u0026#39;0\u0026#39;; } return ans; } 位运算 负二进制转换 https://leetcode.cn/problems/convert-to-base-2/\n负二进制数相加 https://leetcode.cn/problems/adding-two-negabinary-numbers/solutions/2273578/fu-er-jin-zhi-shu-xiang-jia-by-leetcode-nwktq/\nLeetcode 415. 字符串相加\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLeetcode 43. 字符串相乘\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://kdjlyy.github.io/posts/algorithm/algorithm-simulation/","summary":"大数, 大数加法, 大数乘法, 位运算, 二进制","title":"常见算法-模拟篇"},{"content":"Linux用户空间内存分布 程序内存在地址空间中的分布情况称为内存模型。\n对于32位环境，理论上程序可以拥有4GB的虚拟地址空间，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间。\nLinux默认将高地址的1GB空间分配给内核。也就是说，应用程序只能使用剩下3GB的地址空间，称为用户空间。\nLinux用户空间内存分布 内存分区 说明 text段（程序代码 区） 存放已编译程序的机器代码，只读。 rodata段（常量区） 存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。 data段（全局数据区的已初始化部分） 存放已经初始化的全局变量和静态变量等，这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。 bss段（全局数据区的未初始化部分） 存放未初始化的全局变量和静态变量等。 heap（堆区） 一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。 文件/内存映射区（动态链接库） 用于在程序运行期间加载和卸载动态链接库。例如使用 mmap() 创建内存映射区时，就是在这里申请的内存空间。 stack（栈区） 存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。 Linux程序内存空间 Linux 下内存资源是通过虚拟内存管理的，在分配内存时并不是在物理内存开辟了一段空间，而是在使用时才分配的，并且是通过段页式管理。linux 下内存分配是以页为单位的，而页是通过段管理。各个段之间是独立的，方便管理。\nLinux 程序执行时能够分为下面几个内存段：text、rodata、data、bss、stack、heap。\ntext 段（代码段）：text 段存放程序代码，运行前就已经确定（编译时确定），通常为只读； rodata 段（常量区）：rodata 段存储常量数据，比如程序中定义为 const 的全局变量，“#define”定义的常量，以及诸如“Hello World”的字符串常量。const 修饰的全局变量在常量区，const 修饰的局部变量只是为了防止修改，没有放入常量区（存在栈区）； data 段：data 存储已经初始化的全局变量（静态变量），属于静态内存分配，需要占用可执行文件空间（注意：初始化为0的全局变量和静态变量还是被保存在 bss 段）； bss 段：bss 段存储没有初始化或初始化为0的全局变量（静态变量），属于静态内存分配。bss 不占用可执行文件空间，其内容由操作系统初始化（清零），但占据程序运行时的内存空间； stack 段：stack 段存储参数变量和局部变量，由系统进行申请和释放，属于静态内存分配； heap 段：heap 段是程序运行过程中动态分配的内存段，由用户申请和释放，程序中不释放，则程序结束时，由 OS 回收。 执行文件中包含了 text、rodata、data 段的内容，不包含 bss 段内容（一堆0放入执行文件没有意义）。 堆和栈的内存增长方向是相反的：栈是从高地址向低地址生长，堆是从低地址向高地址生长。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const int NUM = 10086; // 常量区(rodata段) int a = 10; // 全局初始化区（data） char *p1; // 全局未初始化区（bss） int main() { int b; // 栈区 char s[] = \u0026#34;abc\u0026#34;; // 栈区 char *p; // 栈区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); // 分配得来的10和20字节的区域就在堆区 static int c =0; // bss段 const int d = 5; // stack段 char *p3 = \u0026#34;123456\u0026#34;; // p3在栈区，\u0026#34;123456\\0\u0026#34; 在rodata段 strcpy(p1, \u0026#34;123456\u0026#34;); // \u0026#34;123456\\0\u0026#34; 放在rodata段，编译器可能会将它与p3所指向的\u0026#34;123456\u0026#34;优化成一个地方。 } 虚拟内存 物理内存是实际的物理空间，即直接映射到硬件 RAM 的物理内存资源。\n虚拟内存是逻辑上的地址空间，它通过将物理内存和硬盘空间组合使用，从逻辑上扩展了物理内存的大小，从而让程序获得更多的可用内存。\n为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个页（Linux下页大小为4KB，即4096字节）。而物理内存则被分成相同大小的页面帧，程序的页被映射到物理内存对应的帧（但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中）。当程序访问到不在物理内存中的页时，发生缺页中断，将缺失的页装入物理内存并重新执行失败的指令。\n从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生16位地址，那么一个程序的地址空间范围是0~64K。该计算机只有32KB的物理内存，虚拟内存技术允许该计算机运行一个64K大小的程序。\n虚拟内存 new/delete 和 malloc/free new 和 delete 是用户进行动态内存申请和释放的操作符，operator new 和 operator delete 是系统提供的全局函数，new 在底层调用 operator new 全局函数来申请空间，delete 在底层通过 operator delete 全局函数来释放空间。\nnew的过程\n调用 operator new 函数申请空间； 在申请的空间上执行构造函数，完成对象的构造。 delete的过程\n在申请的空间上执行析构函数，完成对象中资源的清理工作； 调用 operator delete 函数释放对象的空间。 new T[N]的过程\n调用 operator new[] 函数，在 operator new[] 中实际调用 operator new 函数完成N个对象空间的申请； 在申请的空间上执行N次构造函数。 delete[]的过程\n在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理； 调用 operator delete[] 释放空间，实际在 operator delete[] 中调用 operator delete 来释放空间。 new/delete 和 malloc/free的异同 相同点是: 都是从堆上申请空间，并且需要用户手动释放。\n不同点是:\nmalloc 和 free 是函数，new 和 delete 是操作符； malloc 申请的空间不会初始化，new 可以初始化； malloc 申请空间时，需要手动计算空间大小并传递，new 只需在其后跟上空间的类型即可； malloc 的返回值为 void*, 在使用时必须强转；new 不需要，因为 new 后跟的是空间的类型； malloc 申请空间失败时，返回的是 NULL，因此使用时必须判空；new 不需要，但是 new 需要捕获异常； 申请自定义类型对象时，malloc/free 只会开辟与销毁空间，不会调用构造函数与析构函数；而 new 在申请空间后会调用构造函数完成对象的初始化，delete 在释放空间前会调用析构函数完成空间中资源的清理； new/delete 比 malloc/free 的效率稍微低点，因为 new/delete 的底层封装了 malloc/free。 free 如何知道要 free 多大的空间 malloc 函数的实现是以块分配内存，在被分配的块中包括两部分：\n第一部分中存储含有报头的元数据，它其中包含有分配块的大小信息，是一个常量； 第二部分中存储实际用户数据。而使用 malloc 分配内存返回的是第二部分用户数据的地址。 所以内存释放时不再需要再指定释放多大的内存空间，只需要指定该块内存空间的首地址即可。\nnew 一个对象时加括号和不加括号的区别 对于内置类型：\nint *a = new int; 不会将申请到的 int 空间初始化，而 int *a = new int(); 则会将申请到的 int 空间初始化为0。\n1 2 int *a1 = new int[10]; // 10个未初始化int int *a2 = new int[10](); // 10个值初始化为0的int 对于自定义类类型：\n如果该类显式定义了默认构造函数，那么 class c = new class; 和 class c = new class(); 一样，都会调用默认构造函数。\n如果该类没有显式定义构造函数（由编译器生成默认构造函数）但有虚函数，那么 class c = new class; 和 class c = new class(); 一样，都会调用默认构造函数；\n如果该类没有显式定义构造函数（由编译器生成默认构造函数）也没有虚函数，那么 class c = new class 将不调用合成的默认构造函数，而 class c = new class() 则会调用默认构造函数。\nmalloc/free 实现原理 brk 和 mmap 函数 brk() 和 sbrk() 函数：作用是扩展 heap 的上界 brk\n1 2 3 4 5 // addr为新的brk地址，成功返回0，失败返回-1 int brk(const void *addr); // incr为需要申请的内存大小，返回heap新的上界brk地址。若sbrk的参数为0，则返回原来的brk地址 void* sbrk (intptr_t incr); mmap() 和 munmap() 函数：映射磁盘文件到内存中或匿名映射（向映射区申请一块内存）\n1 2 3 4 5 6 7 // addr为映射区的开始地址，length为映射区的长度，prot为期望的内存保护标志， // flags指定映射对象的类型，fd为文件描述符，offset为文件映射的偏移量，通常设置为0， // 代表从文件最前方开始对应，offset必须是分页大小的整数倍 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); // munmap执行与mmap相反的操作，删除特定地址区域的对象映射 int munmap(void *addr, size_t length); 实现原理 malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。\n方式一：如果用户分配的内存 $\u0026lt;128 KB$，则通过 brk() 系统调用从堆分配内存；\n方式二：如果用户分配的内存 $\\geq128 KB$，则通过 mmap() 系统调用在文件/内存映射区域分配内存。\nbrk 是将 heap 的上界指针 brk 往高地址推，mmap 是在进程的虚拟地址空间中（堆和栈中间，称为内存/文件映射区域的地方）找一块空闲的虚拟内存。 这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。\nbrk 分配的内存需要等到高地址内存释放以后才能释放（这就是内存碎片产生的原因），当最高地址空间的空闲内存超过128K（可由 M_TRIM_THRESHOLD 选项调节）时，执行内存紧缩操作（trim）。 mmap 分配的内存可以单独释放。\nbrk和mmap 调用 free(A) 后 A 对应的虚拟内存和物理内存都没有释放，因为只有一个 brk 指针，如果往回推，那么 B 这块内存怎么办呢？\n当然 A 这块内存是可以重用的，如果这个时候再来一个 40KB 的请求，那么 malloc 很可能就使用 A 这块内存。\n进程调用 free(B) 以后，A 和 B 连接起来，变成一块 150KB 的空闲内存，于是内存紧缩。\nmalloc 采用了内存池的实现方式：先申请一大块内存，然后将内存分成不同大小的内存块，用户申请内存时，直接从内存池中选择一块相近的内存块即可。brk 分配内存时优先从内存池获取，失败的话走 brk 系统调用。细节参考：简书：glibc内存管理那些事儿\n既然堆内内存 brk 和 sbrk 不能直接释放，导致疑似“内存泄露”问题，为什么不全部使用 mmap 来分配，munmap 直接释放，而是仅仅对于大于 128K 的大块内存才使用 mmap？\n因为 brk 和 mmap 都是系统调用，频繁调用系统调用都比较消耗系统资源。使用 mmap 申请的空间，直接调用 munmap 是将空间真正释放了，而 brk 释放的空间，并不一定真正释放了，那些没有被真正释放的内存碎片可以被重复利用，再次访问该内存可能不需产生任何系统调用和缺页中断，这将大大降低 CPU 的消耗。\nmalloc 和 tcmalloc malloc 和 tcmalloc 都是内存分配库，主要的不同在于实现方式和效率。\nmalloc 是C标准库中的一部分，是系统提供的内存分配器。它的主要作用是管理进程虚拟内存空间，负责分配和释放内存资源。但是，由于多线程并发执行时需要加锁，所以它的性能并不是最优的。 tcmalloc 是 Google 开发的一个高性能、多线程的内存管理库，是 malloc 的替代品之一。tcmalloc 采用线程本地缓存技术（Thread-Caching Malloc，TCMalloc），避免了锁的竞争，从而在多线程环境下具有更好的性能表现。此外，tcmalloc 还会将未使用的页面设置为“dirty”状态，提高缓存命中率，进一步提升了其效率。 总的来说，tcmalloc 比 malloc 具有更高的性能和更好的可扩展性，在大型高并发的应用场景中使用更为适合。但是，tcmalloc 也相对较复杂，需要结合实际情况进行使用和优化。\n参考：内存优化总结:ptmalloc、tcmalloc和jemalloc、ptmalloc、tcmalloc与jemalloc对比分析\n内存管理可以分为三个层次，自底向上分别是：\n内核层 C运行时库层（glibc 层使用系统调用维护的内存管理算法） 应用程序层（应用程序从 glibc 动态分配内存后，根据应用程序本身的程序特性进行优化，比如使用引用计数 std::shared_ptr，内存池方式等） 现状 目前大部分服务端程序使用 glibc 提供的 malloc/free 系列函数，而 glibc 使用的 ptmalloc2 在性能上远远弱后于 google 的 tcmalloc 和 facebook 的 jemalloc。而且后两者只需要使用 LD_PRELOAD 环境变量启动程序即可，甚至并不需要重新编译。\nptmalloc2 ptmalloc2 即是我们当前使用的 glibc malloc 版本。\nptmalloc2 操作 heap 时，一般大内存采用 mmap，小内存使用 brk。\n🔰 主分配区和非主分配区\nptmalloc 的内存分配器中，为了解决多线程锁争夺问题，分为主分配区（main_area）和非主分配区（no_main_area）。\n每个进程有一个主分配区，也可以允许有多个非主分配区。 主分配区可以使用 brk 和 mmap 来分配内存，而非主分配区只能使用 mmap 来映射内存块（批发申请 HEAP_MAX_SIZE 大小的虚拟内存）。当用户向非主分配区请求分配内存时再切割成小块“零售” 出去，毕竟系统调用是相对低效的，直接从用户空间分配内存快多了。所以 ptmalloc 在必要的情况下才会调用 mmap 函数向操作系统申请虚拟内存。 非主分配区的数量一旦增加，则不会减少。 主分配区和非主分配区形成一个环形链表进行管理。 当某一线程需要调用 malloc 分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么 malloc 会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。\n在释放操作中，线程同样试图获得待释放内存块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行释放操作。\n🔰 chunk 内存块的基本组织单元\nptmalloc 通过 chunk 的数据结构来组织每个内存单元。当我们使用 malloc 分配得到一块内存的时候，这块内存就会通过 chunk 的形式被 glibc 管理起来。你可以把它想象成自己写内存池的时候的一个内存数据结构。chunk 的结构可以分为使用中的 chunk 和空闲的 chunk。\n空闲的 chunk 会被放置到空闲的链表 bins 上。当用户 malloc 申请内存的时候，会先去查找空闲链表 bins上是否有合适的内存。\n🔰 空闲链表 bins\n当用户使用 free 函数释放掉的内存，ptmalloc 并不会马上交还给操作系统，而是被 ptmalloc 本身的空闲链表 bins 管理起来了，这样当下次进程需要 malloc 一块内存的时候，ptmalloc 就会从空闲的 bins 上寻找一块合适大小的内存块分配给用户使用。这样的好处可以避免频繁的系统调用，降低内存分配的开销。\nptmalloc ptmalloc 一共维护了128个 bin。每个 bin 都维护了大小相近的双向链表的 chunk。通过上图这个 bins 的列表就能看出，当用户调用 malloc 的时候，能很快找到用户需要分配的内存大小是否在维护的 bin 上，如果在某一个 bin 上，就可以通过双向链表去查找合适的 chunk 内存块给用户使用。\nfast bins：fast bins 是 bins 的高速缓冲区，大约有10个定长队列。当用户释放一块不大于 max_fast（默认值64B）的 chunk 的时候，会默认会被放到 fast bins 上。当用户下次需要申请内存的时候首先会到 fast bins 上寻找是否有合适的 chunk。ptmalloc 会遍历 fast bin，看是否有合适的 chunk 需要合并到 bins 上。 unsorted bin：是 bins 的一个缓冲区。当用户释放的内存大于 max_fast 或者 fast bins 合并后的 chunk 都会进入 unsorted bin 上。当用户 malloc 的时候，先会到 unsorted bin 上查找是否有合适的 bin，如果没有合适的 bin，ptmalloc 会将 unsorted bin 上的 chunk 放入 bins 上，然后到 bins 上查找合适的空闲 chunk。 small bins 和 large bins：small bins 和 large bins 是真正用来放置 chunk 双向链表的。每个 bin 之间相差8个字节，并且通过上面的这个列表，可以快速定位到合适大小的空闲 chunk。前64个为 small bins 定长；后64个为 large bins，非定长。 Top chunk：并不是所有的 chunk 都会被放到 bins 上。top chunk 相当于分配区的顶部空闲内存，当 bins 上都不能满足内存分配要求的时候，就会来 top chunk 上分配。 mmaped chunk：当分配的内存非常大（大于分配阀值，默认128K）的时候，需要被 mmap 映射，则会放到 mmaped chunk 上，当释放 mmaped chunk 上的内存的时候会直接交还给操作系统。 ✏️ 内存分配 malloc() 的流程\nmalloc()的流程 获取分配区的锁，防止多线程冲突；\n计算出需要分配的内存的 chunk 实际大小；\n判断chunk的大小，如果小于 max_fast（64B），则取 fast bins 上去查询是否有适合的 chunk，如果有则分配结束；\nchunk 大小是否小于512B，如果是，则从 small bins 上去查找 chunk，如果有合适的，则分配结束；\n继续从 unsorted bins 上查找：\n如果 unsorted bins 上只有一个 chunk 并且大于待分配的 chunk，则进行切割，并且剩余的 chunk 继续扔回 unsorted bins；\n如果 unsorted bins 上有大小和待分配 chunk 相等的，则返回，并从 unsorted bins 删除；\n如果 unsorted bins 中的某一 chunk 大小属于 small bins 的范围，则放入 small bins 的头部；\n如果 unsorted bins 中的某一 chunk 大小属于 large bins 的范围，则找到合适的位置放入；\n从 large bins 中查找，找到链表头后，反向遍历此链表，直到找到第一个大小大于待分配的 chunk，然后进行切割，如果有余下的，则放入 unsorted bin 中去，分配则结束；\n如果搜索 fast bins 和其他 bins 都没有找到合适的 chunk，那么就需要操作 top chunk 来进行分配了（top chunk 相当于分配区的剩余内存空间）。判断 top chunk 大小是否满足所需 chunk 的大小，如果是，则从 top chunk 中分出一块来；\n如果 top chunk 也不能满足需求，则需要扩大 top chunk。主分区上，如果分配的内存小于分配阀值（默认128K），则直接使用 brk 分配一块内存；如果分配的内存大于分配阀值，则需要 mmap 来分配。\n非主分区上，则直接使用 mmap 来分配一块内存。通过 mmap 分配的内存，就会放入 mmaped chunk 上，mmaped chunk 上的内存会直接回收给操作系统。\n✏️ 内存释放 free() 的流程\n获取分配区的锁，保证线程安全；\n如果 free 的是空指针，则返回，什么都不做；\n判断当前 chunk 是否是 mmap 映射区域映射的内存，如果是，则直接 munmap 释放这块内存。已使用 chunk 的数据结构中，有对应的标识判断是否是 mmap 映射的内存；\n判断 chunk 是否与 top chunk 相邻，如果相邻，则直接和 top chunk 合并（和 top chunk 相邻相当于和分配区中的空闲内存块相邻），转到步骤8；\n如果 chunk 的大小大于 max_fast（64B），则放入 unsorted bin，并且检查是否有合并，有合并情况并且和 top chunk 相邻，则转到步骤8；没有合并情况则 free；\n如果 chunk 的大小小于 max_fast（64B），则直接放入 fast bin，fast bin 并没有改变 chunk 的状态。没有合并情况，则 free；有合并情况，转到步骤7；\n在 fast bin，如果当前 chunk 的下一个 chunk 也是空闲的，则将这两个 chunk 合并，放入 unsorted bin 上面。合并后的大小如果大于64KB，会触发进行 fast bins 的合并操作，fast bins 中的 chunk 将被遍历，并与相邻的空闲 chunk 进行合并，合并后的 chunk 会被放到 unsorted bin 中，fast bin 会变为空。合并后的 chunk 和 top chunk 相邻，则会合并到 top chunk 中。转到步骤8；\n判断 top chunk 的大小是否大于 mmap 收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还 top chunk 中的一部分给操作系统。free 结束。\n✏️ ptmalloc 的问题\nptmalloc 的主要问题其实是内存浪费、内存碎片、以及加锁导致的性能问题。\n内存浪费：\n每个 chunk 本身至少8字节的开销很大；\n后分配的内存先释放，可能无法及时归还系统。因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放，top chunk 以下的 chunk 都无法释放；\n内存不能在线程间移动，多线程使用内存不均衡将导致内存浪费。\n内存碎片：不定期分配长生命周期的内存容易造成内存碎片，不利于回收。\n加锁导致的性能问题：加锁耗时，无论当前分区有无耗时，在内存分配和释放时，会首先加锁。\ntcmalloc tcmalloc 是 Google 开源的一个内存管理库， 作为 glibc malloc 的替代品。目前已经在 chrome、safari 等知名软件中运用。\n🔰 对象分配\ntcmalloc 为每个线程分配了一个线程本地 ThreadCache，小内存从 ThreadCache 分配，此外还有个中央堆（CentralCache），ThreadCache 不够用的时候，会从 CentralCache中 获取空间放到 ThreadCache 中。 小对象（$\\leq32KB$）从 ThreadCache 分配，大对象从 CentralCache 分配。大对象分配的空间都是4K页面对齐的，多个 pages 也能切割成多个小对象划分到 ThreadCache 中。 ✏️ tcmalloc的优势\n小内存可以在 ThreadCache 中不加锁分配（加锁的代价大约100ns） 大内存可以直接按照大小分配不需要再像 ptmalloc 一样进行查找 大内存加锁使用更高效的自旋锁 减少了内存碎片 内存对齐 什么事内存对齐？ 现代计算机中内存空间都是按照字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。\n为什么内存对齐？ 主要是由于 CPU 的访问内存的特性决定，CPU 访问内存时并不是以字节为单位来读取内存，而是以机器字长为单位，实际机器字长由 CPU 数据总线宽度决定的。实际 CPU 运行时，每一次控制内存读写信号发生时，CPU 可以从内存中读取数据总线宽度的数据，并将其写入到 CPU 的通用寄存器中。内存对齐的主要目的是为了减少 CPU 访问内存的次数。假设读取8个字节的数据，按照每次读取4个字节的速度，则8个字节需要 CPU 耗费2次读取操作。CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数。\n怎么使用内存对齐？ 我们可以用#progma pack(x)指定结构体以x为单位进行对齐。一般情况下使用方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #pragma pack(push) /* push current alignment to stack */ #pragma pack(1) /* set alignment to 1 byte boundary */ struct MyPackedData { char Data1; // 1 byte long Data2; // 8 byte(64位环境) char Data3; // 1 byte }; #pragma pack(pop) /* restore original alignment from stack */ int main() { cout \u0026lt;\u0026lt; alignof(MyPackedData) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; sizeof(MyPackedData) \u0026lt;\u0026lt; endl; // 10 return 0; } C++11之后提供了alignas关键字，允许往更大的字节数去对齐（有的平台不支持未对齐内存访问，alignas 的目的是允许你往更大的字节数去对齐，比如 char 对齐到32位供 SIMD load）。\n即 pack 是变小，alignas 是变大，用法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct alignas(1) Point // 使用g++能正常运行，但是在CLion中会报错，因为这样做是不合规范（ill-formed）的 { int a; char b; }p; cout \u0026lt;\u0026lt; alignof(p) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt; endl; // 8 #pragma pack(push) #pragma pack(1) struct Point2 { int a; char b; }p2; #pragma pop(pop) cout \u0026lt;\u0026lt; alignof(p2) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; sizeof(p2) \u0026lt;\u0026lt; endl; // 4 用户态与内核态 用户态/内核态的概念 CPU 指令可以直接操作硬件，而对于硬件的操作是非常复杂的，出问题的几率相当大，所以操作系统内核直接屏蔽了个人开发者对于硬件操作的可能。因为这个需求，硬件设备商直接提供了硬件级别的支持，做法就是对 CPU 指令设置了权限，不同级别的权限可以使用的 CPU 指令是有限制的。\n以 Intel CPU 为例，CPU 指令操作的权限划为4级：ring 0、ring 1、ring 2、ring 3。其中ring 0权限最高，可以使用所有 CPU 指令，ring 3 权限最低，仅能使用常规 CPU 指令，不能使用访问硬件资源的指令，比如 I/O读写、网卡访问、申请内存等。\nLinux 系统内核采用了：ring 0 和 ring 3 这2个权限\nring 0 被叫做 内核态，完全在操作系统内核中运行，由专门的内核线程执行其任务； ring 3 被叫做 用户态，在应用程序中运行，由用户线程执行其任务。 切换方式 从用户态到内核态切换可以通过三种方式，或者说会导致从用户态切换到内核态的操作：\n系统调用：系统调用本身就是中断，属于软件中断，跟硬件中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。比如我们使用库函数 fopen 打开文件，就会触发 open 系统调用。 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中。 外围设备中断：硬件中断，外围设备完成用户请求的操作之后，会向 CPU 发出中断信号，这时 CPU 会转去处理对应的中断处理程序。 切换过程 当发生用户态到内核态的切换时，会发生如下过程（本质上是从“用户程序”切换到“内核程序”）\n设置处理器至内核态；\n保存当前程序的寄存器（栈指针、程序计数器、通用寄存器）；\n将栈指针设置指向内核栈地址；\n执行中断处理程序；\n恢复之前保存的寄存器，从中断处理程序返回。\n具体流程参考：中断（系统调用）的具体过程\n中断（系统调用）的具体过程 总结： 用户运行库函数（系统调用的封装），函数里面其实是执行的 int 0x80 指令。系统调用先把系统调用号保存在 eax 寄存器中，然后执行 int 0x80 指令。int 0x80 指令先进行切换堆栈（找到进程的堆栈，将寄存器值压入到内核栈中，将 esp，ss 设置成对应内核栈的值），查找相应中断向量的中断处理程序(system_call)并调用，随后 system_call 从系统调用表中找到相应的系统调用进行调用，调用结束后从 system_call 中返回。\n中断一般有两个属性，中断号和中断处理程序（ISR，Interrupt Service Routine）。在内核中，有一个数组称为中断向量表，包含了中断号及其对应中断处理程序的指针。中断到来时，CPU 暂停当前执行的代码，根据中断的中断号，在中断向量表中找到对应的中断处理程序，并调用它。中断处理程序执行完成之后，CPU 会继续执行之前的代码。\n由于中断号是有限的，操作系统不舍得每一个系统调用对应一个中断号，而更倾向于用一个或少数几个中断号来对应所有的系统调用。Linux 则使用 int 0x80 来触发所有系统调用。每个系统调用对应一份系统调用号，这个系统调用号在执行 int 0x80 指令前会放置在某个固定的寄存器里（eax)，对应的中断代码会取得这个系统调用号，并且调用正确的函数。\n系统调用的详细过程 触发中断 用户程序在代码中调用系统调用，执行 int 指令前将系统调用号放入 eax 寄存器中，执行 int 0x80 指令（int 指令最终执行的函数是 system_call，该函数验证系统调用号的有效性，查找系统调用函数并执行，最后通过 itret 指令从中断处理程序返回）。\n切换堆栈（此步在 int 指令中完成） 在实际执行 0x80 号中断向量所对应的中断处理程序（system_call）之前，CPU 首先要进行堆栈切换，即从用户态切换到内核态。所谓的当前栈，指得是 esp（栈指针）的值所在的栈空间。如果 esp 的值位于用户栈的范围内，那么程序的当前栈就是用户栈，反之亦然。此外，寄存器 ss 的值还应该指向当前栈所在的页。\n所以，将当前栈由用户栈切换为内核栈（用户态切换到内核态）的实际行为就是：保存当前的 esp，ss 的值（保证存在内核栈上，int 指令发送后自动地由硬件完成），并将 esp，ss 的值设置为内核栈的相应值\n当 0x80 号中断发生的时候，cpu 除了切入内核态之外，还会自动完成下列几件事：\n（1）找到当前进程的内核栈（每一个进程都有自己的内核栈）\n（2）在内核栈中一次压入用户态的寄存器 ss、esp、eflags、cs、eip\n而当内核从系统调用返回的时候，须要调用 iret 指令来回到用户态，iret 指令则会从内核栈里弹出寄存器 ss、esp、eflags、cs、eip 的值，使得栈恢复到用户态的状态。\n中断时内核栈和用户栈的切换 中断处理程序 在 int 指令切换内核栈之后，程序就切换到了中断向量表中的 0x80 号中断处理程序。Linux 中 0x80 向量对应的中断处理程序是 system_call。\nsystem_call 中断服务程序首先检查系统调用号的有效性，再根据 eax 寄存器存储的系统调用号从系统调用表上找到相应的系统调用并调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // system_call的开头部分 ...... SAVE_ALL // 保存寄存器的值到栈中，以免被覆盖 ...... cmpl $(nr_syscalls), %eax // 比较eax寄存器中的值和系统调用号大1的值（验证系统调用号的有效性） jae syscall_badsys\t// 如果系统调用无效，指向syscall_badsys // 如果系统调用号有效，则会执行以下代码 syscall_call: call *sys_call_table(0, %eax, 4) // 查找中断服务程序并执行， sys_call_table其实就是系统调用表 ..... RESTORE_REGS // 恢复之前保存的寄存器 ...... iret // 从中断程序返回 恢复之前保存的寄存器，从中断处理程序返回，从内核态切换回用户态 缺页中断 在操作系统中，程序执行时需要访问的内存在虚拟内存中，不在物理内存中，此时就会发生缺页中断（该情况为硬件页缺失）。\n缺页中断的分类 软性页缺失：指页缺失发生时，相关的页已经被加载进内存，但是没有向 MMU（内存管理单元）注册的情况。操作系统只需要在 MMU 中注册相关页对应的物理地址即可。 硬性页缺失：硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。 无效页缺失：当程序访问的虚拟地址是不存在于虚拟地址空间内的时候，则发生无效页缺失。\n查看进程发生缺页中断的次数 ps -o majflt,minflt -C \u0026lt;program_name\u0026gt;\nps -o majflt,minflt -p \u0026lt;pid\u0026gt; majflt 代表 major fault，中文名叫大错误，minflt 代表 minor fault，中文名叫小错误。 majflt 表示需要读写磁盘，可能是内存对应页面在磁盘中需要load到物理内存中，也可能是此时物理内存不足，需要淘汰部分物理页面至磁盘中。 这两个数值表示一个进程自启动以来所发生的缺页中断的次数。\n缺页中断过程 当程序访问一个虚拟地址时，操作系统会检查该地址是否被映射到物理内存中，如果没有，则触发缺页中断：\n缺页中断会暂停程序执行，将控制权交给操作系统内核（进程会陷入内核态），保护程序现场，以免被操作系统破坏。\n内核会检查发生缺页中断的虚拟地址是否有效：\n如果虚拟地址有效，操作系统将会分配一个空闲物理页面，并把未被读取的数据从磁盘拷贝到物理内存所分配的页面中（没有空闲物理页面会触发页面置换算法），并更新页表信息。 如果虚拟地址无效，则操作系统会向进程发出一个信号或杀掉该进程。 当操作系统处理完缺页中断后，程序会恢复至发生缺页中断指令以前的状态，程序计数器重新指向这条指令。 缺页中断和缺页异常 缺页中断是指当程序访问一个虚拟内存地址时，对应的物理内存页不在主存中，需要从磁盘中加载到主存中，此时 CPU 就会发出一个中断请求，操作系统会响应中断请求，将对应的物理页加载到主存中，并重新执行产生缺页中断的指令。缺页中断是一种同步事件，也就是说，程序需要等待操作系统完成页的加载操作后才能继续执行。\n缺页异常是指当程序访问一个虚拟内存地址时，对应的物理内存页不在主存中，需要从磁盘中加载到主存中，但是此时 CPU 不会发出中断请求，而是将控制权交给操作系统，让操作系统处理缺页异常。缺页异常是一种异步事件，也就是说，程序不需要等待操作系统完成页的加载操作就可以继续执行。\n因此，缺页中断和缺页异常的主要区别在于它们是同步事件还是异步事件。缺页中断是同步事件，程序需要等待操作系统完成页的加载操作后才能继续执行；而缺页异常是异步事件，程序不需要等待操作系统完成页的加载操作就可以继续执行。\n虚表/虚表指针 为了实现 C++ 的多态，C++ 使用了一种动态绑定的技术，这个技术的核心是虚函数表。\n虚表 每个包含了虚函数的类都包含一个虚表； 一个类继承了包含虚函数的基类，那么这个类也会拥有自己的虚表； 虚表是一个指针数组，其元素是虚函数的指针，即虚表中每个元素对应一个虚函数的函数指针； 虚函数的的调用都需要经过虚表，普通函数即非虚函数，其调用并不需要经过虚表； 虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段； 虚表是属于类的，而不属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。 虚表指针 如有类中包含虚函数，编译器会自动在类中添加一个指针：*__vptr，用来指向该类的虚表； 类的对象在创建时便拥有虚表指针，且这个指针的值会自动被设置为指向类的唯一虚表。 类A的定义如下：\n1 2 3 4 5 6 7 8 9 class A { public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int m_data1, m_data2; }; 因为类A中存在（一个或多个）虚函数，编译器会自动给类A加上一个虚表指针（占8字节空间），所以sizeof(A)=16。 类A的虚表和虚表指针（__vptr）关系如下：\n虚表和虚表指针 多态相关 一个类的基类如果包含虚函数，那个这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表； 一旦继承类重写了基类的某个虚函数，那么它的虚表项也会同步更新，指向继承类重写的函数，否则指向它基类的同名函数。 通过基类的指针调用派生类中的函数称为（运行时）多态，经过虚表调用虚函数的过程称为动态绑定； 虚表和虚表指针的创建时机： 在编译的过程中编译器就为含有虚函数的类创建了虚表，并且编译器会在构造函数中插入一段代码，这段代码用来给虚指针赋值。因此虚表是在编译的过程中创建。 由于虚指针是基于对象的，所以对象在实例化的时候，虚指针就会创建，所以虚指针是在运行时创建。 此外，编译器规定一个模版函数不能为虚函数。因为模版机制需要在编译期间识别模版支持类型，对于每一种类型我们都要生成对应类型的函数体。如果这个模版函数为虚函数，我们不知道这个模版函数被生成了多少份对应类型的虚函数，也就不好确定虚表的大小，所以编译器禁止这一行为。\n更详细的内容参考：知乎：C++中虚函数、虚继承内存模型\n","permalink":"https://kdjlyy.github.io/posts/tech/cs-basic-os/","summary":"内存模型, Linux用户空间内存分布, 程序内存空间, 虚拟内存, new, delete, malloc, free, brk, mmap, ptmalloc, tcmalloc, 内存对敌, 用户态, 内核态, 中断, 系统调用, 缺页中断, 虚表, 虚表指针","title":"计算机基础知识总结（系统篇）"},{"content":"成员变量初始化 构造函数内部初始化和初始化列表 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。\n对于内置类型，如int, float等，使用初始化列表和在构造函数体内初始化差别不大； 对于类类型来说，使用初始化列表会减少调用默认构造函数的次数，更加高效。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;A()\u0026#34; \u0026lt;\u0026lt; endl; } A(int _a) { a = _a; cout \u0026lt;\u0026lt; \u0026#34;A(_a)\u0026#34; \u0026lt;\u0026lt; endl; } private: int a; }; class B { public: B() { cout \u0026lt;\u0026lt; \u0026#34;B()\u0026#34; \u0026lt;\u0026lt; endl; } B(int _b) : b(_b), m_a(_b) { // 初始化列表初始化 // b = _b, m_a = A(_b); // 构造函数内部赋值操作 cout \u0026lt;\u0026lt; \u0026#34;B(_b)\u0026#34; \u0026lt;\u0026lt; endl; } private: int b; A m_a; }; int main(int argc, char** argv) { B b(100); } 这段代码输出：\n1 2 A(_a) B(_b) 如果不使用初始化列表，使用17行构造函数内部赋值的方式，会输出：\n1 2 3 A() A(_a) B(_b) 除了性能问题之外，有时候初始化列表是不可或缺的，以下几种情况必须使用初始化列表：\n类的const成员\n引用类型\nconst对象或引用只能初始化但是不能赋值，构造函数的函数体内只能做赋值而不是初始化。因此初始化const对象或引用的唯一机会是构造函数函数体之前的初始化列表中。\n没有默认构造函数的类类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class A { public: A(int a): i(a) {} int i; }; class B { public: A a ; B(const A\u0026amp; a1) { a = a1; // error: 类A不存在默认构造函数 } }; class C: public A { public: C(int _x): x(_x) {} // error: 类A不存在默认构造函数 private: int x; } 以上代码无法通过编译，因为B的构造函数中a=a1这一行会先调用A的默认构造函数来初始化a1，由于A没有默认的构造函数，所以无法执行，故而编译错误。\n如果基类没有默认构造函数，派生类必须在其初始化列表中显示调用基类的构造函数。\n构造函数调用顺序 调用基类构造函数，调用顺序按照他们的继承时声明的顺序。 调用内嵌成员对象的构造函数，调用顺序按照他们在类中声明的顺序。 调用派生类自己的构造函数体中的内容。 析构函数的调用顺序相反。\n更详细的：构造函数的执行可以分成两个阶段，初始化阶段和计算阶段，初始化阶段先于计算阶段。\n初始化阶段：所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。 计算阶段：一般用于执行构造函数体内的赋值操作。 所以，初始化列表总是先于构造函数体执行：基类初始化列表 → 基类的构造函数 → 派生类初始化列表 → 派生类的构造函数。\n成员变量初始化顺序 成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class A { private: int n1; int n2; public: A(): n2(0), n1(n2+1) {} void Print(){ cout \u0026lt;\u0026lt; \u0026#34;n1: \u0026#34; \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#34;, n2: \u0026#34; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt;endl; } }; int main() { A a; a.Print(); // 输出是：`n1: 18749281, n2: 0`，而不是`n1: 1, n2: 0` return 0; } const和constexpr constexpr关键字是C++11新增的，其作用包括：\n定义编译期常量[编译期常量]； 定义常量表达式函数[常量表达式函数]； 定义编译期常量对象[编译期常量对象]。 常量分为编译期常量、运行期常量。 编译期常量在编译阶段就可以确定其值，并将其结果展开到使用的地方，一般存放在rodata段。 运行期常量本质上是只读的变量（存放在栈区），编译时无法确定其值；运行时，无法修改其值。\nconst 可以定义编译期常量，也可以定义运行期常量； constexpr 只能定义编译期常量。 1 2 3 4 5 6 7 const int a = 10; // 编译期常量，存放在静态存储区的rodata段 int main() { int b = 20; // 栈 const int c = b; // 栈（运行期常量） // constexpr int c = b; Error: 因为b是一个普通变量，必须到运行期才能确定，constexpr无法修饰运行期常量。 } 普通函数必须在运行时才能执行，进而计算出结果。而常量表达式函数要求函数在编译期就计算出结果，运行时直接使用结果。也就是说将函数的执行从运行阶段转移到编译阶段，提升程序运行效率。 只需要在函数返回值类型前面加上constexpr关键字即可定义常量表达式函数，我们必须使用constexpr修饰的编译期常量来保存常量表达式函数的结果，否则常量表达式函数仍然会在运行期执行。\n1 2 3 4 5 6 7 8 constexpr int my_sum(int n) { if (n == 1) return 1; return n + my_sum(n - 1); } void test() { constexpr int a = my_sum(3); } 编译期常量对象的任何计算都在编译期完成。定义编译期常量对象，有以下几点要求：\n构造函数使用constexpr修饰，必须使用初始化列表对成员进行初始化； 对象调用的成员函数必须使用constexpr修饰。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Box { public: // 构造函数使用constexptr修饰，并且使用初始化列表对成员进行初始化。这就保证了对象成员m_l、m_w、m_h在编译期确定其值。 constexpr Box(int l, int w, int h) : m_l(l), m_w(w), m_h(h) {} // get_volume函数被定义为了常量表达式成员函数，调用该函数则会在编译阶段计算出结果。 constexpr int get_volume() const { return m_l * m_w * m_h; } // get_sum函数则是普通函数，该函数必须声明为const函数，否则无法被常量对象调用 int get_sum() const { return (m_l + m_w + m_h); } public: int m_l, m_w, m_h; }; void test() { constexpr Box box(10, 20, 30); // 程序编译期间调用常量表达式构造函数 constexpr int volume = box.get_volume(); // 在编译期计算出函数的执行结果，并赋值给编译期常量volume int my_sum = box.get_sum(); // 在运行期进行执行 } 单例模式 单例模式是一种设计模式，它确保一个类只有一个实例，并且提供一个全局访问点来访问它。 单例模式的实现一般需要将构造函数、析构函数私有化，禁用拷贝构造函数和赋值运算符，将成员变量和成员函数都设置成静态类型。\n懒汉单例模式实现 最简单的懒汉模式（在全局访问入口中声明静态变量。局部静态变量在C++11后也是线程安全的） 1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton { private: Singleton(); ~Singleton(); Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton* getInstance() { static Singleton instance; return \u0026amp;instance; } }; 加锁版本的懒汉单例模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Singleton { private: Singleton(); ~Singleton(); Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* instance; static pthread_mutex_t mutex; public: static Singleton* getInstance() { if (instance == nullptr) { pthread_mutex_lock(\u0026amp;mutex); instance = new Singleton(); pthread_mutex_unlock(\u0026amp;mutex); } return instance; } }; Singleton* Singleton::instance = nullptr; pthread_mutex_t Singleton::mutex = PTHREAD_MUTEX_INITIALIZER; 饿汉单例模式实现 饿汉单例模式天生线程安全，因为在main函数前已经初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton { private: Singleton(); ~Singleton(); Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* instance; public: static Singleton* getInstance() { return instance; } }; Singleton* Singleton::instance = new Singleton(); ","permalink":"https://kdjlyy.github.io/posts/tech/cs-basic-grammar/","summary":"成员变量初始化 构造函数内部初始化和初始化列表 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。 对于内置类型，如int, float等，使用初始化列表和在构","title":"计算机基础知识总结（语法篇）"},{"content":" 常见的Markdown语法，例如引用、标题、段落、无序列表、有序列表等不做讨论。\n参考：Sulv’s Blog、荷戟独彷徨、Memory、3rd\u0026rsquo;s Blog、Doit。\n字体种类 在Markdown中，使用\u0026lt;font\u0026gt;标签的face属性修改文字字体：\n1 2 3 \u0026lt;font face=\u0026#39;SimHei\u0026#39;\u0026gt;这是黑体\u0026lt;/font\u0026gt; \u0026lt;font face=\u0026#39;KaiTi\u0026#39;\u0026gt;这是楷体\u0026lt;/font\u0026gt; \u0026lt;font face=\u0026#39;Fangsong_GB2312\u0026#39;\u0026gt;这是仿宋_GB2312字体\u0026lt;/font\u0026gt; 这是黑体 这是楷体 这是仿宋_GB2312字体\n字体名称 字体写法 黑体 SimHei 宋体 SimSun 新宋体 NSimSun 仿宋 FangSong 楷体 KaiTi 仿宋_GB2312 FangSong_GB2312 楷体_GB2312 KaiTi_GB2312 微软雅黑 Microsoft YaHei 落霞文楷 LXGW WenKai 落霞文楷 Lite LXGW WenKai Lite 落霞文楷 Screen LXGW WenKai Screen 落霞文楷 TC LXGW WenKai TC 字号 1 2 3 4 5 6 7 \u0026lt;font size=\u0026#34;1\u0026#34;\u0026gt;这是1号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;2\u0026#34;\u0026gt;这是2号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;3\u0026#34;\u0026gt;这是3号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;4\u0026#34;\u0026gt;这是4号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;5\u0026#34;\u0026gt;这是5号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;6\u0026#34;\u0026gt;这是6号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;7\u0026#34;\u0026gt;这是7号字体\u0026lt;/font\u0026gt; 这是1号字体\n这是2号字体 这是3号字体 这是4号字体 这是5号字体 这是6号字体 这是7号字体 字体颜色 1 2 3 4 \u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;这是红色字体\u0026lt;/font\u0026gt; \u0026lt;font color=\u0026#39;rgb(200, 100, 100)\u0026#39;\u0026gt;这是rgb(200, 100, 100)颜色字体\u0026lt;/font\u0026gt; \u0026lt;font color=\u0026#39;#FF00BB\u0026#39;\u0026gt;这是#FF00BB颜色字体\u0026lt;/font\u0026gt; \u0026lt;font style=\u0026#34;background: linear-gradient(to right, #ff1616, #36c945, #10a5ce, #0f0096, #a51eff, #ff1616);\u0026#34;\u0026gt;这是7色渐变颜色\u0026lt;/font\u0026gt; 这是红色字体 这是rgb(200, 100, 100)颜色字体 这是#FF00BB颜色字体\n这是7色渐变颜色\n待办列表 使用-[]表示一项待办，当完成待办后给中括号中添加x（不区分大小写，注意空格不可省略）即可，例如：\n1 2 3 - [x] 吃饭 - [x] 睡觉 - [ ] 写作业 吃饭 睡觉 写作业 脚注和页内跳转 脚注 1 2 3 这是一个简单的脚注[^1]，这是另一个脚注[^bignote]。 [^1]:这是第一个脚注 [^bignote]:这是第二脚注 这是一个简单的脚注1，这是另一个脚注2。\n页内跳转 1 2 3 4 5 6 7 // 1. 首先定义一个锚点： \u0026lt;span id=\u0026#34;jump\u0026#34;\u0026gt;**\u0026lt;u\u0026gt;《塞尔达传说 王国之泪》\u0026lt;/u\u0026gt;**\u0026lt;/span\u0026gt;（日语：ゼルダの伝説 ティアーズ オブ ザ キングダム，英语：The Legend of Zelda: Tears of the Kingdom）是一款由任天堂企划制作本部开发，任天堂发行的一款开放世界动作冒险游戏。本作为2017年发售的《塞尔达传说 旷野之息》的续作，也是塞尔达传说系列的第二十部作品，于2023年5月12日在任天堂Switch上发售。 // 2. 用markdown的语法写超链 点击查看[王国之泪的介绍](#jump) // 3. 点击超链文字就可以定位到跳转内容了 点击查看王国之泪的介绍\n《塞尔达传说 王国之泪》（日语：ゼルダの伝説 ティアーズ オブ ザ キングダム，英语：The Legend of Zelda: Tears of the Kingdom）是一款由任天堂企划制作本部开发，任天堂发行的一款开放世界动作冒险游戏。本作为2017年发售的《塞尔达传说 旷野之息》的续作，也是塞尔达传说系列的第二十部作品，于2023年5月12日在任天堂Switch上发售。\n另外，也可以用上标的方式进行页内跳转：\n1 王国之泪\u0026lt;sup\u0026gt;[[塞尔达传说 王国之泪]](#jump)\u0026lt;/sup\u0026gt;是什么游戏？ 王国之泪[塞尔达传说 王国之泪]是什么游戏？\n鼠标悬浮效果 1 \u0026lt;abbr title=\u0026#34;🙃🙃🙃\u0026#34;\u0026gt;鼠标悬浮这里\u0026lt;/abbr\u0026gt;可以看到详细的解释。 鼠标悬浮这里 可以看到详细的解释。\n自定义shortcodes Hugo博客通过简码方式插入pdf、bilibili以及博客文章内链等功能。\n为了防止被识别生效，调用样式均表示为{.{\u0026lt; xxx \u0026gt;}}，实际使用时去掉大括号中间的.即可。\n插入pdf 1 {.{\u0026lt; ppt src=\u0026#34;https://www.africau.edu/images/default/sample.pdf\u0026#34; \u0026gt;}} 插入bilibili视频 1 2 {.{\u0026lt; bilibili BV1WZ4y1a7MF \u0026gt;}} # 如果有集数（默认第一集），例如要播放第5集，则这样使用：{.{\u0026lt; bilibili BV1WZ4y1a7MF 5 \u0026gt;}} \u003c!DOCTYPE HTML\u003e 插入博客文章内链 1 2 {.{\u0026lt; innerlink src=\u0026#34;posts/tech/cs-basic-grammar.md\u0026#34; \u0026gt;}} # 卡片获取的文章长度默认是70，需要在config.yaml配置文件添加 summaryLength: 90，即设置为90 计算机基础知识总结（语法篇） 日期: 2023-05-09 \u0026nbsp; 标签: #C\u0026#43;\u0026#43;\u0026nbsp; #基础知识\u0026nbsp; 成员变量初始化 构造函数内部初始化和初始化列表 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。 对于内置类型，如int, float等，使用初始化列表和在构 ...... 代码折叠 1 2 3 4 5 6 7 8 9 {.{% code %}} ```cpp #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } ``` {.{% /code %}} 代码 1 2 3 4 5 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 文字位置 1 2 3 {.{\u0026lt; align left \u0026#34;文字居左\u0026#34; \u0026gt;}} {.{\u0026lt; align center \u0026#34;文字居中\u0026#34; \u0026gt;}} {.{\u0026lt; align right \u0026#34;文字居中\u0026#34; \u0026gt;}} 文字居左\n文字居中\n文字居中\n图片 figure标签是PaperMod主题自带的\n1 2 {.{\u0026lt; figure src=\u0026#34;https://kdjlyy.github.io/img/logo.ico\u0026#34; caption=\u0026#34;图片描述\u0026#34; width=\u0026#34;50%\u0026#34; height=\u0026#34;50%\u0026#34; align=\u0026#34;center\u0026#34; \u0026gt;}} {.{\u0026lt; figure src=\u0026#34;https://kdjlyy.github.io/img/logo.ico\u0026#34; title=\u0026#34;xxx\u0026#34; caption=\u0026#34;图片描述\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34; \u0026gt;}} 图片描述\n或者：\n1 2 3 4 \u0026lt;div style=\u0026#34;text-align:center;\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;display: block; margin: 0 auto;\u0026#34; src=\u0026#34;\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; \u0026gt; \u0026lt;span style=\u0026#34;font-size: 14px; color: grey;\u0026#34;\u0026gt;图片描述\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; 头像 Github卡片 1 {.{\u0026lt; github title=\u0026#34;kdjlyy/fastRPC\u0026#34; \u0026gt;}} Mermaid作图 1 2 3 4 5 6 7 8 \u0026lt;div align=center\u0026gt; \u0026lt;!-- 可以用html代码包裹该代码实现居中或其他排版 --\u0026gt; {.{\u0026lt;mermaid\u0026gt;}} flowchart LR a --\u0026gt; b \u0026amp; c --\u0026gt; d {.{\u0026lt;/mermaid\u0026gt;}} \u0026lt;/div\u0026gt; flowchart LR a --\u003e b \u0026 c --\u003e d 流程图 代码 1 2 3 4 5 6 {.{\u0026lt; mermaid \u0026gt;}}graph LR; A[Hard edge] --\u0026gt;|Link text| B(Round edge) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result one] C --\u0026gt;|Two| E[Result two] {.{\u0026lt; /mermaid \u0026gt;}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] 时序图 代码 1 2 3 4 5 6 7 8 9 10 11 12 {.{\u0026lt; mermaid \u0026gt;}}sequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! {.{\u0026lt; /mermaid \u0026gt;}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! 甘特图 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { {\u0026lt; mermaid \u0026gt;}}gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d { {\u0026lt; /mermaid \u0026gt;}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d 类图 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { {\u0026lt; mermaid \u0026gt;}}classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u0026lt;--\u0026gt; C2: Cool label { {\u0026lt; /mermaid \u0026gt;}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label 状态图 代码 1 2 3 4 5 6 7 8 {.{\u0026lt; mermaid \u0026gt;}}stateDiagram [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] {.{\u0026lt; /mermaid \u0026gt;}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] Git图 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 { {\u0026lt; mermaid \u0026gt;}} gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\u0026#34;ash\u0026#34; tag:\u0026#34;abc\u0026#34; branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release { {\u0026lt; /mermaid \u0026gt;}} gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\"ash\" tag:\"abc\" branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release 饼图 代码 1 2 3 4 5 6 7 \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; pie \u0026#34;Dogs\u0026#34; : 386 \u0026#34;Cats\u0026#34; : 85 \u0026#34;Rats\u0026#34; : 15 \u0026lt;/div\u0026gt; pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 Echarts作图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;echarts\u0026#34; style=\u0026#34;width: 600px;height:400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/echarts/5.1.1/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var myChart = echarts.init(document.getElementById(\u0026#39;echarts\u0026#39;)); myChart.setOption({ title: { text: \u0026#39;ECharts 示例\u0026#39; }, tooltip: {}, xAxis: { data: [\u0026#39;周一\u0026#39;, \u0026#39;周二\u0026#39;, \u0026#39;周三\u0026#39;, \u0026#39;周四\u0026#39;, \u0026#39;周五\u0026#39;, \u0026#39;周六\u0026#39;, \u0026#39;周日\u0026#39;] }, yAxis: {}, series: [{ name: \u0026#39;销量\u0026#39;, type: \u0026#39;bar\u0026#39;, data: [5, 20, 36, 10, 10, 20, 5] }] }); \u0026lt;/script\u0026gt; 其他 上标和下标 1 2 3 H\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;O C\u0026lt;sub\u0026gt;6\u0026lt;/sub\u0026gt;H\u0026lt;sub\u0026gt;12\u0026lt;/sub\u0026gt;O\u0026lt;sub\u0026gt;6\u0026lt;/sub\u0026gt; X\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; + Y\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; = Z\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; H2O\nC6H12O6 Xn + Yn = Zn 公式 1 $$0.414213562373095048\\approx6\\*16^{-1}+a\\*16^{-2}+0\\*16^{-3}+\\cdots$$ $$0.414213562373095048\\approx6*16^{-1}+a*16^{-2}+0*16^{-3}+\\cdots$$\n高亮 1 \u0026lt;mark\u0026gt;高亮标记语言\u0026lt;/mark\u0026gt;显示段落中的重要文字部分。 高亮标记语言显示段落中的重要文字部分。\n这是第一个脚注\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n这是第二个脚注\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://kdjlyy.github.io/posts/tech/markdown-note/","summary":"主要展示 PaperMod 主题中 Markdown 语法的页面效果","title":"PaperMod主题Markdown示例"}]