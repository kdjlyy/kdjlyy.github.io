[{"content":"Linux用户空间内存分布 程序内存在地址空间中的分布情况称为内存模型。\n对于32位环境，理论上程序可以拥有4GB的虚拟地址空间，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间。\nLinux默认将高地址的1GB空间分配给内核。也就是说，应用程序只能使用剩下3GB的地址空间，称为用户空间。\nLinux用户空间内存分布 内存分区 说明 text段（程序代码 区） 存放已编译程序的机器代码，只读。 rodata段（常量区） 存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。 data段（全局数据区的已初始化部分） 存放已经初始化的全局变量和静态变量等，这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。 bss段（全局数据区的未初始化部分） 存放未初始化的全局变量和静态变量等。 heap（堆区） 一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。 文件/内存映射区（动态链接库） 用于在程序运行期间加载和卸载动态链接库。例如使用mmap()创建内存映射区时，就是在这里申请的内存空间。 stack（栈区） 存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。 虚拟内存 物理内存是实际的物理空间，即直接映射到硬件RAM的物理内存资源。\n虚拟内存是逻辑上的地址空间，它通过将物理内存和硬盘空间组合使用，从逻辑上扩展了物理内存的大小，从而让程序获得更多的可用内存。\n为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个页（Linux下页大小为4KB，即4096字节）。而物理内存则被分成相同大小的页面帧，程序的页被映射到物理内存对应的帧（但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中）。当程序访问到不在物理内存中的页时，发生缺页中断，将缺失的页装入物理内存并重新执行失败的指令。\n从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生16位地址，那么一个程序的地址空间范围是0~64K。该计算机只有32KB的物理内存，虚拟内存技术允许该计算机运行一个64K大小的程序。\n虚拟内存 new/delete和malloc/free new和delete是用户进行动态内存申请和释放的操作符，operator new和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。\nnew的过程\n调用operator new函数申请空间； 在申请的空间上执行构造函数，完成对象的构造。 delete的过程\n在申请的空间上执行析构函数，完成对象中资源的清理工作； 调用operator delete函数释放对象的空间。 new T[N]的过程\n调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请； 在申请的空间上执行N次构造函数。 delete[]的过程\n在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理； 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间。 new/delete和malloc/free的异同 共同点是: 都是从堆上申请空间，并且需要用户手动释放。\n不同的地方是:\nmalloc和free是函数，new和delete是操作符； malloc申请的空间不会初始化，new可以初始化； malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可； malloc的返回值为void*, 在使用时必须强转；new不需要，因为new后跟的是空间的类型； malloc申请空间失败时，返回的是NULL，因此使用时必须判空；new不需要，但是new需要捕获异常； 申请自定义类型对象时，malloc/free只会开辟与销毁空间，不会调用构造函数与析构函数；而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理； new/delete比malloc/free的效率稍微低点，因为new/delete的底层封装了malloc/free。 free如何知道要free多大的空间 malloc函数的实现是以块分配内存，在被分配的块中包括两部分：\n第一部分中存储含有报头的元数据，它其中包含有分配块的大小信息，是一个常量； 第二部分中存储实际用户数据。而使用malloc分配内存返回的是第二部分用户数据的地址。 所以内存释放时不再需要再指定释放多大的内存空间，只需要指定该块内存空间的首地址即可。\nnew一个对象时加括号和不加括号的区别 对于内置类型：\nint *a = new int; 不会将申请到的int空间初始化，而 int *a = new int(); 则会将申请到的int空间初始化为0。 对于自定义类类型：\n如果该类没有定义构造函数（由编译器合成默认构造函数）也没有虚函数，那么 class c = new class 将不调用合成的默认构造函数，而 class c = new class() 则会调用默认构造函数。 如果该类没有定义构造函数（由编译器合成默认构造函数）但有虚函数，那么 class c = new class; 和 class c = new class(); 一样，都会调用默认构造函数。 如果该类定义了默认构造函数，那么 class c = new class; 和 class c = new class(); 一样，都会调用默认构造函数。 1 2 int *a1 = new int[10]; // 10个未初始化int int *a2 = new int[10](); // 10个值初始化为0的int malloc/free实现原理 实现原理 malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。\n方式一：如果用户分配的内存小于128 KB，则通过 brk() 系统调用从堆分配内存；\n方式二：如果用户分配的内存大于128 KB，则通过 mmap() 系统调用在文件/内存映射区域分配内存。\nbrk 是将 heap 的上界指针 brk 往高地址推，mmap 是在进程的虚拟地址空间中（堆和栈中间，称为内存/文件映射区域的地方）找一块空闲的虚拟内存。 这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。\nbrk 分配的内存需要等到高地址内存释放以后才能释放（这就是内存碎片产生的原因），当最高地址空间的空闲内存超过128K（可由 M_TRIM_THRESHOLD 选项调节）时，执行内存紧缩操作（trim）。 mmap 分配的内存可以单独释放。\nbrk和mmap 调用free(A)后A对应的虚拟内存和物理内存都没有释放，因为只有一个brk指针，如果往回推，那么B这块内存怎么办呢？ 当然A这块内存是可以重用的，如果这个时候再来一个40KB的请求，那么malloc很可能就使用A这块内存。 进程调用free(B)以后，A和B连接起来，变成一块150KB的空闲内存，于是内存紧缩。\nmalloc采用了内存池的实现方式：先申请一大块内存，然后将内存分成不同大小的内存块，然后用户申请内存时，直接从内存池中选择一块相近的内存块即可。brk分配内存时优先从内存池获取，失败的话走brk系统调用。细节参考：简书：glibc内存管理那些事儿\n既然堆内内存brk和sbrk不能直接释放，为什么不全部使用mmap来分配，munmap直接释放呢？ 既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么malloc不全部使用mmap来实现呢？而是仅仅对于大于128k的大块内存才使用mmap？\n因为brk和mmap都是系统调用，频繁调用系统调用都比较消耗系统资源的。使用mmap申请的空间，直接调用munmap是将空间真正释放了，而brk释放的空间，并不一定真正释放了，那些没有被真正释放的内存碎片可以被重复利用，再次访问该内存可能不需产生任何系统调用和缺页中断，这将大大降低CPU的消耗。\nbrk和mmap函数 brk()和sbrk()函数：作用是扩展heap的上界brk\n1 2 3 4 // 参数addr为新的brk地址，成功返回0，失败返回-1 int brk( const void *addr ); // 参数incr为需要申请的内存的大小，返回heap新的上界brk地址。如果sbrk的参数为0，则返回的为原来的brk地址。 void* sbrk ( intptr_t incr ); mmap()和munmap()函数：映射磁盘文件到内存中或匿名映射（向映射区申请一块内存）\n1 2 3 4 // addr为映射区的开始地址，length为映射区的长度，prot为期望的内存保护标志，flags指定映射对象的类型，fd为文件描述符 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); // munmap执行与mmap相反的操作，删除特定地址区域的对象映射 int munmap(void *addr, size_t length); ptmalloc和tcmalloc tcmalloc和malloc都是内存分配库，主要的不同在于实现方式和效率。\nmalloc是C标准库中的一部分，是系统提供的内存分配器。它的主要作用是管理进程虚拟内存空间，负责分配和释放内存资源。但是，由于多线程并发执行时需要加锁，所以它的性能并不是最优的。 tcmalloc是Google开发的一个高性能、多线程的内存管理库，是malloc的替代品之一。tcmalloc采用线程本地缓存技术（Thread-Caching Malloc，TCMalloc），避免了锁的竞争，从而在多线程环境下具有更好的性能表现。此外，tcmalloc还会将未使用的页面设置为“dirty”状态，提高缓存命中率，进一步提升了其效率。 总的来说，tcmalloc比malloc具有更高的性能和更好的可扩展性，在大型高并发的应用场景中使用更为适合。但是，tcmalloc也相对较复杂，需要结合实际情况进行使用和优化。\n参考：内存优化总结:ptmalloc、tcmalloc和jemalloc、ptmalloc、tcmalloc与jemalloc对比分析\n内存管理可以分为三个层次，自底向上分别是：\n内核层 C运行时库层（glibc层使用系统调用维护的内存管理算法） 应用程序层（应用程序从glibc动态分配内存后，根据应用程序本身的程序特性进行优化，比如使用引用计数std::shared_ptr，内存池方式等） 现状 目前大部分服务端程序使用glibc提供的malloc/free系列函数，而glibc使用的ptmalloc2在性能上远远弱后于google的tcmalloc和facebook的jemalloc。而且后两者只需要使用LD_PRELOAD环境变量启动程序即可，甚至并不需要重新编译。\nptmalloc2 ptmalloc2即是我们当前使用的glibc malloc版本。\nptmalloc2操作heap时，一般大内存采用mmap()，小内存使用brk()。\n🔰 主分配区和非主分配区\nptmalloc的内存分配器中，为了解决多线程锁争夺问题，分为主分配区（main_area）和非主分配区（no_main_area）。\n每个进程有一个主分配区，也可以允许有多个非主分配区。 主分配区可以使用brk和mmap来分配内存，而非主分配区只能使用mmap来映射内存块（批发申请HEAP_MAX_SIZE（64位系统为64MB）大小的虚拟内存）。 非主分配区的数量一旦增加，则不会减少。 主分配区和非主分配区形成一个环形链表进行管理。 当某一线程需要调用malloc()分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么malloc()会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。在释放操作中，线程同样试图获得待释放内存块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行释放操作。\n🔰 chunk内存块的基本组织单元\nptmalloc通过chunk的数据结构来组织每个内存单元。当我们使用malloc分配得到一块内存的时候，这块内存就会通过chunk的形式被glibc管理起来。你可以把它想象成自己写内存池的时候的一个内存数据结构。chunk的结构可以分为使用中的chunk和空闲的chunk。\n空闲的chunk会被放置到空闲的链表bins上。当用户申请内存malloc的时候，会先去查找空闲链表bins上是否有合适的内存。\n🔰 空闲链表bins\n当用户使用free函数释放掉的内存，ptmalloc并不会马上交还给操作系统，而是被ptmalloc本身的空闲链表bins管理起来了，这样当下次进程需要malloc一块内存的时候，ptmalloc就会从空闲的bins上寻找一块合适大小的内存块分配给用户使用。这样的好处可以避免频繁的系统调用，降低内存分配的开销。\nptmalloc ptmalloc一共维护了128个bin。每个bin都维护了大小相近的双向链表的chunk。通过上图这个bins的列表就能看出，当用户调用malloc的时候，能很快找到用户需要分配的内存大小是否在维护的bin上，如果在某一个bin上，就可以通过双向链表去查找合适的chunk内存块给用户使用。\nfast bins。fast bins是bins的高速缓冲区，大约有10个定长队列。当用户释放一块不大于max_fast（默认值64B）的chunk的时候，会默认会被放到fast bins上。当用户下次需要申请内存的时候首先会到fast bins上寻找是否有合适的chunk。ptmalloc会遍历fast bin，看是否有合适的chunk需要合并到bins上。 unsorted bin。是bins的一个缓冲区。当用户释放的内存大于max_fast或者fast bins合并后的chunk都会进入unsorted bin上。当用户malloc的时候，先会到unsorted bin上查找是否有合适的bin，如果没有合适的bin，ptmalloc会将unsorted bin上的chunk放入bins上，然后到bins上查找合适的空闲chunk。 small bins和large bins。small bins和large bins是真正用来放置chunk双向链表的。每个bin之间相差8个字节，并且通过上面的这个列表，可以快速定位到合适大小的空闲chunk。前64个为small bins定长；后64个为large bins，非定长。 Top chunk。并不是所有的chunk都会被放到bins上。top chunk相当于分配区的顶部空闲内存，当bins上都不能满足内存分配要求的时候，就会来top chunk上分配。 **mmaped chunk。**当分配的内存非常大（大于分配阀值，默认128K）的时候，需要被mmap映射，则会放到mmaped chunk上，当释放mmaped chunk上的内存的时候会直接交还给操作系统。 ✏️ 内存分配malloc()的流程\nmalloc()的流程 获取分配区的锁，防止多线程冲突；\n计算出需要分配的内存的chunk实际大小；\n判断chunk的大小，如果小于max_fast（64B），则取fast bins上去查询是否有适合的chunk，如果有则分配结束；\nchunk大小是否小于512B，如果是，则从small bins上去查找chunk，如果有合适的，则分配结束；\n继续从unsorted bins上查找：\n如果unsorted bins上只有一个chunk并且大于待分配的chunk，则进行切割，并且剩余的chunk继续扔回unsorted bins；\n如果unsorted bins上有大小和待分配chunk相等的，则返回，并从unsorted bins删除；\n如果unsorted bins中的某一chunk大小属于small bins的范围，则放入small bins的头部；\n如果unsorted bins中的某一chunk大小属于large bins的范围，则找到合适的位置放入；\n从large bins中查找，找到链表头后，反向遍历此链表，直到找到第一个大小大于待分配的chunk，然后进行切割，如果有余下的，则放入unsorted bin中去，分配则结束；\n如果搜索fast bins和其他bins都没有找到合适的chunk，那么就需要操作top chunk来进行分配了（top chunk相当于分配区的剩余内存空间）。判断top chunk大小是否满足所需chunk的大小，如果是，则从top chunk中分出一块来；\n如果top chunk也不能满足需求，则需要扩大top chunk。主分区上，如果分配的内存小于分配阀值（默认128K），则直接使用brk()分配一块内存；如果分配的内存大于分配阀值，则需要mmap来分配。\n非主分区上，则直接使用mmap来分配一块内存。通过mmap分配的内存，就会放入mmaped chunk上，mmap chunk上的内存会直接回收给操作系统。\n✏️ 内存释放free()的流程\n获取分配区的锁，保证线程安全。\n如果free的是空指针，则返回，什么都不做。\n判断当前chunk是否是mmap映射区域映射的内存，如果是，则直接munmap()释放这块内存。已使用chunk的数据结构中，有对应的标识判断是否是mmap映射的内存。\n判断chunk是否与top chunk相邻，如果相邻，则直接和top chunk合并（和top chunk相邻相当于和分配区中的空闲内存块相邻）。转到步骤8\n如果chunk的大小大于max_fast（64B），则放入unsorted bin，并且检查是否有合并，有合并情况并且和top chunk相邻，则转到步骤8；没有合并情况则free。\n如果chunk的大小小于 max_fast（64B），则直接放入fast bin，fast bin并没有改变chunk的状态。没有合并情况，则free；有合并情况，转到步骤7\n在fast bin，如果当前chunk的下一个chunk也是空闲的，则将这两个chunk合并，放入unsorted bin上面。合并后的大小如果大于64KB，会触发进行fast bins的合并操作，fast bins中的chunk将被遍历，并与相邻的空闲chunk进行合并，合并后的chunk会被放到unsorted bin中，fast bin会变为空。合并后的chunk和top chunk相邻，则会合并到top chunk中。转到步骤8\n判断top chunk的大小是否大于mmap收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还top chunk中的一部分给操作系统。free结束。\n✏️ ptmalloc的问题\nptmalloc的主要问题其实是内存浪费、内存碎片、以及加锁导致的性能问题。\n内存浪费：\n每个chunk本身至少8字节的开销很大；\n后分配的内存先释放，可能无法及时归还系统。因为ptmalloc收缩内存是从top chunk开始,如果与top chunk相邻的chunk不能释放，top chunk以下的chunk都无法释放；\n内存不能在线程间移动，多线程使用内存不均衡将导致内存浪费。\n内存碎片：不定期分配长生命周期的内存容易造成内存碎片，不利于回收。\n加锁导致的性能问题：加锁耗时，无论当前分区有无耗时，在内存分配和释放时，会首先加锁。\ntcmalloc tcmalloc是Google开源的一个内存管理库， 作为glibc malloc的替代品。目前已经在chrome、safari等知名软件中运用。\n🔰 对象分配\ntcmalloc为每个线程分配了一个线程本地ThreadCache，小内存从ThreadCache分配，此外还有个中央堆（CentralCache），ThreadCache不够用的时候，会从CentralCache中获取空间放到ThreadCache中。 小对象（\u0026lt;=32KB）从ThreadCache分配，大对象从CentralCache分配。大对象分配的空间都是4k页面对齐的，多个pages也能切割成多个小对象划分到ThreadCache中。 ✏️ tcmalloc的优势\n小内存可以在ThreadCache中不加锁分配（加锁的代价大约100ns） 大内存可以直接按照大小分配不需要再像ptmalloc一样进行查找 大内存加锁使用更高效的自旋锁 减少了内存碎片 内存对齐 什么事内存对齐？ 现代计算机中内存空间都是按照字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。\n为什么内存对齐？ 主要是由于CPU的访问内存的特性决定，**CPU访问内存时并不是以字节为单位来读取内存，而是以机器字长为单位，实际机器字长由CPU数据总线宽度决定的。**实际CPU运行时，每一次控制内存读写信号发生时，CPU可以从内存中读取数据总线宽度的数据，并将其写入到CPU的通用寄存器中。内存对齐的主要目的是为了减少CPU访问内存的次数。假设读取8个字节的数据，按照每次读取4个字节的速度，则8个字节需要CPU耗费2次读取操作。CPU始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU访问内存的次数。\n怎么使用内存对齐？ 我们可以用#progma pack(x)指定结构体以x为单位进行对齐。一般情况下使用方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #pragma pack(push) /* push current alignment to stack */ #pragma pack(1) /* set alignment to 1 byte boundary */ struct MyPackedData { char Data1; // 1 byte long Data2; // 8 byte(64位环境) char Data3; // 1 byte }; #pragma pack(pop) /* restore original alignment from stack */ int main() { cout \u0026lt;\u0026lt; alignof(MyPackedData) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; sizeof(MyPackedData) \u0026lt;\u0026lt; endl; // 10 return 0; } C++11之后提供了alignas关键字，允许往更大的字节数去对齐（有的平台不支持未对齐内存访问，alignas的目的是允许你往更大的字节数去对齐，比如char对齐到32位供SIMD load）。\n即pack是变小，alignas是变大，用法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct alignas(1) Point // 使用G++能正常运行，但是在CLion中会报错，因为这样做是不合规范（ill-formed）的 { int a; char b; }p; cout \u0026lt;\u0026lt; alignof(p) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt; endl; // 8 #pragma pack(push) #pragma pack(1) struct Point2 { int a; char b; }p2; #pragma pop(pop) cout \u0026lt;\u0026lt; alignof(p2) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; sizeof(p2) \u0026lt;\u0026lt; endl; // 4 用户态与内核态 用户态/内核态的概念 CPU指令可以直接操作硬件，而对于硬件的操作是非常复杂的，出问题的几率相当大，所以操作系统内核直接屏蔽了个人开发者对于硬件操作的可能。因为这个需求，硬件设备商直接提供了硬件级别的支持，做法就是对CPU指令设置了权限，不同级别的权限可以使用的CPU指令是有限制的。\n以Intel CPU为例，CPU指令操作的权限划为4级：ring 0、ring 1、ring 2、ring 3。其中ring 0权限最高，可以使用所有CPU指令，ring 3 权限最低，仅能使用常规CPU指令，不能使用访问硬件资源的指令，比如I/O读写、网卡访问、申请内存等。\nLinux 系统内核采用了：ring 0 和 ring 3 这2个权限\nring 0 被叫做 内核态，完全在操作系统内核中运行，由专门的内核线程执行其任务； ring 3 被叫做 用户态，在应用程序中运行，由用户线程执行其任务。 切换方式 从用户态到内核态切换可以通过三种方式，或者说会导致从用户态切换到内核态的操作：\n系统调用：系统调用本身就是中断，属于软件中断，跟硬件中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如Linux的int 80h中断。比如我们使用库函数fopen打开文件，就会触发open系统调用。 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中。 外围设备中断：硬件中断，外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。 切换过程 当发生用户态到内核态的切换时，会发生如下过程（本质上是从“用户程序”切换到“内核程序”）\n设置处理器至内核态；\n保存当前程序的寄存器（栈指针、程序计数器、通用寄存器）；\n将栈指针设置指向内核栈地址；\n执行中断处理程序；\n恢复之前保存的寄存器，从中断处理程序返回。\n具体流程参考[中断（系统调用）的具体过程](## 中断（系统调用）的具体过程)\n中断（系统调用）的具体过程 总结： 用户运行库函数（系统调用的封装），函数里面其实是执行的int 0x80指令。系统调用先把系统调用号保存在eax寄存器中，然后执行int0x80指令。int 0x80指令先进行切换堆栈（找到进程的堆栈，将寄存器值压入到内核栈中，将esp，ss设置成对应内核栈的值），查找相应中断向量的中断处理程序(system_call)并调用，随后system_call 从系统调用表中找到相应的系统调用进行调用，调用结束后从system_call中返回。\n中断一般有两个属性，中断号和中断处理程序（ISR，Interrupt Service Routine）。在内核中，有一个数组称为中断向量表，包含了中断号及其对应中断处理程序的指针。中断到来时，CPU暂停当前执行的代码，根据中断的中断号，在中断向量表中找到对应的中断处理程序，并调用它。中断处理程序执行完成之后，CPU会继续执行之前的代码。\n由于中断号是有限的，操作系统不舍得每一个系统调用对应一个中断号，而更倾向于用一个或少数几个中断号来对应所有的系统调用。Linux则使用int 0x80来触发所有系统调用。每个系统调用对应一份系统调用号，这个系统调用号在执行int 0x80指令前会放置在某个固定的寄存器里（eax)，对应的中断代码会取得这个系统调用号，并且调用正确的函数。\n系统调用的详细过程 触发中断 用户程序在代码中调用系统调用，执行int指令前将系统调用号放入eax寄存器中，执行int 0x80指令（int指令最终执行的函数是system_call，该函数验证系统调用号的有效性，查找系统调用函数并执行，最后通过itret指令从中断处理程序返回）。\n切换堆栈（此步在int指令中完成） 在实际执行0x80号中断向量所对应的中断处理程序（system_call）之前，CPU首先要进行堆栈切换，即从用户态切换到内核态。所谓的当前栈，指得是esp（栈指针）的值所在的栈空间。如果esp的值位于用户栈的范围内，那么程序的当前栈就是用户栈，反之亦然。此外，寄存器ss的值还应该指向当前栈所在的页。\n所以，将当前栈由用户栈切换为内核栈（用户态切换到内核态）的实际行为就是：保存当前的esp，ss的值（保证存在内核栈上，int指令发送后自动地由硬件完成），并将esp，ss的值设置为内核栈的相应值\n当0x80号中断发生的时候，cpu除了切入内核态之外，还会自动完成下列几件事：\n（1）找到当前进程的内核栈（每一个进程都有自己的内核栈）\n（2）在内核栈中一次压入用户态的寄存器ss、esp、eflags、cs、eip\n而当内核从系统调用返回的时候，须要调用iret指令来回到用户态，iret指令则会从内核栈里弹出寄存器ss、esp、eflags、cs、eip的值，使得栈恢复到用户态的状态。\n中断时内核栈和用户栈的切换 中断处理程序 在int指令切换内核栈之后，程序就切换到了中断向量表中的0x80号中断处理程序。Linux中0x80向量对应的中断处理程序是system_call。\nsystem_call中断服务程序首先检查系统调用号的有效性，再根据eax寄存器存储的系统调用号从系统调用表上找到相应的系统调用并调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // system_call的开头部分 ...... SAVE_ALL // 保存寄存器的值到栈中，以免被覆盖 ...... cmpl $(nr_syscalls), %eax // 比较eax寄存器中的值和系统调用号大1的值（验证系统调用号的有效性） jae syscall_badsys\t// 如果系统调用无效，指向syscall_badsys // 如果系统调用号有效，则会执行以下代码 syscall_call: call *sys_call_table(0, %eax, 4) // 查找中断服务程序并执行， sys_call_table其实就是系统调用表 ..... RESTORE_REGS // 恢复之前保存的寄存器 ...... iret // 从中断程序返回 恢复之前保存的寄存器，从中断处理程序返回，从内核态切换回用户态 缺页中断 在操作系统中，程序执行时需要访问的内存在虚拟内存中，不在物理内存中，此时就会发生缺页中断（该情况为硬件页缺失）。\n缺页中断的分类 软性页缺失：指页缺失发生时，相关的页已经被加载进内存，但是没有向MMU（内存管理单元）注册的情况。操作系统只需要在MMU中注册相关页对应的物理地址即可。 硬性页缺失：硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。 无效页缺失：当程序访问的虚拟地址是不存在于虚拟地址空间内的时候，则发生无效页缺失。\n查看进程发生缺页中断的次数 ps -o majflt,minflt -C \u0026lt;program_name\u0026gt; ps -o majflt,minflt -p \u0026lt;pid\u0026gt; majflt代表major fault，中文名叫大错误，minflt代表minor fault，中文名叫小错误。 majflt 表示需要读写磁盘，可能是内存对应页面在磁盘中需要load到物理内存中，也可能是此时物理内存不足，需要淘汰部分物理页面至磁盘中。 这两个数值表示一个进程自启动以来所发生的缺页中断的次数。\n缺页中断过程 当程序访问一个虚拟地址时，操作系统会检查该地址是否被映射到物理内存中，如果没有，则触发缺页中断：\n缺页中断会暂停程序执行，将控制权交给操作系统内核（进程会陷入内核态），保护程序现场，以免被操作系统破坏。\n内核会检查发生缺页中断的虚拟地址是否有效：\n如果虚拟地址有效，操作系统将会分配一个空闲物理页面，并把未被读取的数据从磁盘拷贝到物理内存所分配的页面中（没有空闲物理页面会触发页面置换算法），并更新页表信息。 如果虚拟地址无效，则操作系统会向进程发出一个信号或杀掉该进程。 当操作系统处理完缺页中断后，程序会恢复至发生缺页中断指令以前的状态，程序计数器重新指向这条指令。 缺页中断和缺页异常 缺页中断是指当程序访问一个虚拟内存地址时，对应的物理内存页不在主存中，需要从磁盘中加载到主存中，此时CPU就会发出一个中断请求，操作系统会响应中断请求，将对应的物理页加载到主存中，并重新执行产生缺页中断的指令。缺页中断是一种同步事件，也就是说，程序需要等待操作系统完成页的加载操作后才能继续执行。\n缺页异常是指当程序访问一个虚拟内存地址时，对应的物理内存页不在主存中，需要从磁盘中加载到主存中，但是此时CPU不会发出中断请求，而是将控制权交给操作系统，让操作系统处理缺页异常。缺页异常是一种异步事件，也就是说，程序不需要等待操作系统完成页的加载操作就可以继续执行。\n因此，缺页中断和缺页异常的主要区别在于它们是同步事件还是异步事件。缺页中断是同步事件，程序需要等待操作系统完成页的加载操作后才能继续执行；而缺页异常是异步事件，程序不需要等待操作系统完成页的加载操作就可以继续执行。\nLinux程序内存空间 linux下内存资源是通过虚拟内存管理的，在分配内存时并不是在物理内存开辟了一段空间，而是在使用时才分配的，并且是通过段页式管理。linux下内存分配是以页为单位的，而页是通过段管理。各个段之间是独立的，方便管理。\nlinux程序执行时能够分为下面几个内存段：text、rodata、data、bss、stack、heap。\ntext段（代码段）：text段存放程序代码，运行前就已经确定（编译时确定），通常为只读； rodata段（常量区）：rodata段存储常量数据，比如程序中定义为const的全局变量，“#define”定义的常量，以及诸如“Hello World”的字符串常量。const修饰的全局变量在常量区，const修饰的局部变量只是为了防止修改，没有放入常量区（存在stack段）； data段：data存储已经初始化的全局变量（静态变量），属于静态内存分配，需要占用可执行文件空间（注意：初始化为0的全局变量和静态变量还是被保存在bss段）； bss段：bss段存储没有初始化或初始化为0的全局变量（静态变量），属于静态内存分配。bss不占用可执行文件空间，其内容由操作系统初始化（清零），但占据程序运行时的内存空间； stack段：stack段存储参数变量和局部变量，由系统进行申请和释放，属于静态内存分配； heap段：heap段是程序运行过程中动态分配的内存段，由用户申请和释放，程序中不释放，则程序结束时，由OS回收。 执行文件中包含了text、rodata、data段的内容，不包含bss段内容（一堆0放入执行文件没有意义）。 堆和栈的内存增长方向是相反的：栈是从高地址向低地址生长，堆是从低地址向高地址生长。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const int NUM = 10086; // 常量区(rodata段) int a = 10; // 全局初始化区（data） char *p1; // 全局未初始化区（bss） int main() { int b; // 栈区 char s[] = \u0026#34;abc\u0026#34;; // 栈区 char *p; // 栈区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); // 分配得来的10和20字节的区域就在堆区 static int c =0; // bss段 const int d = 5; // stack段 char *p3 = \u0026#34;123456\u0026#34;; // p3在栈区，\u0026#34;123456\\0\u0026#34; 在rodata段 strcpy(p1, \u0026#34;123456\u0026#34;); // \u0026#34;123456\\0\u0026#34; 放在rodata段，编译器可能会将它与p3所指向的\u0026#34;123456\u0026#34;优化成一个地方。 } 虚表/虚表指针 为了实现C++的多态，C++使用了一种动态绑定的技术，这个技术的核心是虚函数表。\n虚表 每个包含了虚函数的类都包含一个虚表； 一个类继承了包含虚函数的基类，那么这个类也会拥有自己的虚表； 虚表是一个指针数组，其元素是虚函数的指针，即虚表中每个元素对应一个虚函数的函数指针； 虚函数的的调用都需要经过虚表，普通函数即非虚函数，其调用并不需要经过虚表； 虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段； 虚表是属于类的，而不属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。 虚表指针 如有类中包含虚函数，编译器会自动在类中添加一个指针：*__vptr，用来指向该类的虚表； 类的对象在创建时便拥有虚表指针，且这个指针的值会自动被设置为指向类的唯一虚表。 类A的定义如下：\n1 2 3 4 5 6 7 8 9 class A { public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int m_data1, m_data2; }; 因为类A中存在（一个或多个）虚函数，编译器会自动给类A加上一个虚表指针（占8字节空间），所以sizeof(A)=16。 类A的虚表和虚表指针（__vptr）关系如下：\n虚表和虚表指针 多态相关 一个类的基类如果包含虚函数，那个这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表； 一旦继承类重写了基类的某个虚函数，那么它的虚表项也会同步更新，指向继承类重写的函数，否则指向它基类的同名函数。 通过基类的指针调用派生类中的函数称为（运行时）多态，经过虚表调用虚函数的过程称为动态绑定； 虚表和虚表指针的创建时机： 在编译的过程中编译器就为含有虚函数的类创建了虚表，并且编译器会在构造函数中插入一段代码，这段代码用来给虚指针赋值。因此虚表是在编译的过程中创建。 由于虚指针是基于对象的，所以对象在实例化的时候，虚指针就会创建，所以虚指针是在运行时创建。 此外，编译器规定一个模版函数不能为虚函数。因为模版机制需要在编译期间识别模版支持类型，对于每一种类型我们都要生成对应类型的函数体。如果这个模版函数为虚函数，我们不知道这个模版函数被生成了多少份对应类型的虚函数，也就不好确定虚表的大小，所以编译器禁止这一行为。\n更详细的内容参考：知乎：C++中虚函数、虚继承内存模型\n","permalink":"https://kdjlyy.github.io/posts/tech/cs_basic_os/","summary":"Linux用户空间内存分布 程序内存在地址空间中的分布情况称为内存模型。 对于32位环境，理论上程序可以拥有4GB的虚拟地址空间，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间。 Linux默认将高地址的1GB空间分配给内核。也就是说，应","title":"计算机基础知识总结（系统篇）"},{"content":" 常见的Markdown语法，例如引用、标题、段落、无序列表、有序列表等不做讨论。\n参考：Sulv’s Blog、荷戟独彷徨、Memory、3rd\u0026rsquo;s Blog、Doit。\n字体种类 在Markdown中，使用\u0026lt;font\u0026gt;标签的face属性修改文字字体：\n1 2 3 \u0026lt;font face=\u0026#39;SimHei\u0026#39;\u0026gt;这是黑体\u0026lt;/font\u0026gt; \u0026lt;font face=\u0026#39;KaiTi\u0026#39;\u0026gt;这是楷体\u0026lt;/font\u0026gt; \u0026lt;font face=\u0026#39;Fangsong_GB2312\u0026#39;\u0026gt;这是仿宋_GB2312字体\u0026lt;/font\u0026gt; 这是黑体 这是楷体 这是仿宋_GB2312字体\n字体名称 字体写法 黑体 SimHei 宋体 SimSun 新宋体 NSimSun 仿宋 FangSong 楷体 KaiTi 仿宋_GB2312 FangSong_GB2312 楷体_GB2312 KaiTi_GB2312 微软雅黑 Microsoft YaHei 落霞文楷 LXGW WenKai 落霞文楷 Lite LXGW WenKai Lite 落霞文楷 Screen LXGW WenKai Screen 落霞文楷 TC LXGW WenKai TC 字号 1 2 3 4 5 6 7 \u0026lt;font size=\u0026#34;1\u0026#34;\u0026gt;这是1号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;2\u0026#34;\u0026gt;这是2号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;3\u0026#34;\u0026gt;这是3号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;4\u0026#34;\u0026gt;这是4号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;5\u0026#34;\u0026gt;这是5号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;6\u0026#34;\u0026gt;这是6号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;7\u0026#34;\u0026gt;这是7号字体\u0026lt;/font\u0026gt; 这是1号字体\n这是2号字体 这是3号字体 这是4号字体 这是5号字体 这是6号字体 这是7号字体 字体颜色 1 2 3 4 \u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;这是红色字体\u0026lt;/font\u0026gt; \u0026lt;font color=\u0026#39;rgb(200, 100, 100)\u0026#39;\u0026gt;这是rgb(200, 100, 100)颜色字体\u0026lt;/font\u0026gt; \u0026lt;font color=\u0026#39;#FF00BB\u0026#39;\u0026gt;这是#FF00BB颜色字体\u0026lt;/font\u0026gt; \u0026lt;font style=\u0026#34;background: linear-gradient(to right, #ff1616, #36c945, #10a5ce, #0f0096, #a51eff, #ff1616);\u0026#34;\u0026gt;这是7色渐变颜色\u0026lt;/font\u0026gt; 这是红色字体 这是rgb(200, 100, 100)颜色字体 这是#FF00BB颜色字体\n这是7色渐变颜色\n待办列表 使用-[]表示一项待办，当完成待办后给中括号中添加x（不区分大小写，注意空格不可省略）即可，例如：\n1 2 3 - [x] 吃饭 - [x] 睡觉 - [ ] 写作业 吃饭 睡觉 写作业 脚注和页内跳转 脚注 1 2 3 这是一个简单的脚注[^1]，这是另一个脚注[^bignote]。 [^1]:这是第一个脚注 [^bignote]:这是第二脚注 这是一个简单的脚注1，这是另一个脚注2。\n页内跳转 1 2 3 4 5 6 7 // 1. 首先定义一个锚点： \u0026lt;span id=\u0026#34;jump\u0026#34;\u0026gt;**\u0026lt;u\u0026gt;《塞尔达传说 王国之泪》\u0026lt;/u\u0026gt;**\u0026lt;/span\u0026gt;（日语：ゼルダの伝説 ティアーズ オブ ザ キングダム，英语：The Legend of Zelda: Tears of the Kingdom）是一款由任天堂企划制作本部开发，任天堂发行的一款开放世界动作冒险游戏。本作为2017年发售的《塞尔达传说 旷野之息》的续作，也是塞尔达传说系列的第二十部作品，于2023年5月12日在任天堂Switch上发售。 // 2. 用markdown的语法写超链 点击查看[王国之泪的介绍](#jump) // 3. 点击超链文字就可以定位到跳转内容了 点击查看王国之泪的介绍\n《塞尔达传说 王国之泪》（日语：ゼルダの伝説 ティアーズ オブ ザ キングダム，英语：The Legend of Zelda: Tears of the Kingdom）是一款由任天堂企划制作本部开发，任天堂发行的一款开放世界动作冒险游戏。本作为2017年发售的《塞尔达传说 旷野之息》的续作，也是塞尔达传说系列的第二十部作品，于2023年5月12日在任天堂Switch上发售。\n另外，也可以用上标的方式进行页内跳转：\n1 王国之泪\u0026lt;sup\u0026gt;[[塞尔达传说 王国之泪]](#jump)\u0026lt;/sup\u0026gt;是什么游戏？ 王国之泪[塞尔达传说 王国之泪]是什么游戏？\n鼠标悬浮效果 1 \u0026lt;abbr title=\u0026#34;🙃🙃🙃\u0026#34;\u0026gt;鼠标悬浮这里\u0026lt;/abbr\u0026gt;可以看到详细的解释。 鼠标悬浮这里 可以看到详细的解释。\n自定义shortcodes Hugo博客通过简码方式插入pdf、bilibili以及博客文章内链等功能。\n为了防止被识别生效，调用样式均表示为{.{\u0026lt; xxx \u0026gt;}}，实际使用时去掉大括号中间的.即可。\n插入pdf 1 {.{\u0026lt; ppt src=\u0026#34;https://www.africau.edu/images/default/sample.pdf\u0026#34; \u0026gt;}} 插入bilibili视频 1 2 {.{\u0026lt; bilibili BV1WZ4y1a7MF \u0026gt;}} # 如果有集数（默认第一集），例如要播放第5集，则这样使用：{.{\u0026lt; bilibili BV1WZ4y1a7MF 5 \u0026gt;}} \u003c!DOCTYPE HTML\u003e 插入博客文章内链 1 2 {.{\u0026lt; innerlink src=\u0026#34;posts/tech/cs_basic_grammar.md\u0026#34; \u0026gt;}} # 卡片获取的文章长度默认是70，需要在config.yaml配置文件添加 summaryLength: 140，即设置为140 计算机基础知识总结（语法篇） 日期: 2023-05-09 \u0026nbsp; 标签: #C\u0026#43;\u0026#43;\u0026nbsp; #基础知识\u0026nbsp; 成员变量初始化 构造函数内部初始化和初始化列表 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。 对于内置类型，如int, float等，使用初始化列表和在构造函数体内初始化差别不大； 对于类类型来说，使用初始化列表会减少调用默认构造函数的次数，更加高效。 1 2 ...... 代码折叠 1 2 3 4 5 6 7 8 9 {.{% code %}} ```cpp #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } ``` {.{% /code %}} 代码 1 2 3 4 5 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 文字位置 1 2 3 {.{\u0026lt; align left \u0026#34;文字居左\u0026#34; \u0026gt;}} {.{\u0026lt; align center \u0026#34;文字居中\u0026#34; \u0026gt;}} {.{\u0026lt; align right \u0026#34;文字居中\u0026#34; \u0026gt;}} 文字居左\n文字居中\n文字居中\n图片 figure标签是PaperMod主题自带的\n1 2 {.{\u0026lt; figure src=\u0026#34;https://kdjlyy.github.io/img/logo.ico\u0026#34; caption=\u0026#34;图片描述\u0026#34; width=\u0026#34;50%\u0026#34; height=\u0026#34;50%\u0026#34; align=\u0026#34;center\u0026#34; \u0026gt;}} {.{\u0026lt; figure src=\u0026#34;https://kdjlyy.github.io/img/logo.ico\u0026#34; title=\u0026#34;xxx\u0026#34; caption=\u0026#34;图片描述\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34; \u0026gt;}} 图片描述\n或者：\n1 2 3 4 \u0026lt;div style=\u0026#34;text-align:center;\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;display: block; margin: 0 auto;\u0026#34; src=\u0026#34;\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; \u0026gt; \u0026lt;span style=\u0026#34;font-size: 14px; color: grey;\u0026#34;\u0026gt;图片描述\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; 头像 Github卡片 1 {.{\u0026lt; github title=\u0026#34;kdjlyy/fastRPC\u0026#34; \u0026gt;}} Mermaid作图 1 2 3 4 5 6 7 8 \u0026lt;div align=center\u0026gt; \u0026lt;!-- 可以用html代码包裹该代码实现居中或其他排版 --\u0026gt; {.{\u0026lt;mermaid\u0026gt;}} flowchart LR a --\u0026gt; b \u0026amp; c --\u0026gt; d {.{\u0026lt;/mermaid\u0026gt;}} \u0026lt;/div\u0026gt; flowchart LR a --\u003e b \u0026 c --\u003e d 流程图 代码 1 2 3 4 5 6 {.{\u0026lt; mermaid \u0026gt;}}graph LR; A[Hard edge] --\u0026gt;|Link text| B(Round edge) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result one] C --\u0026gt;|Two| E[Result two] {.{\u0026lt; /mermaid \u0026gt;}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] 时序图 代码 1 2 3 4 5 6 7 8 9 10 11 12 {.{\u0026lt; mermaid \u0026gt;}}sequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! {.{\u0026lt; /mermaid \u0026gt;}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! 甘特图 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { {\u0026lt; mermaid \u0026gt;}}gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d { {\u0026lt; /mermaid \u0026gt;}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d 类图 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { {\u0026lt; mermaid \u0026gt;}}classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u0026lt;--\u0026gt; C2: Cool label { {\u0026lt; /mermaid \u0026gt;}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label 状态图 代码 1 2 3 4 5 6 7 8 {.{\u0026lt; mermaid \u0026gt;}}stateDiagram [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] {.{\u0026lt; /mermaid \u0026gt;}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] Git图 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 { {\u0026lt; mermaid \u0026gt;}} gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\u0026#34;ash\u0026#34; tag:\u0026#34;abc\u0026#34; branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release { {\u0026lt; /mermaid \u0026gt;}} gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\"ash\" tag:\"abc\" branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release 饼图 代码 1 2 3 4 5 6 7 \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; pie \u0026#34;Dogs\u0026#34; : 386 \u0026#34;Cats\u0026#34; : 85 \u0026#34;Rats\u0026#34; : 15 \u0026lt;/div\u0026gt; pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 Echarts作图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;echarts\u0026#34; style=\u0026#34;width: 600px;height:400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/echarts/5.1.1/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var myChart = echarts.init(document.getElementById(\u0026#39;echarts\u0026#39;)); myChart.setOption({ title: { text: \u0026#39;ECharts 示例\u0026#39; }, tooltip: {}, xAxis: { data: [\u0026#39;周一\u0026#39;, \u0026#39;周二\u0026#39;, \u0026#39;周三\u0026#39;, \u0026#39;周四\u0026#39;, \u0026#39;周五\u0026#39;, \u0026#39;周六\u0026#39;, \u0026#39;周日\u0026#39;] }, yAxis: {}, series: [{ name: \u0026#39;销量\u0026#39;, type: \u0026#39;bar\u0026#39;, data: [5, 20, 36, 10, 10, 20, 5] }] }); \u0026lt;/script\u0026gt; 其他 上标和下标 1 2 3 H\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;O C\u0026lt;sub\u0026gt;6\u0026lt;/sub\u0026gt;H\u0026lt;sub\u0026gt;12\u0026lt;/sub\u0026gt;O\u0026lt;sub\u0026gt;6\u0026lt;/sub\u0026gt; X\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; + Y\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; = Z\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; H2O\nC6H12O6 Xn + Yn = Zn 公式 1 $$0.414213562373095048\\approx6\\*16^{-1}+a\\*16^{-2}+0\\*16^{-3}+\\cdots$$ $$0.414213562373095048\\approx6*16^{-1}+a*16^{-2}+0*16^{-3}+\\cdots$$\n高亮 1 \u0026lt;mark\u0026gt;高亮标记语言\u0026lt;/mark\u0026gt;显示段落中的重要文字部分。 高亮标记语言显示段落中的重要文字部分。\n这是第一个脚注\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n\u0026#160;\u0026#x21a9;\u0026#xfe0e; ","permalink":"https://kdjlyy.github.io/posts/tech/markdown_note/","summary":"主要展示 PaperMod 主题中 Markdown 语法的页面效果","title":"PaperMod主题Markdown示例"},{"content":"成员变量初始化 构造函数内部初始化和初始化列表 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。\n对于内置类型，如int, float等，使用初始化列表和在构造函数体内初始化差别不大； 对于类类型来说，使用初始化列表会减少调用默认构造函数的次数，更加高效。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;A()\u0026#34; \u0026lt;\u0026lt; endl; } A(int _a) { a = _a; cout \u0026lt;\u0026lt; \u0026#34;A(_a)\u0026#34; \u0026lt;\u0026lt; endl; } private: int a; }; class B { public: B() { cout \u0026lt;\u0026lt; \u0026#34;B()\u0026#34; \u0026lt;\u0026lt; endl; } B(int _b) : b(_b), m_a(_b) { // 初始化列表初始化 // b = _b, m_a = A(_b); // 构造函数内部赋值操作 cout \u0026lt;\u0026lt; \u0026#34;B(_b)\u0026#34; \u0026lt;\u0026lt; endl; } private: int b; A m_a; }; int main(int argc, char** argv) { B b(100); } 这段代码输出：\n1 2 A(_a) B(_b) 如果不使用初始化列表，使用17行构造函数内部赋值的方式，会输出：\n1 2 3 A() A(_a) B(_b) 除了性能问题之外，有时候初始化列表是不可或缺的，以下几种情况必须使用初始化列表：\n类的const成员\n引用类型\nconst对象或引用只能初始化但是不能赋值，构造函数的函数体内只能做赋值而不是初始化。因此初始化const对象或引用的唯一机会是构造函数函数体之前的初始化列表中。\n没有默认构造函数的类类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class A { public: A(int a): i(a) {} int i; }; class B { public: A a ; B(const A\u0026amp; a1) { a = a1; // error: 类A不存在默认构造函数 } }; class C: public A { public: C(int _x): x(_x) {} // error: 类A不存在默认构造函数 private: int x; } 以上代码无法通过编译，因为B的构造函数中a=a1这一行会先调用A的默认构造函数来初始化a1，由于A没有默认的构造函数，所以无法执行，故而编译错误。\n如果基类没有默认构造函数，派生类必须在其初始化列表中显示调用基类的构造函数。\n构造函数调用顺序 调用基类构造函数，调用顺序按照他们的继承时声明的顺序。 调用内嵌成员对象的构造函数，调用顺序按照他们在类中声明的顺序。 调用派生类自己的构造函数体中的内容。 析构函数的调用顺序相反。\n更详细的：构造函数的执行可以分成两个阶段，初始化阶段和计算阶段，初始化阶段先于计算阶段。\n初始化阶段：所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。 计算阶段：一般用于执行构造函数体内的赋值操作。 所以，初始化列表总是先于构造函数体执行：基类初始化列表 → 基类的构造函数 → 派生类初始化列表 → 派生类的构造函数。\n成员变量初始化顺序 成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class A { private: int n1; int n2; public: A(): n2(0), n1(n2+1) {} void Print(){ cout \u0026lt;\u0026lt; \u0026#34;n1: \u0026#34; \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#34;, n2: \u0026#34; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt;endl; } }; int main() { A a; a.Print(); // 输出是：`n1: 18749281, n2: 0`，而不是`n1: 1, n2: 0` return 0; } const和constexpr constexpr关键字是C++11新增的，其作用包括：\n定义编译期常量[编译期常量]； 定义常量表达式函数[常量表达式函数]； 定义编译期常量对象[编译期常量对象]。 常量分为编译期常量、运行期常量。 编译期常量在编译阶段就可以确定其值，并将其结果展开到使用的地方，一般存放在rodata段。 运行期常量本质上是只读的变量（存放在栈区），编译时无法确定其值；运行时，无法修改其值。\nconst 可以定义编译期常量，也可以定义运行期常量； constexpr 只能定义编译期常量。 1 2 3 4 5 6 7 const int a = 10; // 编译期常量，存放在静态存储区的rodata段 int main() { int b = 20; // 栈 const int c = b; // 栈（运行期常量） // constexpr int c = b; Error: 因为b是一个普通变量，必须到运行期才能确定，constexpr无法修饰运行期常量。 } 普通函数必须在运行时才能执行，进而计算出结果。而常量表达式函数要求函数在编译期就计算出结果，运行时直接使用结果。也就是说将函数的执行从运行阶段转移到编译阶段，提升程序运行效率。 只需要在函数返回值类型前面加上constexpr关键字即可定义常量表达式函数，我们必须使用constexpr修饰的编译期常量来保存常量表达式函数的结果，否则常量表达式函数仍然会在运行期执行。\n1 2 3 4 5 6 7 8 constexpr int my_sum(int n) { if (n == 1) return 1; return n + my_sum(n - 1); } void test() { constexpr int a = my_sum(3); } 编译期常量对象的任何计算都在编译期完成。定义编译期常量对象，有以下几点要求：\n构造函数使用constexpr修饰，必须使用初始化列表对成员进行初始化； 对象调用的成员函数必须使用constexpr修饰。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Box { public: // 构造函数使用constexptr修饰，并且使用初始化列表对成员进行初始化。这就保证了对象成员m_l、m_w、m_h在编译期确定其值。 constexpr Box(int l, int w, int h) : m_l(l), m_w(w), m_h(h) {} // get_volume函数被定义为了常量表达式成员函数，调用该函数则会在编译阶段计算出结果。 constexpr int get_volume() const { return m_l * m_w * m_h; } // get_sum函数则是普通函数，该函数必须声明为const函数，否则无法被常量对象调用 int get_sum() const { return (m_l + m_w + m_h); } public: int m_l, m_w, m_h; }; void test() { constexpr Box box(10, 20, 30); // 程序编译期间调用常量表达式构造函数 constexpr int volume = box.get_volume(); // 在编译期计算出函数的执行结果，并赋值给编译期常量volume int my_sum = box.get_sum(); // 在运行期进行执行 } 单例模式 单例模式是一种设计模式，它确保一个类只有一个实例，并且提供一个全局访问点来访问它。 单例模式的实现一般需要将构造函数、析构函数私有化，禁用拷贝构造函数和赋值运算符，将成员变量和成员函数都设置成静态类型。\n懒汉单例模式实现 最简单的懒汉模式（在全局访问入口中声明静态变量。局部静态变量在C++11后也是线程安全的） 1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton { private: Singleton(); ~Singleton(); Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton* getInstance() { static Singleton instance; return \u0026amp;instance; } }; 加锁版本的懒汉单例模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Singleton { private: Singleton(); ~Singleton(); Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* instance; static pthread_mutex_t mutex; public: static Singleton* getInstance() { if (instance == nullptr) { pthread_mutex_lock(\u0026amp;mutex); instance = new Singleton(); pthread_mutex_unlock(\u0026amp;mutex); } return instance; } }; Singleton* Singleton::instance = nullptr; pthread_mutex_t Singleton::mutex = PTHREAD_MUTEX_INITIALIZER; 饿汉单例模式实现 饿汉单例模式天生线程安全，因为在main函数前已经初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton { private: Singleton(); ~Singleton(); Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* instance; public: static Singleton* getInstance() { return instance; } }; Singleton* Singleton::instance = new Singleton(); ","permalink":"https://kdjlyy.github.io/posts/tech/cs_basic_grammar/","summary":"成员变量初始化 构造函数内部初始化和初始化列表 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。 对于内置类型，如int, float等，使用初始化列表和在构造函数体内初始化差别不大； 对于类类型来说，使用初始化列表会减少调用默认构造函数的次数，更加高效。 1 2","title":"计算机基础知识总结（语法篇）"}]