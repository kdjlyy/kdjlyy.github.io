[{"content":"","permalink":"https://kdjlyy.cn/posts/site/hugo_shortcodes/","summary":"","title":"Hugo博客shortcodes使用"},{"content":"准备工作 ","permalink":"https://kdjlyy.cn/posts/site/ecs_deploy/","summary":"准备工作","title":"Hugo博客部署到云服务器"},{"content":"配置标签页面 PaperMod 主题是支持多语言的，但是标签页不支持，需要修改对应的 html 模板。\n主题提供的语言支持文件在themes/PaperMod/il8n里面，其中zh.yaml即简体中文。\n为了防止更新主题时还原修改过的文件，需要在网站根目录进行修改，这样可以覆盖主题原有文件的效果。在网站根目录新建i18n/文件夹，复制themes/PaperMod/i18n/zh.yaml到i18n/zh.yaml，并按需设置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 - id: prev_page translation: \u0026#34;上一页\u0026#34; - id: next_page translation: \u0026#34;下一页\u0026#34; - id: read_time translation: one : \u0026#34;1 分钟\u0026#34; other: \u0026#34;{{ .Count }} 分钟\u0026#34; - id: words translation: one: \u0026#34;字\u0026#34; other: \u0026#34;{{ .Count }} 字\u0026#34; - id: toc translation: \u0026#34;目录\u0026#34; - id: translations translation: \u0026#34;语言\u0026#34; - id: home translation: \u0026#34;主页\u0026#34; - id: edit_post translation: \u0026#34;编辑\u0026#34; - id: code_copy translation: \u0026#34;Copy\u0026#34; - id: code_copied translation: \u0026#34;Done\u0026#34; 添加MathJax 创建themes/PaperMod/layouts/partials/mathjax.html，输入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; async src=\u0026#34;https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[\u0026#39;$\u0026#39;, \u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;]], displayMath: [[\u0026#39;$$\u0026#39;, \u0026#39;$$\u0026#39;], [\u0026#39;\\[\\[\u0026#39;, \u0026#39;\\]\\]\u0026#39;]], processEscapes: true, processEnvironments: true, skipTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;], TeX: { equationNumbers: { autoNumber: \u0026#34;AMS\u0026#34; }, extensions: [\u0026#34;AMSmath.js\u0026#34;, \u0026#34;AMSsymbols.js\u0026#34;] } }, \u0026#34;HTML-CSS\u0026#34;: { availableFonts: [\u0026#34;Arial\u0026#34;, \u0026#34;TeX\u0026#34;], preferredFont: \u0026#34;TeX\u0026#34;, webFont: \u0026#34;TeX\u0026#34; } }); MathJax.Hub.Queue(function () { // Fix \u0026lt;code\u0026gt; tags after MathJax finishes running. This is a // hack to overcome a shortcoming of Markdown. Discussion at // https://github.com/mojombo/jekyll/issues/199 var all = MathJax.Hub.getAllJax(), i; for (i = 0; i \u0026lt; all.length; i += 1) { all[i].SourceElement().parentNode.className += \u0026#39; has-jax\u0026#39;; } }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; code.has-jax { font: inherit; font-size: 100%; background: inherit; border: inherit; color: #515151; } \u0026lt;/style\u0026gt; 打开themes/PaperMod/layouts/partials/extend_head.html文件，添加如下内容：\n1 2 \u0026lt;!-- MathJax Support --\u0026gt; {{ partial \u0026#34;mathjax.html\u0026#34; . }} 下面是一个泰勒级数展开的例子：\n$$f(x) = f(a) + f\u0026rsquo;(a)(x-a) + \\frac{f\u0026rsquo;\u0026rsquo;(a)}{2!}(x-a)^2 + \\cdots + \\frac{f^{(n)}(a)}{n!}(x-a)^n + R_n(x)$$\n其中，$f(a)$表示在点$a$处的函数值，$f\u0026rsquo;(a)$表示在点$a$处的导数值，$f\u0026rsquo;\u0026rsquo;(a)$表示在点$a$处的二阶导数值，以此类推，$R_n(x)$为余项：$$R_n(x) = \\frac{f^{(n+1)}(c)}{(n+1)!}(x-a)^{n+1}$$\n自定义头部 Hugo 提供了一个默认的文章使用模板，位于archetypes/default.md，里面包括一些基本内容标题、日期以及是否为草稿。\n为方便写作，在文件夹 archetypes 中创建post.md 文件，并写入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} lastmod: {{ .Date }} author: [\u0026#34;kdjlyy\u0026#34;] summary: \u0026#34;\u0026#34; # 简单描述，会展示在主页，可被搜索 weight: # 输入1可以顶置文章 draft: false # 是否为草稿 comments: true # 是否开启评论 showToc: true # 显示目录 TocOpen: true # 自动展开目录 autonumbering: true # 目录自动编号 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 searchHidden: false # 该页面不能被搜索到 showbreadcrumbs: true # 顶部显示当前路径 mermaid: true # 是否开启mermaid cover: image: \u0026#34;\u0026#34; # 封面图片 hidden: true # 文章页面隐藏封面图片 tags: - tag 1 - tag 2 --- 根据定义好的模板，在此利用该模板生成关于页面，根目录执行执行命令：\n1 hugo new --kind post content/posts/tech/xx.md 自定义字体 本博客使用落霞孤鹜系列字体，正文使用 LXGW WenKai Lite 字体，代码块英文使用 JetBrains Mono 字体，中文使用 LXGW WenKai Screen 字体，公式使用 Arial 字体。\n打开themes/PaperMod/layouts/partials/extend_head.html文件，这个是会插入到 \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; 中间的内容，添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!-- 文章字体设置 --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; body { font-family: \u0026#34;LXGW WenKai Lite\u0026#34;, sans-serif; font-family: \u0026#34;LXGW WenKai Screen\u0026#34;, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; 详细内容参考：https://github.com/lxgw/LxgwWenKai/issues/24\n打开themes/PaperMod/assets/css/extended/blank.css ，这个是可以自定义样式的地方，添加：\n1 2 3 4 5 6 7 8 9 /* ========== 正文字体：落霞孤鹜 ========== */ body { font-family: \u0026#34;LXGW WenKai Lite\u0026#34;, sans-serif !important; } /* ========== 代码字体：JetBrains Mono ========== */ code { font-family: \u0026#34;JetBrains Mono\u0026#34;, \u0026#34;LXGW WenKai Screen\u0026#34;, \u0026#34;LXGW WenKai Lite\u0026#34;, sans-serif; } 为了让 MathJax 公式更加美观，需要在themes/PaperMod/layouts/partials/mathjax.html文件的MathJax.Hub.Config配置中添加：\n1 2 3 4 5 \u0026#34;HTML-CSS\u0026#34;: { availableFonts: [\u0026#34;Arial\u0026#34;, \u0026#34;TeX\u0026#34;], preferredFont: \u0026#34;TeX\u0026#34;, webFont: \u0026#34;TeX\u0026#34; } ​\t示例：$\\sum_{i=0}^N\\int_{a}^{b}g(t,i)\\text{d}t$\n添加busuanzi busuanzi 插件可以提供站点访问量和文章阅读数的计数服务，因为打开该功能会略微降低网站加载速度，所以默认关闭该功能。\n打开themes/PaperMod/layouts/partials/head.html，在{{- /* Styles */}}这一行前面添加如下代码：\n1 2 3 4 5 \u0026lt;!-- busuanzi --\u0026gt; {{- if site.Params.busuanzi.enable -}} \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;no-referrer-when-downgrade\u0026#34;\u0026gt; {{- end }} 在站点底部显示总访问量与访客数，打开footer.html一般和head.html同目录，添加如下代码，注意添加在\u0026lt;footer\u0026gt;代码块里：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- busuanzi --\u0026gt; {{ if .Site.Params.busuanzi.enable -}} \u0026lt;div class=\u0026#34;busuanzi-footer\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_site_pv\u0026#34;\u0026gt; 本站总访问量\u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次 \u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_site_uv\u0026#34;\u0026gt; 本站访客数\u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;人次 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} 用于显示每篇文章阅读量，在themes/PaperMod/layouts/_default/single.html，一样注意加在\u0026lt;header\u0026gt;代码块内：\n1 2 3 4 5 6 \u0026lt;!-- busuanzi --\u0026gt; {{ if .Site.Params.busuanzi.enable -}} \u0026lt;div class=\u0026#34;meta-item\u0026#34;\u0026gt;\u0026amp;nbsp·\u0026amp;nbsp \u0026lt;span id=\u0026#34;busuanzi_container_page_pv\u0026#34;\u0026gt;本文阅读量\u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{- end }} 回到根目录改config.yml，在params里加上两行：\n1 2 3 params: busuanzi: enable: true 修改post_meta头部信息 post_meta 样式 定位到文件：themes/PaperMod/layouts/partials/post_meta.html，替换如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 {{- $scratch := newScratch }} \u0026lt;!-- 创建时间 --\u0026gt; {{- if not .Date.IsZero -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (printf \u0026#34;创建:\u0026amp;nbsp;\u0026lt;span title=\u0026#39;%s\u0026#39;\u0026gt;%s\u0026lt;/span\u0026gt;\u0026#34; (.Date) (.Date.Format (default \u0026#34;January 2, 2006\u0026#34; .Site.Params.DateFormat)))) }} {{- end }} \u0026lt;!-- 更新时间 --\u0026gt; {{- if (.Param \u0026#34;ShowLastMod\u0026#34;) -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (printf \u0026#34;更新:\u0026amp;nbsp;%s\u0026#34; (.Lastmod.Format (.Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34;)))) }} {{- end }} \u0026lt;!-- 统计字数 --\u0026gt; {{- if (.Param \u0026#34;ShowWordCounts\u0026#34;) -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (default (printf \u0026#34;字数:\u0026amp;nbsp;%d字\u0026#34; .WordCount))) }} {{- end }} \u0026lt;!-- 大概需要花费的阅读时间 --\u0026gt; {{- if (.Param \u0026#34;ShowReadingTime\u0026#34;) -}} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice (default (printf \u0026#34;时长: %d分钟\u0026#34; .ReadingTime))) }} {{- end }} \u0026lt;!-- 作者 --\u0026gt; {{- with (partial \u0026#34;author.html\u0026#34; .) }} {{- $scratch.Add \u0026#34;meta\u0026#34; (slice .) }} {{- end }} \u0026lt;!-- 分隔方式 --\u0026gt; {{- with ($scratch.Get \u0026#34;meta\u0026#34;) }} {{- delimit . \u0026#34;\u0026amp;nbsp;|\u0026amp;nbsp;\u0026#34; -}} {{- end -}} 作者的中文显示要找themes/PaperMod/layouts/partials/author.html，设置如下：\n1 2 3 4 5 6 7 8 9 {{- if or .Params.author site.Params.author }} 作者:\u0026amp;nbsp;{{- $author := (.Params.author | default site.Params.author) }} {{- $author_type := (printf \u0026#34;%T\u0026#34; $author) }} {{- if (or (eq $author_type \u0026#34;[]string\u0026#34;) (eq $author_type \u0026#34;[]interface {}\u0026#34;)) }} {{- (delimit $author \u0026#34;, \u0026#34; ) }} {{- else }} {{- $author }} {{- end }} {{- end -}} 因为有些字段是自己加的，所以还要在config.yml文件的params字段下加上这些字段：\n1 2 3 4 5 params: DateFormat: \u0026#34;2006-01-02\u0026#34; ShowWordCounts: true ShowReadingTime: true ShowLastMod: true 在每篇文章开头记得加上“date”、“lastmod”、“author”这三个字段，已经集成在 archetypes/post.md 里面了，这样每次创建文章就会自动生成，生成文章的命令：\n1 hugo new --kind post content/posts/tech/xx.md 参考：Hugo博客修改post_meta头部信息\n添加背景图片 通过浏览器定位 html 代码，发现背景图片在 list 标签下，所以需要：\n打开themes/PaperMod/assets/css/extended/blank.css，添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 主页背景图片 */ .list { /* 添加!important表示覆盖默认的设置 */ background-image: url(\u0026#34;../../img/white_mountains.jpg\u0026#34;) !important; /* 照片不重复出现 */ background-repeat: no-repeat; /* 照片大小 */ background-size: 100% 100%; /* 右侧滚动时照片固定大小 */ background-attachment: fixed; } .dark.list { /* 添加!important表示覆盖默认的设置 */ background-image: url(\u0026#34;../../img/white_mountains_dark.jpg\u0026#34;) !important; background-repeat: no-repeat; background-size: 100% 100%; background-attachment: fixed; } 这里我是将图片源文件放在public/img目录下，也可以使用 URL 的方式填写。\n文章自动编号 个人在写用 markdown 文章时一般用二级标题##开始，希望写文章时能有类似于 $LaTeX$ 的体验，这个在 Typora 中很容易实现，只需要添加对应的 css 样式即可，网络上很容易找到对应的教程。\n在 Hugo 的 PaperMod 主题中，以下操作可以实现目录和正文的自动编号：\n打开themes/PaperMod/layouts/_default/single.html文件，将\n1 \u0026lt;article class=\u0026#34;post-single\u0026#34;\u0026gt; 替换为：\n1 \u0026lt;article class=\u0026#34;post\u0026#34; {{- if .Param \u0026#34;autonumbering\u0026#34; }} autonumbering {{- end }}\u0026gt; 打开themes/PaperMod/assets/css/extended/blank.css，添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* ========= 文章和目录自动编号（从二级标题开始）============ */ body { counter-reset: h2 } h2 { counter-reset: h3 } h3 { counter-reset: h4 } h4 { counter-reset: h5 } article[autonumbering] h2:before { counter-increment: h2; content: counter(h2) \u0026#34;. \u0026#34; } article[autonumbering] h3:before { counter-increment: h3; content: counter(h2) \u0026#34;.\u0026#34; counter(h3) \u0026#34; \u0026#34; } article[autonumbering] h4:before { counter-increment: h4; content: counter(h2) \u0026#34;.\u0026#34; counter(h3) \u0026#34;.\u0026#34; counter(h4) \u0026#34; \u0026#34; } article[autonumbering] .toc ul { counter-reset: item } article[autonumbering] .toc li a:before { content: counters(item, \u0026#34;.\u0026#34;) \u0026#34; \u0026#34;; counter-increment: item } 在文章头部信息前面设置autonumbering: true即可完成正文和目录的自动编号功能。\n封面图片缩小并移到侧边 PaperMod 主题会因为插入了封面图片导致文章磁贴高度变大，达不到美观统一的要求，下面操作可以做到将封面图片缩小并移到右侧，效果如图：\n封面图片缩小并移到侧边 打开themes/PaperMod/layouts/_default/list.html，添加一个 class 标识，命名为post-info，把 entry-header 和 entry-content 和 entry-footer 都包裹进去，具体修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;article class=\u0026#34;{{ $class }}\u0026#34;\u0026gt; \u0026lt;!-- {{- $isHidden := (site.Params.cover.hidden | default site.Params.cover.hiddenInList) }} {{- partial \u0026#34;cover.html\u0026#34; (dict \u0026#34;cxt\u0026#34; . \u0026#34;IsHome\u0026#34; true \u0026#34;isHidden\u0026#34; $isHidden) }} --\u0026gt; \u0026lt;div class=\u0026#34;post-info\u0026#34;\u0026gt; \u0026lt;header class=\u0026#34;entry-header\u0026#34;\u0026gt; \u0026lt;h2\u0026gt; {{- .Title }} {{- if .Draft }}\u0026lt;sup\u0026gt;\u0026lt;span class=\u0026#34;entry-isdraft\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;[draft]\u0026lt;/span\u0026gt;\u0026lt;/sup\u0026gt; {{- end }} \u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; {{- if (ne (.Param \u0026#34;hideSummary\u0026#34;) true) }} \u0026lt;div class=\u0026#34;entry-content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ .Summary | plainify | htmlUnescape }}{{ if .Truncated }}...{{ end }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; {{- end }} {{- if not (.Param \u0026#34;hideMeta\u0026#34;) }} \u0026lt;footer class=\u0026#34;entry-footer\u0026#34;\u0026gt; {{- partial \u0026#34;post_meta.html\u0026#34; . -}} \u0026lt;/footer\u0026gt; {{- end }} \u0026lt;/div\u0026gt; {{- $isHidden := (.Site.Params.cover.hidden | default .Site.Params.cover.hiddenInList) }} {{- partial \u0026#34;cover.html\u0026#34; (dict \u0026#34;cxt\u0026#34; . \u0026#34;IsHome\u0026#34; true \u0026#34;isHidden\u0026#34; $isHidden) }} \u0026lt;a class=\u0026#34;entry-link\u0026#34; aria-label=\u0026#34;post link to {{ .Title | plainify }}\u0026#34; href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/article\u0026gt; 打开themes/PaperMod/assets/css/extended/blank.css，添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* 封面图片显示到右边 */ .entry-cover1 { border-radius: 10px; display: flex; justify-content: center; } .post-entry { display: flex; flex-direction: row; align-items: center; } .entry-cover { border-radius: 10px; overflow: hidden; width: 50%; margin-bottom: unset; max-height: 150px; display: grid; align-content: center; } .post-info { display: inline-block; overflow: hidden; width: 100%; padding-right: 10px; } /* 文章内使用的封面图 */ .entry-cover1 img { border-radius: var(--radius); pointer-events: none; width: 100%; height: auto; margin-bottom: 40px; } 因为上面对文章封面图片进行了调整，会影响到文章里面顶部的图片展示，所以需要解决冲突：\n定位到目录themes/PaperMod/layouts/partials/cover.html，在相同目录下创建一个名字为cover1.html的文件，并把cover.html里的文件复制一份一样的到cover1.html下；\n把cover1.html文件里的\u0026lt;figure class=\u0026quot;entry-cover\u0026quot;\u0026gt;修改为\u0026lt;figure class=\u0026quot;entry-cover1\u0026quot;\u0026gt;；\n定位到themes/PaperMod/layouts/_default/single.html，把{{- partial \u0026quot;cover.html\u0026quot; (dict \u0026quot;cxt\u0026quot; . \u0026quot;IsHome\u0026quot; false \u0026quot;isHidden\u0026quot; $isHidden) }}改为{{- partial \u0026quot;cover1.html\u0026quot; (dict \u0026quot;cxt\u0026quot; . \u0026quot;IsHome\u0026quot; false \u0026quot;isHidden\u0026quot; $isHidden) }}，这样文章封面调用的是经过修改的图片，而文章里面顶部的图片调用的是未经修改的图片。\n如果只需要封面图片，但是不需要文章顶部的图片需要在写作时设置头部：\n1 2 3 cover: image: \u0026#34;\u0026#34; # 封面图片 hidden: true # 文章页面隐藏封面图片 添加utterances评论 utterances 是一款基于 GitHub issues 的评论工具，优点是极其轻量、加载非常快、配置比较简单。\n首先创建一个 Github 仓库保存个人博客的评论内容，例如：blog_comments；\n进入 utterances app 对自己所要保存评论的仓库授权；\n创建themes/PaperMod/layouts/partials/comments.html，输入：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- github comments --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;pagination__title\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;pagination__title-h\u0026#34; style=\u0026#34;font-size: 20px;\u0026#34;\u0026gt;评论\u0026lt;/span\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;tcomment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;GitHub仓库名称（如：kdjlyy/blog_comments）\u0026#34; issue-term=\u0026#34;title\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; 在博客配置文件config.yml中的params字段添加配置：\n1 2 3 4 5 utteranc: enable: true repo: \u0026#34;kdjlyy/blog_comments\u0026#34; issueTerm: \u0026#34;title\u0026#34; theme: \u0026#34;github-light\u0026#34; ","permalink":"https://kdjlyy.cn/posts/site/hugo-papermod-optimization/","summary":"PaperMod, 主题优化, 标签页面, MathJax, 自定义头部, 自定义字体, 卜算子, busuanzi, post_meta, 背景图片, 自动编号, utterances, 评论","title":"PaperMod主题优化"},{"content":"新建Github仓库 新建一个 GitHub Repository，库名为 username.github.io，username 即你的 GitHub 账号 username。\n新建 Github 仓库 配置文件 在上一篇文章中我们在本地快速启动了 Hugo 博客：\n基于Hugo搭建静态博客 日期: 2023-05-30 \u0026nbsp; 标签: #Hugo\u0026nbsp; #PaperMod\u0026nbsp; hugo, 静态博客, PaperMod, 快速启动 ...... 其中站点配置文件改成了 .yml 后缀的写法，因为这样比默认的 .toml 写法更易用，详细参考：Configure Hugo。\n下面是我的 config.yml 配置，注意不同的主题配置方法可能有差异，我使用的是 PaperMod 主题。部分信息根据需要自行更改，例如我绑定了个人域名所以 baseURL 设置的是自己购买的域名，也可以配置使用 Github 仓库的域名访问博客主页。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 baseURL: https://kdjlyy.cn # baseURL: https://kdjlyy.github.io languageCode: zh-cn title: 向着悠远的苍穹 theme: PaperMod paginate: 10 # 首页每页显示的文章数 hasCJKLanguage: true # 自动检测是否包含中文日文韩文,如果文章中使用了很多中文引号的话可以开启 enableInlineShortcodes: true # 允许内联短码 enableEmoji: true # 允许使用 Emoji 表情，建议 true enableRobotsTXT: true # 允许爬虫抓取到搜索引擎，建议 true summaryLength: 90 # 文章内链卡片获取的文章长度默认是70 buildDrafts: false buildFuture: false buildExpired: false # pygmentsUseClasses: true # googleAnalytics: UA-123-45 minify: disableXML: true # minifyOutput: true permalinks: # 浏览器链接显示方式 post: \u0026#34;/:title/\u0026#34; # post: \u0026#34;/:year/:month/:day/:title/\u0026#34; defaultContentLanguage: zh # 最顶部首先展示的语言页面 defaultContentLanguageInSubdir: true languages: zh: languageName: \u0026#34;Chinese\u0026#34; # contentDir: content/english weight: 1 profileMode: enabled: true title: # 主页标题 subtitle: # 主页副标题 imageUrl: \u0026#34;img/logo.ico\u0026#34; # 头像 imageTitle: imageWidth: 150 imageHeight: 150 buttons: - name: 👨🏻‍💻技术 url: posts/tech - name: 📋建站 url: posts/site - name: 📕阅读 url: posts/read - name: 🏖生活 url: posts/life menu: main: - identifier: search name: 🔍搜索 url: search weight: 1 - identifier: home name: 🏠主页 url: / weight: 2 - identifier: posts name: 📚文章 url: /posts weight: 3 - identifier: archives name: ⏱️时间轴 url: /archives weight: 20 # - identifier: categories # name: 🧩分类 # url: /categories # weight: 30 - identifier: tags name: 🔖标签 url: /tags weight: 40 - identifier: about name: 🙋🏻‍♂️关于 url: /about weight: 50 # - identifier: links # name: 🤝友链 # url: links # weight: 60 outputs: home: - HTML - RSS - JSON params: env: production # to enable google analytics, opengraph, twitter-cards and schema. description: \u0026#34;向着悠远的苍穹, kdjlyy\u0026#39;s Blog\u0026#34; author: kdjlyy # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] defaultTheme: light # defaultTheme: light or dark disableThemeToggle: false DateFormat: \u0026#34;2006-01-02\u0026#34; # ShowShareButtons: true ShowReadingTime: false # disableSpecialistPost: true displayFullLangName: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true hideFooter: false # 隐藏页脚 ShowWordCounts: true VisitCount: true ShowLastMod: true #显示文章更新时间 ShowToc: true # 显示目录 TocOpen: true # 自动展开目录 comments: true busuanzi: enable: false # 访问量统计，开启会降低加载速度 socialIcons: - name: github url: \u0026#34;https://github.com/kdjlyy\u0026#34; - name: bilibili url: \u0026#34;https://space.bilibili.com/279296780\u0026#34; - name: QQ url: \u0026#34;img/qq.jpg\u0026#34; - name: email url: \u0026#34;kdjlyy@qq.com\u0026#34; # - name: RSS # url: \u0026#34;index.xml\u0026#34; # - name: QQ # url: \u0026#34;img/qq.png\u0026#34; # - name: Phone # url: \u0026#34;img/phone.png\u0026#34; # editPost: # URL: \u0026#34;https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content\u0026#34; # Text: \u0026#34;Suggest Changes\u0026#34; # edit text # appendFilePath: true # to append file path to Edit link # label: # text: \u0026#34;Home\u0026#34; # icon: icon.png # iconHeight: 35 assets: favicon: \u0026#34;img/logo.ico\u0026#34; favicon16x16: \u0026#34;img/logo.ico\u0026#34; favicon32x32: \u0026#34;img/logo.ico\u0026#34; apple_touch_icon: \u0026#34;logo.ico\u0026#34; safari_pinned_tab: \u0026#34;logo.ico\u0026#34; # cover: # hidden: true # hide everywhere but not in structured data # hiddenInList: true # hide on list pages and home # hiddenInSingle: true # hide on single page fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 1 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;] # twikoo: # version: 1.4.11 # 评论 utteranc: enable: true repo: \u0026#34;kdjlyy/blog_comments\u0026#34; issueTerm: \u0026#34;title\u0026#34; theme: \u0026#34;github-light\u0026#34; taxonomies: category: categories tag: tags series: series markup: goldmark: renderer: unsafe: true # HUGO 默认转义 Markdown 文件中的 HTML 代码，如需开启的话 highlight: # anchorLineNos: true # 代码行号下加下划线 codeFences: true # 代码围栏功能，这个功能一般都要设为true，不然很难看 guessSyntax: true # 猜测语法，这个功能建议设置为true, 如果你没有设置要显示的语言则会自动匹配 lineNos: true # 代码行号 style: nord # monokai, darcula, solarized-dark, nord lineNumbersInTable: true # 使用表来格式化行号和代码,而不是标签。这个属性一般设置为 true # hl_Lines：高亮的行号，一般这个不设置，因为每个代码块我们可能希望让高亮的地方不一样 # lineNoStart：行号从编号几开始，一般从 1 开始 # lineNos：是否显示行号，我比较喜欢显示，所以我设置的为 true # noClasses: true # 使用 class 标签，而不是内嵌的内联样式 privacy: vimeo: disabled: false simple: true twitter: disabled: false enableDNT: true simple: true instagram: disabled: false simple: true youtube: disabled: false privacyEnhanced: true services: instagram: disableInlineCSS: true twitter: disableInlineCSS: true 目录结构 个人的目录配置如下，搭配上面的配置文件使用。\n文章目录结构 博客文章都是存放在content目录下的，具体的目录结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 content/ ├── posts/ │\t├── life/ │\t│\t└── _index.md │\t├── read/ │\t│\t└── _index.md │\t├── site/ │\t│\t├── xxx.md │\t│\t└── _index.md │\t├── tech/ │\t│\t└── _index.md │\t└── _index.md ├── about.md ├── archive.md └── search.md about.md、archive.md、search.md 分别对应右上角关于、时间轴、搜索三个页面。\nlife、read、site、tech 对应首页的四个按钮，content 里每个文件夹内都要添加一个 _index.md 文件。在对应的文件夹下创建 markdown 文件即可将文章放入对应的分类中。\nabout.md 1 2 3 4 5 6 7 8 9 10 --- title: \u0026#34;关于\u0026#34; layout: \u0026#34;about\u0026#34; url: \u0026#34;/about/\u0026#34; summary: about hidemeta: true # 是否隐藏文章的元信息，如发布日期、作者等 showbreadcrumbs: false #顶部显示当前路径 searchHidden: true showToc: false --- archive.md 1 2 3 4 5 6 --- title: \u0026#34;时间轴\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives/\u0026#34; summary: archives --- search.md 1 2 3 4 5 6 7 8 --- title: \u0026#34;搜索\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # is necessary url: \u0026#34;/search/\u0026#34; # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; placeholder: \u0026#34;请输入关键词\u0026#34; --- life/_index.md 1 2 3 4 5 --- title: \u0026#34;🏖 生活\u0026#34; # description: \u0026#34;\u0026#34; hidemeta: true # 是否隐藏文章的元信息，如发布日期、作者等 --- read/_index.md 1 2 3 4 5 --- title: \u0026#34;📕 阅读\u0026#34; # description: hidemeta: true # 是否隐藏文章的元信息，如发布日期、作者等 --- site/_index.md 1 2 3 4 5 --- title: \u0026#34;📋 建站\u0026#34; # description: hidemeta: true # 是否隐藏文章的元信息，如发布日期、作者等 --- tech/_index.md 1 2 3 4 5 --- title: \u0026#34;👨🏻‍💻 技术\u0026#34; # description: \u0026#34;\u0026#34; hidemeta: true # 是否隐藏文章的元信息，如发布日期、作者等 --- 部署到 Github 写完博客后本地预览：hugo server -D，浏览器打开：http://localhost:1313/ 访问。\n输入hugo -D生成public文件夹，这个文件夹可以部署到云服务器或者托管到github上。\n⚠️注意：这种生成方式只会往 public 文件夹里添加内容，但是不会删除外部已经不存在而 public 里面还存在的文件，所以也可以用hugo -F --cleanDestinationDir命令，表示每次生成的public都是全新的，会覆盖原来的。\n将 public 文件夹上传到步骤1中的 username.github.io 仓库中\n1 2 3 4 5 6 7 cd public git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin git@github.com:xxx/xxx.github.io.git git push -u origin main 几十秒钟后，即可通过 Github 域名访问，例如我的 Github 博客域名为：https://kdjlyy.github.io/\n","permalink":"https://kdjlyy.cn/posts/site/hugo-papermod-configure/","summary":"hugo, papermod, 主题配置","title":"Hugo主题配置及Github部署"},{"content":"前言 一直想搭建一个记录自己学习与生活的博客，断断续续尝试过很多种方案，例如基于 Typecho 或 Wordpress 的动态博客，基于 Hexo + Coding 的静态博客。\n其中基于 Wordpress 搭建动态博客在互联网上的比例很大，有海量的模版和丰富的教程。Typecho 和 Wordpress 类似，只是前者更加轻量级，界面更加简洁，理论上加载速度更快。Wordpress 的功能更加强大，可以用于搭建论坛、购物网站等，个人觉得只用来写技术博客有点大材小用了。因为不想花费很多精力在博客网站的排版、样式等功能上，更想专注于写文章本身，所以之前使用过较长时间的 Typecho 博客。\n但是动态博客的优点和缺点都很明显，动态博客可以提供诸如在线发布、数据统计、用户注册等一系列在线服务，但是需要部署在云服务器上，一般需要搭配域名使用。然而个人并不常用以上的在线服务，所以更倾向使用静态博客。Hexo 和 Hugo 的区别不大，但是 Hexo 需要 nodejs 环境并且加载速度没有 Hugo 快，优点是 Hexo 的主题更多。\n最终权衡下还是使用 Hugo + PaperMod主题的方案搭建了静态博客。\n技术选型 博客框架：Hugo\n博客主题：PaperMod\n博客字体：LXGW WenKai、JetBrains Mono\n托管工具：Github 或云服务器\n写作工具：Typora\n免费图床：遇见图床\n优点：\n不需要购买云服务器和域名，网站托管在 Github 上（也可以部署到云服务器上，绑定域名）； 网站功能简洁，加载速度快，不用花费精力维护； 使用本地 Typora 写作，所见即所得。 快速启动 搭建过程中参考了如下博客及教程：Sulv\u0026rsquo;s Blog、 田少晗的个人博客、Memory\n安装Hugo 安装前需要准备 Go 和 Git 环境，以下是个人使用的环境，合适的版本即可。\n基础环境 版本号 系统 MacOS Ventura 13.0 (M1 Pro) Go go version go1.17.7 darwin/amd64 Git git version 2.37.1 (Apple Git-137.1) Mac 用户输入：\n1 brew install hugo 安装完成后输入hugo version验证，若出现版本信息则表示安装成功。\n新建站点 新建站点目录kdjlyy_blog，并将站点配置文件改为.yml后缀写法：\n1 hugo new site kdjlyy_blog -f yml 会自动生成以下目录结构：\n1 2 3 4 5 6 7 8 9 10 11 kdjlyy_blog/ ├── archetypes/ │ └── default.md ├── assets/ ├── content/ ├── data/ ├── layouts/ ├── public/ ├── static/ ├── themes/ └── config.yml 目录结构详细介绍参考：https://gohugo.io/getting-started/directory-structure/\n下载主题 在 Hugo Themes 官网下载喜欢的主题到themes文件夹，以个人使用的 PaperMod 主题为例：\n1 2 cd themes git clone git@github.com:adityatelange/hugo-PaperMod.git ​\t把文件夹名称由 hugo-PaperMod 改为 PaperMod，方便后续配置。\n在站点文件夹下的配置文件config.yaml里配置主题：\n1 2 3 4 baseURL: \u0026#34;/\u0026#34; languageCode: \u0026#39;en-us\u0026#39; title: \u0026#39;My Blog\u0026#39; theme: \u0026#34;PaperMod\u0026#34; 新建文章 在站点目录下，新建文章：\n1 hugo new posts/first-blog.md 此时first-blog.md将自动生成在content/posts目录下:\n1 2 3 4 5 --- title: \u0026#34;First Blog\u0026#34; date: 2023-05-30T17:17:15+08:00 draft: false --- 在后面使用 markdown 格式书写即可。\n本地运行 在站点目录下执行命令：\n1 hugo server -D 进入 http://localhost:1313/ 即可访问个人主页。\n","permalink":"https://kdjlyy.cn/posts/site/site-init/","summary":"hugo, 静态博客, PaperMod, 快速启动","title":"基于Hugo搭建静态博客"},{"content":"大数 大数加法 aaaa\n大数乘法 二进制 负二进制转换 https://leetcode.cn/problems/convert-to-base-2/\n负二进制数相加 https://leetcode.cn/problems/adding-two-negabinary-numbers/solutions/2273578/fu-er-jin-zhi-shu-xiang-jia-by-leetcode-nwktq/\n","permalink":"https://kdjlyy.cn/posts/tech/algorithm-simulation/","summary":"大数 大数加法 大数乘法","title":"常见算法-模拟篇"},{"content":"Linux用户空间内存分布 程序内存在地址空间中的分布情况称为内存模型。\n对于32位环境，理论上程序可以拥有4GB的虚拟地址空间，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间。\nLinux默认将高地址的1GB空间分配给内核。也就是说，应用程序只能使用剩下3GB的地址空间，称为用户空间。\nLinux用户空间内存分布 | 内存分区 | 说明| | :--------| ------- | | text段（程序代码 区） | 存放已编译程序的机器代码，只读。| | rodata段（常量区） | 存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。 | | data段（全局数据区的已初始化部分） | 存放已经初始化的全局变量和静态变量等，这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。 | | bss段（全局数据区的未初始化部分） | 存放未初始化的全局变量和静态变量等。| | heap（堆区）| 一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。 | | 文件/内存映射区（动态链接库） | 用于在程序运行期间加载和卸载动态链接库。例如使用 *mmap()* 创建内存映射区时，就是在这里申请的内存空间。 | | stack（栈区）| 存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。 | Linux程序内存空间 Linux 下内存资源是通过虚拟内存管理的，在分配内存时并不是在物理内存开辟了一段空间，而是在使用时才分配的，并且是通过段页式管理。linux 下内存分配是以页为单位的，而页是通过段管理。各个段之间是独立的，方便管理。\nLinux 程序执行时能够分为下面几个内存段：text、rodata、data、bss、stack、heap。\ntext 段（代码段）：text 段存放程序代码，运行前就已经确定（编译时确定），通常为只读； rodata 段（常量区）：rodata 段存储常量数据，比如程序中定义为 const 的全局变量，“#define”定义的常量，以及诸如“Hello World”的字符串常量。const 修饰的全局变量在常量区，const 修饰的局部变量只是为了防止修改，没有放入常量区（存在栈区）； data 段：data 存储已经初始化的全局变量（静态变量），属于静态内存分配，需要占用可执行文件空间（注意：初始化为0的全局变量和静态变量还是被保存在 bss 段）； bss 段：bss 段存储没有初始化或初始化为0的全局变量（静态变量），属于静态内存分配。bss 不占用可执行文件空间，其内容由操作系统初始化（清零），但占据程序运行时的内存空间； stack 段：stack 段存储参数变量和局部变量，由系统进行申请和释放，属于静态内存分配； heap 段：heap 段是程序运行过程中动态分配的内存段，由用户申请和释放，程序中不释放，则程序结束时，由 OS 回收。 执行文件中包含了 text、rodata、data 段的内容，不包含 bss 段内容（一堆0放入执行文件没有意义）。 堆和栈的内存增长方向是相反的：栈是从高地址向低地址生长，堆是从低地址向高地址生长。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const int NUM = 10086; // 常量区(rodata段) int a = 10; // 全局初始化区（data） char *p1; // 全局未初始化区（bss） int main() { int b; // 栈区 char s[] = \u0026#34;abc\u0026#34;; // 栈区 char *p; // 栈区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); // 分配得来的10和20字节的区域就在堆区 static int c =0; // bss段 const int d = 5; // stack段 char *p3 = \u0026#34;123456\u0026#34;; // p3在栈区，\u0026#34;123456\\0\u0026#34; 在rodata段 strcpy(p1, \u0026#34;123456\u0026#34;); // \u0026#34;123456\\0\u0026#34; 放在rodata段，编译器可能会将它与p3所指向的\u0026#34;123456\u0026#34;优化成一个地方。 } 虚拟内存 物理内存是实际的物理空间，即直接映射到硬件 RAM 的物理内存资源。\n虚拟内存是逻辑上的地址空间，它通过将物理内存和硬盘空间组合使用，从逻辑上扩展了物理内存的大小，从而让程序获得更多的可用内存。\n为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个页（Linux下页大小为4KB，即4096字节）。而物理内存则被分成相同大小的页面帧，程序的页被映射到物理内存对应的帧（但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中）。当程序访问到不在物理内存中的页时，发生缺页中断，将缺失的页装入物理内存并重新执行失败的指令。\n从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生16位地址，那么一个程序的地址空间范围是0~64K。该计算机只有32KB的物理内存，虚拟内存技术允许该计算机运行一个64K大小的程序。\n虚拟内存 new/delete 和 malloc/free new 和 delete 是用户进行动态内存申请和释放的操作符，operator new 和 operator delete 是系统提供的全局函数，new 在底层调用 operator new 全局函数来申请空间，delete 在底层通过 operator delete 全局函数来释放空间。\nnew的过程\n调用 operator new 函数申请空间； 在申请的空间上执行构造函数，完成对象的构造。 delete的过程\n在申请的空间上执行析构函数，完成对象中资源的清理工作； 调用 operator delete 函数释放对象的空间。 new T[N]的过程\n调用 operator new[] 函数，在 operator new[] 中实际调用 operator new 函数完成N个对象空间的申请； 在申请的空间上执行N次构造函数。 delete[]的过程\n在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理； 调用 operator delete[] 释放空间，实际在 operator delete[] 中调用 operator delete 来释放空间。 new/delete 和 malloc/free的异同 相同点是: 都是从堆上申请空间，并且需要用户手动释放。\n不同点是:\nmalloc 和 free 是函数，new 和 delete 是操作符； malloc 申请的空间不会初始化，new 可以初始化； malloc 申请空间时，需要手动计算空间大小并传递，new 只需在其后跟上空间的类型即可； malloc 的返回值为 void*, 在使用时必须强转；new 不需要，因为 new 后跟的是空间的类型； malloc 申请空间失败时，返回的是 NULL，因此使用时必须判空；new 不需要，但是 new 需要捕获异常； 申请自定义类型对象时，malloc/free 只会开辟与销毁空间，不会调用构造函数与析构函数；而 new 在申请空间后会调用构造函数完成对象的初始化，delete 在释放空间前会调用析构函数完成空间中资源的清理； new/delete 比 malloc/free 的效率稍微低点，因为 new/delete 的底层封装了 malloc/free。 free 如何知道要 free 多大的空间 malloc 函数的实现是以块分配内存，在被分配的块中包括两部分：\n第一部分中存储含有报头的元数据，它其中包含有分配块的大小信息，是一个常量； 第二部分中存储实际用户数据。而使用 malloc 分配内存返回的是第二部分用户数据的地址。 所以内存释放时不再需要再指定释放多大的内存空间，只需要指定该块内存空间的首地址即可。\nnew 一个对象时加括号和不加括号的区别 对于内置类型：\nint *a = new int; 不会将申请到的 int 空间初始化，而 int *a = new int(); 则会将申请到的 int 空间初始化为0。\n1 2 int *a1 = new int[10]; // 10个未初始化int int *a2 = new int[10](); // 10个值初始化为0的int 对于自定义类类型：\n如果该类显式定义了默认构造函数，那么 class c = new class; 和 class c = new class(); 一样，都会调用默认构造函数。\n如果该类没有显式定义构造函数（由编译器生成默认构造函数）但有虚函数，那么 class c = new class; 和 class c = new class(); 一样，都会调用默认构造函数；\n如果该类没有显式定义构造函数（由编译器生成默认构造函数）也没有虚函数，那么 class c = new class 将不调用合成的默认构造函数，而 class c = new class() 则会调用默认构造函数。\nmalloc/free 实现原理 brk 和 mmap 函数 brk() 和 sbrk() 函数：作用是扩展 heap 的上界 brk\n1 2 3 4 5 // addr为新的brk地址，成功返回0，失败返回-1 int brk(const void *addr); // incr为需要申请的内存大小，返回heap新的上界brk地址。若sbrk的参数为0，则返回原来的brk地址 void* sbrk (intptr_t incr); mmap() 和 munmap() 函数：映射磁盘文件到内存中或匿名映射（向映射区申请一块内存）\n1 2 3 4 5 6 7 // addr为映射区的开始地址，length为映射区的长度，prot为期望的内存保护标志， // flags指定映射对象的类型，fd为文件描述符，offset为文件映射的偏移量，通常设置为0， // 代表从文件最前方开始对应，offset必须是分页大小的整数倍 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); // munmap执行与mmap相反的操作，删除特定地址区域的对象映射 int munmap(void *addr, size_t length); 实现原理 malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。\n方式一：如果用户分配的内存 $\u0026lt;128 KB$，则通过 brk() 系统调用从堆分配内存；\n方式二：如果用户分配的内存 $\\geq128 KB$，则通过 mmap() 系统调用在文件/内存映射区域分配内存。\nbrk 是将 heap 的上界指针 brk 往高地址推，mmap 是在进程的虚拟地址空间中（堆和栈中间，称为内存/文件映射区域的地方）找一块空闲的虚拟内存。 这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。\nbrk 分配的内存需要等到高地址内存释放以后才能释放（这就是内存碎片产生的原因），当最高地址空间的空闲内存超过128K（可由 M_TRIM_THRESHOLD 选项调节）时，执行内存紧缩操作（trim）。 mmap 分配的内存可以单独释放。\nbrk和mmap 调用 free(A) 后 A 对应的虚拟内存和物理内存都没有释放，因为只有一个 brk 指针，如果往回推，那么 B 这块内存怎么办呢？ 当然 A 这块内存是可以重用的，如果这个时候再来一个 40KB 的请求，那么 malloc 很可能就使用 A 这块内存。 进程调用 free(B) 以后，A 和 B 连接起来，变成一块 150KB 的空闲内存，于是内存紧缩。\nmalloc 采用了内存池的实现方式：先申请一大块内存，然后将内存分成不同大小的内存块，用户申请内存时，直接从内存池中选择一块相近的内存块即可。brk 分配内存时优先从内存池获取，失败的话走 brk 系统调用。细节参考：简书：glibc内存管理那些事儿\n既然堆内内存 brk 和 sbrk 不能直接释放，导致疑似“内存泄露”问题，为什么不全部使用 mmap 来分配，munmap 直接释放，而是仅仅对于大于 128K 的大块内存才使用 mmap？\n因为 brk 和 mmap 都是系统调用，频繁调用系统调用都比较消耗系统资源。使用 mmap 申请的空间，直接调用 munmap 是将空间真正释放了，而 brk 释放的空间，并不一定真正释放了，那些没有被真正释放的内存碎片可以被重复利用，再次访问该内存可能不需产生任何系统调用和缺页中断，这将大大降低 CPU 的消耗。\nmalloc 和 tcmalloc malloc 和 tcmalloc 都是内存分配库，主要的不同在于实现方式和效率。\nmalloc 是C标准库中的一部分，是系统提供的内存分配器。它的主要作用是管理进程虚拟内存空间，负责分配和释放内存资源。但是，由于多线程并发执行时需要加锁，所以它的性能并不是最优的。 tcmalloc 是 Google 开发的一个高性能、多线程的内存管理库，是 malloc 的替代品之一。tcmalloc 采用线程本地缓存技术（Thread-Caching Malloc，TCMalloc），避免了锁的竞争，从而在多线程环境下具有更好的性能表现。此外，tcmalloc 还会将未使用的页面设置为“dirty”状态，提高缓存命中率，进一步提升了其效率。 总的来说，tcmalloc 比 malloc 具有更高的性能和更好的可扩展性，在大型高并发的应用场景中使用更为适合。但是，tcmalloc 也相对较复杂，需要结合实际情况进行使用和优化。\n参考：内存优化总结:ptmalloc、tcmalloc和jemalloc、ptmalloc、tcmalloc与jemalloc对比分析\n内存管理可以分为三个层次，自底向上分别是：\n内核层 C运行时库层（glibc 层使用系统调用维护的内存管理算法） 应用程序层（应用程序从 glibc 动态分配内存后，根据应用程序本身的程序特性进行优化，比如使用引用计数 std::shared_ptr，内存池方式等） 现状 目前大部分服务端程序使用 glibc 提供的 malloc/free 系列函数，而 glibc 使用的 ptmalloc2 在性能上远远弱后于 google 的 tcmalloc 和 facebook 的 jemalloc。而且后两者只需要使用 LD_PRELOAD 环境变量启动程序即可，甚至并不需要重新编译。\nptmalloc2 ptmalloc2 即是我们当前使用的 glibc malloc 版本。\nptmalloc2 操作 heap 时，一般大内存采用 mmap，小内存使用 brk。\n🔰 主分配区和非主分配区\nptmalloc 的内存分配器中，为了解决多线程锁争夺问题，分为主分配区（main_area）和非主分配区（no_main_area）。\n每个进程有一个主分配区，也可以允许有多个非主分配区。 主分配区可以使用 brk 和 mmap 来分配内存，而非主分配区只能使用 mmap 来映射内存块（批发申请 HEAP_MAX_SIZE 大小的虚拟内存）。当用户向非主分配区请求分配内存时再切割成小块“零售” 出去，毕竟系统调用是相对低效的，直接从用户空间分配内存快多了。所以 ptmalloc 在必要的情况下才会调用 mmap 函数向操作系统申请虚拟内存。 非主分配区的数量一旦增加，则不会减少。 主分配区和非主分配区形成一个环形链表进行管理。 当某一线程需要调用 malloc 分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么 malloc 会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。\n在释放操作中，线程同样试图获得待释放内存块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行释放操作。\n🔰 chunk 内存块的基本组织单元\nptmalloc 通过 chunk 的数据结构来组织每个内存单元。当我们使用 malloc 分配得到一块内存的时候，这块内存就会通过 chunk 的形式被 glibc 管理起来。你可以把它想象成自己写内存池的时候的一个内存数据结构。chunk 的结构可以分为使用中的 chunk 和空闲的 chunk。\n空闲的 chunk 会被放置到空闲的链表 bins 上。当用户 malloc 申请内存的时候，会先去查找空闲链表 bins上是否有合适的内存。\n🔰 空闲链表 bins\n当用户使用 free 函数释放掉的内存，ptmalloc 并不会马上交还给操作系统，而是被 ptmalloc 本身的空闲链表 bins 管理起来了，这样当下次进程需要 malloc 一块内存的时候，ptmalloc 就会从空闲的 bins 上寻找一块合适大小的内存块分配给用户使用。这样的好处可以避免频繁的系统调用，降低内存分配的开销。\nptmalloc ptmalloc 一共维护了128个 bin。每个 bin 都维护了大小相近的双向链表的 chunk。通过上图这个 bins 的列表就能看出，当用户调用 malloc 的时候，能很快找到用户需要分配的内存大小是否在维护的 bin 上，如果在某一个 bin 上，就可以通过双向链表去查找合适的 chunk 内存块给用户使用。\nfast bins：fast bins 是 bins 的高速缓冲区，大约有10个定长队列。当用户释放一块不大于 max_fast（默认值64B）的 chunk 的时候，会默认会被放到 fast bins 上。当用户下次需要申请内存的时候首先会到 fast bins 上寻找是否有合适的 chunk。ptmalloc 会遍历 fast bin，看是否有合适的 chunk 需要合并到 bins 上。 unsorted bin：是 bins 的一个缓冲区。当用户释放的内存大于 max_fast 或者 fast bins 合并后的 chunk 都会进入 unsorted bin 上。当用户 malloc 的时候，先会到 unsorted bin 上查找是否有合适的 bin，如果没有合适的 bin，ptmalloc 会将 unsorted bin 上的 chunk 放入 bins 上，然后到 bins 上查找合适的空闲 chunk。 small bins 和 large bins：small bins 和 large bins 是真正用来放置 chunk 双向链表的。每个 bin 之间相差8个字节，并且通过上面的这个列表，可以快速定位到合适大小的空闲 chunk。前64个为 small bins 定长；后64个为 large bins，非定长。 Top chunk：并不是所有的 chunk 都会被放到 bins 上。top chunk 相当于分配区的顶部空闲内存，当 bins 上都不能满足内存分配要求的时候，就会来 top chunk 上分配。 mmaped chunk：当分配的内存非常大（大于分配阀值，默认128K）的时候，需要被 mmap 映射，则会放到 mmaped chunk 上，当释放 mmaped chunk 上的内存的时候会直接交还给操作系统。 ✏️ 内存分配 malloc() 的流程\nmalloc()的流程 获取分配区的锁，防止多线程冲突；\n计算出需要分配的内存的 chunk 实际大小；\n判断chunk的大小，如果小于 max_fast（64B），则取 fast bins 上去查询是否有适合的 chunk，如果有则分配结束；\nchunk 大小是否小于512B，如果是，则从 small bins 上去查找 chunk，如果有合适的，则分配结束；\n继续从 unsorted bins 上查找：\n如果 unsorted bins 上只有一个 chunk 并且大于待分配的 chunk，则进行切割，并且剩余的 chunk 继续扔回 unsorted bins；\n如果 unsorted bins 上有大小和待分配 chunk 相等的，则返回，并从 unsorted bins 删除；\n如果 unsorted bins 中的某一 chunk 大小属于 small bins 的范围，则放入 small bins 的头部；\n如果 unsorted bins 中的某一 chunk 大小属于 large bins 的范围，则找到合适的位置放入；\n从 large bins 中查找，找到链表头后，反向遍历此链表，直到找到第一个大小大于待分配的 chunk，然后进行切割，如果有余下的，则放入 unsorted bin 中去，分配则结束；\n如果搜索 fast bins 和其他 bins 都没有找到合适的 chunk，那么就需要操作 top chunk 来进行分配了（top chunk 相当于分配区的剩余内存空间）。判断 top chunk 大小是否满足所需 chunk 的大小，如果是，则从 top chunk 中分出一块来；\n如果 top chunk 也不能满足需求，则需要扩大 top chunk。主分区上，如果分配的内存小于分配阀值（默认128K），则直接使用 brk 分配一块内存；如果分配的内存大于分配阀值，则需要 mmap 来分配。\n非主分区上，则直接使用 mmap 来分配一块内存。通过 mmap 分配的内存，就会放入 mmaped chunk 上，mmaped chunk 上的内存会直接回收给操作系统。\n✏️ 内存释放 free() 的流程\n获取分配区的锁，保证线程安全；\n如果 free 的是空指针，则返回，什么都不做；\n判断当前 chunk 是否是 mmap 映射区域映射的内存，如果是，则直接 munmap 释放这块内存。已使用 chunk 的数据结构中，有对应的标识判断是否是 mmap 映射的内存；\n判断 chunk 是否与 top chunk 相邻，如果相邻，则直接和 top chunk 合并（和 top chunk 相邻相当于和分配区中的空闲内存块相邻），转到步骤8；\n如果 chunk 的大小大于 max_fast（64B），则放入 unsorted bin，并且检查是否有合并，有合并情况并且和 top chunk 相邻，则转到步骤8；没有合并情况则 free；\n如果 chunk 的大小小于 max_fast（64B），则直接放入 fast bin，fast bin 并没有改变 chunk 的状态。没有合并情况，则 free；有合并情况，转到步骤7；\n在 fast bin，如果当前 chunk 的下一个 chunk 也是空闲的，则将这两个 chunk 合并，放入 unsorted bin 上面。合并后的大小如果大于64KB，会触发进行 fast bins 的合并操作，fast bins 中的 chunk 将被遍历，并与相邻的空闲 chunk 进行合并，合并后的 chunk 会被放到 unsorted bin 中，fast bin 会变为空。合并后的 chunk 和 top chunk 相邻，则会合并到 top chunk 中。转到步骤8；\n判断 top chunk 的大小是否大于 mmap 收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还 top chunk 中的一部分给操作系统。free 结束。\n✏️ ptmalloc 的问题\nptmalloc 的主要问题其实是内存浪费、内存碎片、以及加锁导致的性能问题。\n内存浪费：\n每个 chunk 本身至少8字节的开销很大；\n后分配的内存先释放，可能无法及时归还系统。因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放，top chunk 以下的 chunk 都无法释放；\n内存不能在线程间移动，多线程使用内存不均衡将导致内存浪费。\n内存碎片：不定期分配长生命周期的内存容易造成内存碎片，不利于回收。\n加锁导致的性能问题：加锁耗时，无论当前分区有无耗时，在内存分配和释放时，会首先加锁。\ntcmalloc tcmalloc 是 Google 开源的一个内存管理库， 作为 glibc malloc 的替代品。目前已经在 chrome、safari 等知名软件中运用。\n🔰 对象分配\ntcmalloc 为每个线程分配了一个线程本地 ThreadCache，小内存从 ThreadCache 分配，此外还有个中央堆（CentralCache），ThreadCache 不够用的时候，会从 CentralCache中 获取空间放到 ThreadCache 中。 小对象（$\\leq32KB$）从 ThreadCache 分配，大对象从 CentralCache 分配。大对象分配的空间都是4K页面对齐的，多个 pages 也能切割成多个小对象划分到 ThreadCache 中。 ✏️ tcmalloc的优势\n小内存可以在 ThreadCache 中不加锁分配（加锁的代价大约100ns） 大内存可以直接按照大小分配不需要再像 ptmalloc 一样进行查找 大内存加锁使用更高效的自旋锁 减少了内存碎片 内存对齐 什么事内存对齐？ 现代计算机中内存空间都是按照字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。\n为什么内存对齐？ 主要是由于 CPU 的访问内存的特性决定，CPU 访问内存时并不是以字节为单位来读取内存，而是以机器字长为单位，实际机器字长由 CPU 数据总线宽度决定的。实际 CPU 运行时，每一次控制内存读写信号发生时，CPU 可以从内存中读取数据总线宽度的数据，并将其写入到 CPU 的通用寄存器中。内存对齐的主要目的是为了减少 CPU 访问内存的次数。假设读取8个字节的数据，按照每次读取4个字节的速度，则8个字节需要 CPU 耗费2次读取操作。CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数。\n怎么使用内存对齐？ 我们可以用#progma pack(x)指定结构体以x为单位进行对齐。一般情况下使用方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #pragma pack(push) /* push current alignment to stack */ #pragma pack(1) /* set alignment to 1 byte boundary */ struct MyPackedData { char Data1; // 1 byte long Data2; // 8 byte(64位环境) char Data3; // 1 byte }; #pragma pack(pop) /* restore original alignment from stack */ int main() { cout \u0026lt;\u0026lt; alignof(MyPackedData) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; sizeof(MyPackedData) \u0026lt;\u0026lt; endl; // 10 return 0; } C++11之后提供了alignas关键字，允许往更大的字节数去对齐（有的平台不支持未对齐内存访问，alignas 的目的是允许你往更大的字节数去对齐，比如 char 对齐到32位供 SIMD load）。\n即 pack 是变小，alignas 是变大，用法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct alignas(1) Point // 使用g++能正常运行，但是在CLion中会报错，因为这样做是不合规范（ill-formed）的 { int a; char b; }p; cout \u0026lt;\u0026lt; alignof(p) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt; endl; // 8 #pragma pack(push) #pragma pack(1) struct Point2 { int a; char b; }p2; #pragma pop(pop) cout \u0026lt;\u0026lt; alignof(p2) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; sizeof(p2) \u0026lt;\u0026lt; endl; // 4 用户态与内核态 用户态/内核态的概念 CPU 指令可以直接操作硬件，而对于硬件的操作是非常复杂的，出问题的几率相当大，所以操作系统内核直接屏蔽了个人开发者对于硬件操作的可能。因为这个需求，硬件设备商直接提供了硬件级别的支持，做法就是对 CPU 指令设置了权限，不同级别的权限可以使用的 CPU 指令是有限制的。\n以 Intel CPU 为例，CPU 指令操作的权限划为4级：ring 0、ring 1、ring 2、ring 3。其中ring 0权限最高，可以使用所有 CPU 指令，ring 3 权限最低，仅能使用常规 CPU 指令，不能使用访问硬件资源的指令，比如 I/O读写、网卡访问、申请内存等。\nLinux 系统内核采用了：ring 0 和 ring 3 这2个权限\nring 0 被叫做 内核态，完全在操作系统内核中运行，由专门的内核线程执行其任务； ring 3 被叫做 用户态，在应用程序中运行，由用户线程执行其任务。 切换方式 从用户态到内核态切换可以通过三种方式，或者说会导致从用户态切换到内核态的操作：\n系统调用：系统调用本身就是中断，属于软件中断，跟硬件中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。比如我们使用库函数 fopen 打开文件，就会触发 open 系统调用。 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中。 外围设备中断：硬件中断，外围设备完成用户请求的操作之后，会向 CPU 发出中断信号，这时 CPU 会转去处理对应的中断处理程序。 切换过程 当发生用户态到内核态的切换时，会发生如下过程（本质上是从“用户程序”切换到“内核程序”）\n设置处理器至内核态；\n保存当前程序的寄存器（栈指针、程序计数器、通用寄存器）；\n将栈指针设置指向内核栈地址；\n执行中断处理程序；\n恢复之前保存的寄存器，从中断处理程序返回。\n具体流程参考：中断（系统调用）的具体过程\n中断（系统调用）的具体过程 总结： 用户运行库函数（系统调用的封装），函数里面其实是执行的 int 0x80 指令。系统调用先把系统调用号保存在 eax 寄存器中，然后执行 int 0x80 指令。int 0x80 指令先进行切换堆栈（找到进程的堆栈，将寄存器值压入到内核栈中，将 esp，ss 设置成对应内核栈的值），查找相应中断向量的中断处理程序(system_call)并调用，随后 system_call 从系统调用表中找到相应的系统调用进行调用，调用结束后从 system_call 中返回。\n中断一般有两个属性，中断号和中断处理程序（ISR，Interrupt Service Routine）。在内核中，有一个数组称为中断向量表，包含了中断号及其对应中断处理程序的指针。中断到来时，CPU 暂停当前执行的代码，根据中断的中断号，在中断向量表中找到对应的中断处理程序，并调用它。中断处理程序执行完成之后，CPU 会继续执行之前的代码。\n由于中断号是有限的，操作系统不舍得每一个系统调用对应一个中断号，而更倾向于用一个或少数几个中断号来对应所有的系统调用。Linux 则使用 int 0x80 来触发所有系统调用。每个系统调用对应一份系统调用号，这个系统调用号在执行 int 0x80 指令前会放置在某个固定的寄存器里（eax)，对应的中断代码会取得这个系统调用号，并且调用正确的函数。\n系统调用的详细过程 触发中断 用户程序在代码中调用系统调用，执行 int 指令前将系统调用号放入 eax 寄存器中，执行 int 0x80 指令（int 指令最终执行的函数是 system_call，该函数验证系统调用号的有效性，查找系统调用函数并执行，最后通过 itret 指令从中断处理程序返回）。\n切换堆栈（此步在 int 指令中完成） 在实际执行 0x80 号中断向量所对应的中断处理程序（system_call）之前，CPU 首先要进行堆栈切换，即从用户态切换到内核态。所谓的当前栈，指得是 esp（栈指针）的值所在的栈空间。如果 esp 的值位于用户栈的范围内，那么程序的当前栈就是用户栈，反之亦然。此外，寄存器 ss 的值还应该指向当前栈所在的页。\n所以，将当前栈由用户栈切换为内核栈（用户态切换到内核态）的实际行为就是：保存当前的 esp，ss 的值（保证存在内核栈上，int 指令发送后自动地由硬件完成），并将 esp，ss 的值设置为内核栈的相应值\n当 0x80 号中断发生的时候，cpu 除了切入内核态之外，还会自动完成下列几件事：\n（1）找到当前进程的内核栈（每一个进程都有自己的内核栈）\n（2）在内核栈中一次压入用户态的寄存器 ss、esp、eflags、cs、eip\n而当内核从系统调用返回的时候，须要调用 iret 指令来回到用户态，iret 指令则会从内核栈里弹出寄存器 ss、esp、eflags、cs、eip 的值，使得栈恢复到用户态的状态。\n中断时内核栈和用户栈的切换 中断处理程序 在 int 指令切换内核栈之后，程序就切换到了中断向量表中的 0x80 号中断处理程序。Linux 中 0x80 向量对应的中断处理程序是 system_call。\nsystem_call 中断服务程序首先检查系统调用号的有效性，再根据 eax 寄存器存储的系统调用号从系统调用表上找到相应的系统调用并调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // system_call的开头部分 ...... SAVE_ALL // 保存寄存器的值到栈中，以免被覆盖 ...... cmpl $(nr_syscalls), %eax // 比较eax寄存器中的值和系统调用号大1的值（验证系统调用号的有效性） jae syscall_badsys\t// 如果系统调用无效，指向syscall_badsys // 如果系统调用号有效，则会执行以下代码 syscall_call: call *sys_call_table(0, %eax, 4) // 查找中断服务程序并执行， sys_call_table其实就是系统调用表 ..... RESTORE_REGS // 恢复之前保存的寄存器 ...... iret // 从中断程序返回 恢复之前保存的寄存器，从中断处理程序返回，从内核态切换回用户态 缺页中断 在操作系统中，程序执行时需要访问的内存在虚拟内存中，不在物理内存中，此时就会发生缺页中断（该情况为硬件页缺失）。\n缺页中断的分类 软性页缺失：指页缺失发生时，相关的页已经被加载进内存，但是没有向 MMU（内存管理单元）注册的情况。操作系统只需要在 MMU 中注册相关页对应的物理地址即可。 硬性页缺失：硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。 无效页缺失：当程序访问的虚拟地址是不存在于虚拟地址空间内的时候，则发生无效页缺失。\n查看进程发生缺页中断的次数 ps -o majflt,minflt -C \u0026lt;program_name\u0026gt;\nps -o majflt,minflt -p \u0026lt;pid\u0026gt; majflt 代表 major fault，中文名叫大错误，minflt 代表 minor fault，中文名叫小错误。 majflt 表示需要读写磁盘，可能是内存对应页面在磁盘中需要load到物理内存中，也可能是此时物理内存不足，需要淘汰部分物理页面至磁盘中。 这两个数值表示一个进程自启动以来所发生的缺页中断的次数。\n缺页中断过程 当程序访问一个虚拟地址时，操作系统会检查该地址是否被映射到物理内存中，如果没有，则触发缺页中断：\n缺页中断会暂停程序执行，将控制权交给操作系统内核（进程会陷入内核态），保护程序现场，以免被操作系统破坏。\n内核会检查发生缺页中断的虚拟地址是否有效：\n如果虚拟地址有效，操作系统将会分配一个空闲物理页面，并把未被读取的数据从磁盘拷贝到物理内存所分配的页面中（没有空闲物理页面会触发页面置换算法），并更新页表信息。 如果虚拟地址无效，则操作系统会向进程发出一个信号或杀掉该进程。 当操作系统处理完缺页中断后，程序会恢复至发生缺页中断指令以前的状态，程序计数器重新指向这条指令。 缺页中断和缺页异常 缺页中断是指当程序访问一个虚拟内存地址时，对应的物理内存页不在主存中，需要从磁盘中加载到主存中，此时 CPU 就会发出一个中断请求，操作系统会响应中断请求，将对应的物理页加载到主存中，并重新执行产生缺页中断的指令。缺页中断是一种同步事件，也就是说，程序需要等待操作系统完成页的加载操作后才能继续执行。\n缺页异常是指当程序访问一个虚拟内存地址时，对应的物理内存页不在主存中，需要从磁盘中加载到主存中，但是此时 CPU 不会发出中断请求，而是将控制权交给操作系统，让操作系统处理缺页异常。缺页异常是一种异步事件，也就是说，程序不需要等待操作系统完成页的加载操作就可以继续执行。\n因此，缺页中断和缺页异常的主要区别在于它们是同步事件还是异步事件。缺页中断是同步事件，程序需要等待操作系统完成页的加载操作后才能继续执行；而缺页异常是异步事件，程序不需要等待操作系统完成页的加载操作就可以继续执行。\n虚表/虚表指针 为了实现 C++ 的多态，C++ 使用了一种动态绑定的技术，这个技术的核心是虚函数表。\n虚表 每个包含了虚函数的类都包含一个虚表； 一个类继承了包含虚函数的基类，那么这个类也会拥有自己的虚表； 虚表是一个指针数组，其元素是虚函数的指针，即虚表中每个元素对应一个虚函数的函数指针； 虚函数的的调用都需要经过虚表，普通函数即非虚函数，其调用并不需要经过虚表； 虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段； 虚表是属于类的，而不属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。 虚表指针 如有类中包含虚函数，编译器会自动在类中添加一个指针：*__vptr，用来指向该类的虚表； 类的对象在创建时便拥有虚表指针，且这个指针的值会自动被设置为指向类的唯一虚表。 类A的定义如下：\n1 2 3 4 5 6 7 8 9 class A { public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int m_data1, m_data2; }; 因为类A中存在（一个或多个）虚函数，编译器会自动给类A加上一个虚表指针（占8字节空间），所以sizeof(A)=16。 类A的虚表和虚表指针（__vptr）关系如下：\n虚表和虚表指针 多态相关 一个类的基类如果包含虚函数，那个这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表； 一旦继承类重写了基类的某个虚函数，那么它的虚表项也会同步更新，指向继承类重写的函数，否则指向它基类的同名函数。 通过基类的指针调用派生类中的函数称为（运行时）多态，经过虚表调用虚函数的过程称为动态绑定； 虚表和虚表指针的创建时机： 在编译的过程中编译器就为含有虚函数的类创建了虚表，并且编译器会在构造函数中插入一段代码，这段代码用来给虚指针赋值。因此虚表是在编译的过程中创建。 由于虚指针是基于对象的，所以对象在实例化的时候，虚指针就会创建，所以虚指针是在运行时创建。 此外，编译器规定一个模版函数不能为虚函数。因为模版机制需要在编译期间识别模版支持类型，对于每一种类型我们都要生成对应类型的函数体。如果这个模版函数为虚函数，我们不知道这个模版函数被生成了多少份对应类型的虚函数，也就不好确定虚表的大小，所以编译器禁止这一行为。\n更详细的内容参考：知乎：C++中虚函数、虚继承内存模型\n","permalink":"https://kdjlyy.cn/posts/tech/cs-basic-os/","summary":"内存模型, Linux用户空间内存分布, 程序内存空间, 虚拟内存, new, delete, malloc, free, brk, mmap, ptmalloc, tcmalloc, 内存对敌, 用户态, 内核态, 中断, 系统调用, 缺页中断, 虚表, 虚表指针","title":"计算机基础知识总结（系统篇）"},{"content":" 常见的Markdown语法，例如引用、标题、段落、无序列表、有序列表等不做讨论。\n参考：Sulv’s Blog、荷戟独彷徨、Memory、3rd\u0026rsquo;s Blog、Doit。\n字体种类 在Markdown中，使用\u0026lt;font\u0026gt;标签的face属性修改文字字体：\n1 2 3 \u0026lt;font face=\u0026#39;SimHei\u0026#39;\u0026gt;这是黑体\u0026lt;/font\u0026gt; \u0026lt;font face=\u0026#39;KaiTi\u0026#39;\u0026gt;这是楷体\u0026lt;/font\u0026gt; \u0026lt;font face=\u0026#39;Fangsong_GB2312\u0026#39;\u0026gt;这是仿宋_GB2312字体\u0026lt;/font\u0026gt; 这是黑体 这是楷体 这是仿宋_GB2312字体\n字体名称 字体写法 黑体 SimHei 宋体 SimSun 新宋体 NSimSun 仿宋 FangSong 楷体 KaiTi 仿宋_GB2312 FangSong_GB2312 楷体_GB2312 KaiTi_GB2312 微软雅黑 Microsoft YaHei 落霞文楷 LXGW WenKai 落霞文楷 Lite LXGW WenKai Lite 落霞文楷 Screen LXGW WenKai Screen 落霞文楷 TC LXGW WenKai TC 字号 1 2 3 4 5 6 7 \u0026lt;font size=\u0026#34;1\u0026#34;\u0026gt;这是1号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;2\u0026#34;\u0026gt;这是2号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;3\u0026#34;\u0026gt;这是3号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;4\u0026#34;\u0026gt;这是4号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;5\u0026#34;\u0026gt;这是5号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;6\u0026#34;\u0026gt;这是6号字体\u0026lt;/font\u0026gt; \u0026lt;font size=\u0026#34;7\u0026#34;\u0026gt;这是7号字体\u0026lt;/font\u0026gt; 这是1号字体\n这是2号字体 这是3号字体 这是4号字体 这是5号字体 这是6号字体 这是7号字体 字体颜色 1 2 3 4 \u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;这是红色字体\u0026lt;/font\u0026gt; \u0026lt;font color=\u0026#39;rgb(200, 100, 100)\u0026#39;\u0026gt;这是rgb(200, 100, 100)颜色字体\u0026lt;/font\u0026gt; \u0026lt;font color=\u0026#39;#FF00BB\u0026#39;\u0026gt;这是#FF00BB颜色字体\u0026lt;/font\u0026gt; \u0026lt;font style=\u0026#34;background: linear-gradient(to right, #ff1616, #36c945, #10a5ce, #0f0096, #a51eff, #ff1616);\u0026#34;\u0026gt;这是7色渐变颜色\u0026lt;/font\u0026gt; 这是红色字体 这是rgb(200, 100, 100)颜色字体 这是#FF00BB颜色字体\n这是7色渐变颜色\n待办列表 使用-[]表示一项待办，当完成待办后给中括号中添加x（不区分大小写，注意空格不可省略）即可，例如：\n1 2 3 - [x] 吃饭 - [x] 睡觉 - [ ] 写作业 吃饭 睡觉 写作业 脚注和页内跳转 脚注 1 2 3 这是一个简单的脚注[^1]，这是另一个脚注[^bignote]。 [^1]:这是第一个脚注 [^bignote]:这是第二脚注 这是一个简单的脚注1，这是另一个脚注2。\n页内跳转 1 2 3 4 5 6 7 // 1. 首先定义一个锚点： \u0026lt;span id=\u0026#34;jump\u0026#34;\u0026gt;**\u0026lt;u\u0026gt;《塞尔达传说 王国之泪》\u0026lt;/u\u0026gt;**\u0026lt;/span\u0026gt;（日语：ゼルダの伝説 ティアーズ オブ ザ キングダム，英语：The Legend of Zelda: Tears of the Kingdom）是一款由任天堂企划制作本部开发，任天堂发行的一款开放世界动作冒险游戏。本作为2017年发售的《塞尔达传说 旷野之息》的续作，也是塞尔达传说系列的第二十部作品，于2023年5月12日在任天堂Switch上发售。 // 2. 用markdown的语法写超链 点击查看[王国之泪的介绍](#jump) // 3. 点击超链文字就可以定位到跳转内容了 点击查看王国之泪的介绍\n《塞尔达传说 王国之泪》（日语：ゼルダの伝説 ティアーズ オブ ザ キングダム，英语：The Legend of Zelda: Tears of the Kingdom）是一款由任天堂企划制作本部开发，任天堂发行的一款开放世界动作冒险游戏。本作为2017年发售的《塞尔达传说 旷野之息》的续作，也是塞尔达传说系列的第二十部作品，于2023年5月12日在任天堂Switch上发售。\n另外，也可以用上标的方式进行页内跳转：\n1 王国之泪\u0026lt;sup\u0026gt;[[塞尔达传说 王国之泪]](#jump)\u0026lt;/sup\u0026gt;是什么游戏？ 王国之泪[塞尔达传说 王国之泪]是什么游戏？\n鼠标悬浮效果 1 \u0026lt;abbr title=\u0026#34;🙃🙃🙃\u0026#34;\u0026gt;鼠标悬浮这里\u0026lt;/abbr\u0026gt;可以看到详细的解释。 鼠标悬浮这里 可以看到详细的解释。\n自定义shortcodes Hugo博客通过简码方式插入pdf、bilibili以及博客文章内链等功能。\n为了防止被识别生效，调用样式均表示为{.{\u0026lt; xxx \u0026gt;}}，实际使用时去掉大括号中间的.即可。\n插入pdf 1 {.{\u0026lt; ppt src=\u0026#34;https://www.africau.edu/images/default/sample.pdf\u0026#34; \u0026gt;}} 插入bilibili视频 1 2 {.{\u0026lt; bilibili BV1WZ4y1a7MF \u0026gt;}} # 如果有集数（默认第一集），例如要播放第5集，则这样使用：{.{\u0026lt; bilibili BV1WZ4y1a7MF 5 \u0026gt;}} \u003c!DOCTYPE HTML\u003e 插入博客文章内链 1 2 {.{\u0026lt; innerlink src=\u0026#34;posts/tech/cs-basic-grammar.md\u0026#34; \u0026gt;}} # 卡片获取的文章长度默认是70，需要在config.yaml配置文件添加 summaryLength: 90，即设置为90 计算机基础知识总结（语法篇） 日期: 2023-05-09 \u0026nbsp; 标签: #C\u0026#43;\u0026#43;\u0026nbsp; #基础知识\u0026nbsp; 成员变量初始化 构造函数内部初始化和初始化列表 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。 对于内置类型，如int, float等，使用初始化列表和在构 ...... 代码折叠 1 2 3 4 5 6 7 8 9 {.{% code %}} ```cpp #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } ``` {.{% /code %}} 代码 1 2 3 4 5 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 文字位置 1 2 3 {.{\u0026lt; align left \u0026#34;文字居左\u0026#34; \u0026gt;}} {.{\u0026lt; align center \u0026#34;文字居中\u0026#34; \u0026gt;}} {.{\u0026lt; align right \u0026#34;文字居中\u0026#34; \u0026gt;}} 文字居左\n文字居中\n文字居中\n图片 figure标签是PaperMod主题自带的\n1 2 {.{\u0026lt; figure src=\u0026#34;https://kdjlyy.github.io/img/logo.ico\u0026#34; caption=\u0026#34;图片描述\u0026#34; width=\u0026#34;50%\u0026#34; height=\u0026#34;50%\u0026#34; align=\u0026#34;center\u0026#34; \u0026gt;}} {.{\u0026lt; figure src=\u0026#34;https://kdjlyy.github.io/img/logo.ico\u0026#34; title=\u0026#34;xxx\u0026#34; caption=\u0026#34;图片描述\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34; \u0026gt;}} 图片描述\n或者：\n1 2 3 4 \u0026lt;div style=\u0026#34;text-align:center;\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;display: block; margin: 0 auto;\u0026#34; src=\u0026#34;\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; \u0026gt; \u0026lt;span style=\u0026#34;font-size: 14px; color: grey;\u0026#34;\u0026gt;图片描述\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;br\u0026gt; 头像 Github卡片 1 {.{\u0026lt; github title=\u0026#34;kdjlyy/fastRPC\u0026#34; \u0026gt;}} Mermaid作图 1 2 3 4 5 6 7 8 \u0026lt;div align=center\u0026gt; \u0026lt;!-- 可以用html代码包裹该代码实现居中或其他排版 --\u0026gt; {.{\u0026lt;mermaid\u0026gt;}} flowchart LR a --\u0026gt; b \u0026amp; c --\u0026gt; d {.{\u0026lt;/mermaid\u0026gt;}} \u0026lt;/div\u0026gt; flowchart LR a --\u003e b \u0026 c --\u003e d 流程图 代码 1 2 3 4 5 6 {.{\u0026lt; mermaid \u0026gt;}}graph LR; A[Hard edge] --\u0026gt;|Link text| B(Round edge) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result one] C --\u0026gt;|Two| E[Result two] {.{\u0026lt; /mermaid \u0026gt;}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] 时序图 代码 1 2 3 4 5 6 7 8 9 10 11 12 {.{\u0026lt; mermaid \u0026gt;}}sequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! {.{\u0026lt; /mermaid \u0026gt;}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! 甘特图 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { {\u0026lt; mermaid \u0026gt;}}gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d { {\u0026lt; /mermaid \u0026gt;}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d 类图 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { {\u0026lt; mermaid \u0026gt;}}classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u0026lt;--\u0026gt; C2: Cool label { {\u0026lt; /mermaid \u0026gt;}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label 状态图 代码 1 2 3 4 5 6 7 8 {.{\u0026lt; mermaid \u0026gt;}}stateDiagram [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] {.{\u0026lt; /mermaid \u0026gt;}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] Git图 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 { {\u0026lt; mermaid \u0026gt;}} gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\u0026#34;ash\u0026#34; tag:\u0026#34;abc\u0026#34; branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release { {\u0026lt; /mermaid \u0026gt;}} gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\"ash\" tag:\"abc\" branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release 饼图 代码 1 2 3 4 5 6 7 \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; pie \u0026#34;Dogs\u0026#34; : 386 \u0026#34;Cats\u0026#34; : 85 \u0026#34;Rats\u0026#34; : 15 \u0026lt;/div\u0026gt; pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 Echarts作图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;echarts\u0026#34; style=\u0026#34;width: 600px;height:400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/echarts/5.1.1/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var myChart = echarts.init(document.getElementById(\u0026#39;echarts\u0026#39;)); myChart.setOption({ title: { text: \u0026#39;ECharts 示例\u0026#39; }, tooltip: {}, xAxis: { data: [\u0026#39;周一\u0026#39;, \u0026#39;周二\u0026#39;, \u0026#39;周三\u0026#39;, \u0026#39;周四\u0026#39;, \u0026#39;周五\u0026#39;, \u0026#39;周六\u0026#39;, \u0026#39;周日\u0026#39;] }, yAxis: {}, series: [{ name: \u0026#39;销量\u0026#39;, type: \u0026#39;bar\u0026#39;, data: [5, 20, 36, 10, 10, 20, 5] }] }); \u0026lt;/script\u0026gt; 其他 上标和下标 1 2 3 H\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;O C\u0026lt;sub\u0026gt;6\u0026lt;/sub\u0026gt;H\u0026lt;sub\u0026gt;12\u0026lt;/sub\u0026gt;O\u0026lt;sub\u0026gt;6\u0026lt;/sub\u0026gt; X\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; + Y\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; = Z\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt; H2O\nC6H12O6 Xn + Yn = Zn 公式 1 $$0.414213562373095048\\approx6\\*16^{-1}+a\\*16^{-2}+0\\*16^{-3}+\\cdots$$ $$0.414213562373095048\\approx6*16^{-1}+a*16^{-2}+0*16^{-3}+\\cdots$$\n高亮 1 \u0026lt;mark\u0026gt;高亮标记语言\u0026lt;/mark\u0026gt;显示段落中的重要文字部分。 高亮标记语言显示段落中的重要文字部分。\n这是第一个脚注\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n这是第二个脚注\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://kdjlyy.cn/posts/tech/markdown-note/","summary":"主要展示 PaperMod 主题中 Markdown 语法的页面效果","title":"PaperMod主题Markdown示例"},{"content":"成员变量初始化 构造函数内部初始化和初始化列表 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。\n对于内置类型，如int, float等，使用初始化列表和在构造函数体内初始化差别不大； 对于类类型来说，使用初始化列表会减少调用默认构造函数的次数，更加高效。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;A()\u0026#34; \u0026lt;\u0026lt; endl; } A(int _a) { a = _a; cout \u0026lt;\u0026lt; \u0026#34;A(_a)\u0026#34; \u0026lt;\u0026lt; endl; } private: int a; }; class B { public: B() { cout \u0026lt;\u0026lt; \u0026#34;B()\u0026#34; \u0026lt;\u0026lt; endl; } B(int _b) : b(_b), m_a(_b) { // 初始化列表初始化 // b = _b, m_a = A(_b); // 构造函数内部赋值操作 cout \u0026lt;\u0026lt; \u0026#34;B(_b)\u0026#34; \u0026lt;\u0026lt; endl; } private: int b; A m_a; }; int main(int argc, char** argv) { B b(100); } 这段代码输出：\n1 2 A(_a) B(_b) 如果不使用初始化列表，使用17行构造函数内部赋值的方式，会输出：\n1 2 3 A() A(_a) B(_b) 除了性能问题之外，有时候初始化列表是不可或缺的，以下几种情况必须使用初始化列表：\n类的const成员\n引用类型\nconst对象或引用只能初始化但是不能赋值，构造函数的函数体内只能做赋值而不是初始化。因此初始化const对象或引用的唯一机会是构造函数函数体之前的初始化列表中。\n没有默认构造函数的类类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class A { public: A(int a): i(a) {} int i; }; class B { public: A a ; B(const A\u0026amp; a1) { a = a1; // error: 类A不存在默认构造函数 } }; class C: public A { public: C(int _x): x(_x) {} // error: 类A不存在默认构造函数 private: int x; } 以上代码无法通过编译，因为B的构造函数中a=a1这一行会先调用A的默认构造函数来初始化a1，由于A没有默认的构造函数，所以无法执行，故而编译错误。\n如果基类没有默认构造函数，派生类必须在其初始化列表中显示调用基类的构造函数。\n构造函数调用顺序 调用基类构造函数，调用顺序按照他们的继承时声明的顺序。 调用内嵌成员对象的构造函数，调用顺序按照他们在类中声明的顺序。 调用派生类自己的构造函数体中的内容。 析构函数的调用顺序相反。\n更详细的：构造函数的执行可以分成两个阶段，初始化阶段和计算阶段，初始化阶段先于计算阶段。\n初始化阶段：所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。 计算阶段：一般用于执行构造函数体内的赋值操作。 所以，初始化列表总是先于构造函数体执行：基类初始化列表 → 基类的构造函数 → 派生类初始化列表 → 派生类的构造函数。\n成员变量初始化顺序 成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class A { private: int n1; int n2; public: A(): n2(0), n1(n2+1) {} void Print(){ cout \u0026lt;\u0026lt; \u0026#34;n1: \u0026#34; \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#34;, n2: \u0026#34; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt;endl; } }; int main() { A a; a.Print(); // 输出是：`n1: 18749281, n2: 0`，而不是`n1: 1, n2: 0` return 0; } const和constexpr constexpr关键字是C++11新增的，其作用包括：\n定义编译期常量[编译期常量]； 定义常量表达式函数[常量表达式函数]； 定义编译期常量对象[编译期常量对象]。 常量分为编译期常量、运行期常量。 编译期常量在编译阶段就可以确定其值，并将其结果展开到使用的地方，一般存放在rodata段。 运行期常量本质上是只读的变量（存放在栈区），编译时无法确定其值；运行时，无法修改其值。\nconst 可以定义编译期常量，也可以定义运行期常量； constexpr 只能定义编译期常量。 1 2 3 4 5 6 7 const int a = 10; // 编译期常量，存放在静态存储区的rodata段 int main() { int b = 20; // 栈 const int c = b; // 栈（运行期常量） // constexpr int c = b; Error: 因为b是一个普通变量，必须到运行期才能确定，constexpr无法修饰运行期常量。 } 普通函数必须在运行时才能执行，进而计算出结果。而常量表达式函数要求函数在编译期就计算出结果，运行时直接使用结果。也就是说将函数的执行从运行阶段转移到编译阶段，提升程序运行效率。 只需要在函数返回值类型前面加上constexpr关键字即可定义常量表达式函数，我们必须使用constexpr修饰的编译期常量来保存常量表达式函数的结果，否则常量表达式函数仍然会在运行期执行。\n1 2 3 4 5 6 7 8 constexpr int my_sum(int n) { if (n == 1) return 1; return n + my_sum(n - 1); } void test() { constexpr int a = my_sum(3); } 编译期常量对象的任何计算都在编译期完成。定义编译期常量对象，有以下几点要求：\n构造函数使用constexpr修饰，必须使用初始化列表对成员进行初始化； 对象调用的成员函数必须使用constexpr修饰。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Box { public: // 构造函数使用constexptr修饰，并且使用初始化列表对成员进行初始化。这就保证了对象成员m_l、m_w、m_h在编译期确定其值。 constexpr Box(int l, int w, int h) : m_l(l), m_w(w), m_h(h) {} // get_volume函数被定义为了常量表达式成员函数，调用该函数则会在编译阶段计算出结果。 constexpr int get_volume() const { return m_l * m_w * m_h; } // get_sum函数则是普通函数，该函数必须声明为const函数，否则无法被常量对象调用 int get_sum() const { return (m_l + m_w + m_h); } public: int m_l, m_w, m_h; }; void test() { constexpr Box box(10, 20, 30); // 程序编译期间调用常量表达式构造函数 constexpr int volume = box.get_volume(); // 在编译期计算出函数的执行结果，并赋值给编译期常量volume int my_sum = box.get_sum(); // 在运行期进行执行 } 单例模式 单例模式是一种设计模式，它确保一个类只有一个实例，并且提供一个全局访问点来访问它。 单例模式的实现一般需要将构造函数、析构函数私有化，禁用拷贝构造函数和赋值运算符，将成员变量和成员函数都设置成静态类型。\n懒汉单例模式实现 最简单的懒汉模式（在全局访问入口中声明静态变量。局部静态变量在C++11后也是线程安全的） 1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton { private: Singleton(); ~Singleton(); Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton* getInstance() { static Singleton instance; return \u0026amp;instance; } }; 加锁版本的懒汉单例模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Singleton { private: Singleton(); ~Singleton(); Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* instance; static pthread_mutex_t mutex; public: static Singleton* getInstance() { if (instance == nullptr) { pthread_mutex_lock(\u0026amp;mutex); instance = new Singleton(); pthread_mutex_unlock(\u0026amp;mutex); } return instance; } }; Singleton* Singleton::instance = nullptr; pthread_mutex_t Singleton::mutex = PTHREAD_MUTEX_INITIALIZER; 饿汉单例模式实现 饿汉单例模式天生线程安全，因为在main函数前已经初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton { private: Singleton(); ~Singleton(); Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; static Singleton* instance; public: static Singleton* getInstance() { return instance; } }; Singleton* Singleton::instance = new Singleton(); ","permalink":"https://kdjlyy.cn/posts/tech/cs-basic-grammar/","summary":"成员变量初始化 构造函数内部初始化和初始化列表 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。 对于内置类型，如int, float等，使用初始化列表和在构","title":"计算机基础知识总结（语法篇）"}]